!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_tracer_2d_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use tpcore, only : fv_tp_2d
use grid_tools, only : area,dx,dxa,dy,dya,rarea
use grid_utils, only : sina_u,sina_v
use mp_mod, only : domain,gid,ie,ied,is,isd,je,jed,js,jsd,ng,mp_reduce_max
use mpp_domains_mod, only : mpp_update_domains
use timingmodule, only : timing_off, timing_on
use tracer_2d_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine g_tracer_2d( q, dp1, g_dp1, mfx, g_mfx, mfy, g_mfy, cx, cy, npx, npy, npz, nq, hord, q_split, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mp_mod, only : mp_reduce_max

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: dp1(is:ie,js:je,npz)
real, intent(in) :: dt
real, intent(inout) :: g_dp1(is:ie,js:je,npz)
real, intent(inout) :: g_mfx(is:ie+1,js:je,npz)
real, intent(inout) :: g_mfy(is:ie,js:je+1,npz)
integer, intent(in) :: hord
integer, intent(in) :: id_divg
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: nq
real, intent(inout) :: q(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: c_global
real :: cmax(npz)
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: g_c_global
real :: g_cmax(npz)
real :: g_dp2(isd:ied,jsd:jed)
real :: g_frac
integer :: i
integer :: it
integer :: j
integer :: k
integer :: nsplt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (q_split .eq. 0) then
!jkim  call g_mp_reduce_max( cmax,g_cmax,npz )
  call mp_reduce_max( cmax,npz )
  call mp_reduce_max( g_cmax,npz )
  g_c_global = g_cmax(1)
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      g_c_global = g_c_global*(0.5-sign(0.5,cmax(k)-c_global))+g_cmax(k)*(0.5+sign(0.5,cmax(k)-c_global))
      c_global = max(cmax(k),c_global)
    end do
  endif
  nsplt = int(1.+c_global)
else
  nsplt = q_split
endif
g_frac = 0.
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do k = 1, npz
    do j = js, je
      do i = is, ie+1
        g_mfx(i,j,k) = g_frac*mfx(i,j,k)+g_mfx(i,j,k)*frac
        mfx(i,j,k) = mfx(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = is, ie
        g_mfy(i,j,k) = g_frac*mfy(i,j,k)+g_mfy(i,j,k)*frac
        mfy(i,j,k) = mfy(i,j,k)*frac
      end do
    end do
  end do
endif
do it = 1, nsplt
  do k = 1, npz
    do j = js, je
      do i = is, ie
        g_dp2(i,j) = g_dp1(i,j,k)-g_mfx(i+1,j,k)*rarea(i,j)+g_mfx(i,j,k)*rarea(i,j)-g_mfy(i,j+1,k)*rarea(i,j)+g_mfy(i,j,k)*rarea(i,&
&j)
        dp2(i,j) = dp1(i,j,k)+(mfx(i,j,k)-mfx(i+1,j,k)+mfy(i,j,k)-mfy(i,j+1,k))*rarea(i,j)
      end do
    end do
    do j = js, je
      do i = is, ie
        g_dp1(i,j,k) = g_dp2(i,j)
        dp1(i,j,k) = dp2(i,j)
      end do
    end do
  end do
end do

end subroutine g_tracer_2d


subroutine g_tracer_2d_1l( q, g_q, dp1, g_dp1, mfx, g_mfx, mfy, g_mfy, cx, g_cx, cy, g_cy, npx, npy, npz, nq, hord, q_split, k, q3,&
& g_q3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_tpcore, only : g_fv_tp_2d
use mp_mod, only : mp_reduce_max

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
real, intent(inout) :: g_cx(is:ie+1,jsd:jed)
real, intent(inout) :: g_cy(isd:ied,js:je+1)
real, intent(inout) :: g_dp1(is:ie,js:je)
real, intent(inout) :: g_mfx(is:ie+1,js:je)
real, intent(inout) :: g_mfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: g_q(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: g_q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
real, intent(inout) :: q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: cmax
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
real :: g_cmax
real :: g_dp2(isd:ied,jsd:jed)
real :: g_frac
real :: g_fx(is:ie+1,js:je)
real :: g_fy(is:ie,js:je+1)
real :: g_ra_x(is:ie,jsd:jed)
real :: g_ra_y(isd:ied,js:je)
real :: g_rdt
real :: g_xfx(is:ie+1,jsd:jed)
real :: g_yfx(isd:ied,js:je+1)
integer :: i
integer :: iq
integer :: it
integer :: j
integer :: nsplt
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      g_xfx(i,j) = g_cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      g_xfx(i,j) = g_cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      g_yfx(i,j) = g_cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      g_yfx(i,j) = g_cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (q_split .eq. 0) then
!jkim  call g_mp_reduce_max( cmax,g_cmax )
  call mp_reduce_max( cmax )
  call mp_reduce_max( g_cmax )
  nsplt = int(1.0001+cmax)
else
  nsplt = q_split
endif
g_frac = 0.
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      g_cx(i,j) = g_cx(i,j)*frac+g_frac*cx(i,j)
      cx(i,j) = cx(i,j)*frac
      g_xfx(i,j) = g_frac*xfx(i,j)+g_xfx(i,j)*frac
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      g_mfx(i,j) = g_frac*mfx(i,j)+g_mfx(i,j)*frac
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      g_cy(i,j) = g_cy(i,j)*frac+g_frac*cy(i,j)
      cy(i,j) = cy(i,j)*frac
      g_yfx(i,j) = g_frac*yfx(i,j)+g_yfx(i,j)*frac
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      g_mfy(i,j) = g_frac*mfy(i,j)+g_mfy(i,j)*frac
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie
    g_ra_x(i,j) = (-g_xfx(i+1,j))+g_xfx(i,j)
    ra_x(i,j) = area(i,j)+xfx(i,j)-xfx(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    g_ra_y(i,j) = (-g_yfx(i,j+1))+g_yfx(i,j)
    ra_y(i,j) = area(i,j)+yfx(i,j)-yfx(i,j+1)
  end do
end do
do it = 1, nsplt
  do j = js, je
    do i = is, ie
      g_dp2(i,j) = g_dp1(i,j)-g_mfx(i+1,j)*rarea(i,j)+g_mfx(i,j)*rarea(i,j)-g_mfy(i,j+1)*rarea(i,j)+g_mfy(i,j)*rarea(i,j)
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  do iq = 1, nq
    call g_fv_tp_2d( q(isd,jsd,iq),g_q(isd,jsd,iq),cx,g_cx,cy,g_cy,npx,npy,hord,fx,g_fx,fy,g_fy,xfx,g_xfx,yfx,g_yfx,area,ra_x,&
&g_ra_x,ra_y,g_ra_y,uniform_ppm,mfx=mfx,g_mfx=g_mfx,mfy=mfy,g_mfy=g_mfy )
    if (it .eq. nsplt) then
      do j = js, je
        do i = is, ie
          g_q3(i,j,k,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q3(i,j,k,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    else
      do j = js, je
        do i = is, ie
          g_q(i,j,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q(i,j,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    endif
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        g_dp1(i,j) = g_dp2(i,j)
        dp1(i,j) = dp2(i,j)
      end do
    end do
  endif
end do
if (id_divg .gt. 0) then
  g_rdt = -(g_frac*(1.*dt/(frac*dt*frac*dt)))
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      g_dp1(i,j) = g_rdt*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)+g_xfx(i+1,j)*rarea(i,j)*rdt-g_xfx(i,j)*rarea(i,j)*&
&rdt+g_yfx(i,j+1)*rarea(i,j)*rdt-g_yfx(i,j)*rarea(i,j)*rdt
      dp1(i,j) = (xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)*rdt
    end do
  end do
endif

end subroutine g_tracer_2d_1l


end module     g_tracer_2d_mod


