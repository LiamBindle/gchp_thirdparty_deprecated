!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_mapz_module
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use pre_direct
use constants_mod, only : pi,radius,rdgas,rvgas
use grid_tools, only : area,dx,dxa,dy,dya
use grid_utils, only : ptop,ptop_min,cubed_to_latlon, g_sum
use fill_module, only : fillz
use mp_mod, only : gid, domain
use mpp_domains_mod, only : mpp_update_domains
use mapz_module

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine g_compute_total_energy( is, ie, js, je, isd, ied, jsd, jed, km, u, g_u, v, g_v, pt, delp, q, pe, peln, hs, r_vir, cp, &
&rg, hlv, te_2d, ua, g_ua, va, g_va, teq, moist_phys, id_te )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use grid_utils, only : g_cubed_to_latlon

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: cp
integer, intent(in) :: ied
integer, intent(in) :: isd
integer, intent(in) :: jed
integer, intent(in) :: jsd
integer, intent(in) :: km
real, intent(in) :: delp(isd:ied,jsd:jed,km)
real, intent(in) :: g_u(isd:ied,jsd:jed+1,km)
real, intent(out) :: g_ua(isd:ied,jsd:jed,km)
real, intent(in) :: g_v(isd:ied+1,jsd:jed,km)
real, intent(out) :: g_va(isd:ied,jsd:jed,km)
real, intent(in) :: hlv
real, intent(in) :: hs(isd:ied,jsd:jed)
integer, intent(in) :: id_te
integer, intent(in) :: ie
integer, intent(in) :: is
integer, intent(in) :: je
integer, intent(in) :: js
logical, intent(in) :: moist_phys
real, intent(in) :: pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(in) :: peln(is:ie,km+1,js:je)
real, intent(in) :: pt(isd:ied,jsd:jed,km)
real, intent(in) :: q(isd:ied,jsd:jed,km)
real, intent(in) :: r_vir
real, intent(in) :: rg
real, intent(out) :: te_2d(is:ie,js:je)
real, intent(out) :: teq(is:ie,js:je)
real, intent(in) :: u(isd:ied,jsd:jed+1,km)
real, intent(out) :: ua(isd:ied,jsd:jed,km)
real, intent(in) :: v(isd:ied+1,jsd:jed,km)
real, intent(out) :: va(isd:ied,jsd:jed,km)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call g_cubed_to_latlon( u,g_u,v,g_v,ua,g_ua,va,g_va,dx,dy,dxa,dya,km )

end subroutine g_compute_total_energy


subroutine g_cs_limiters( im, a4, g_a4, iv )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r12 = 1./12.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: im
real, intent(inout) :: a4(4,im)
real, intent(inout) :: g_a4(4,im)
integer, intent(in) :: iv

!==============================================
! declare local variables
!==============================================
real :: a6da
real :: da1
real :: da2
real :: fmin
real :: g_a6da
real :: g_da1
real :: g_da2
real :: g_fmin
integer :: i

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (iv .eq. 0) then
  do i = 1, im
    if (abs(a4(3,i)-a4(2,i)) .lt. (-a4(4,i))) then
      g_fmin = g_a4(4,i)*((-(0.25*(a4(3,i)-a4(2,i))**2/(a4(4,i)*a4(4,i))))+r12)+g_a4(3,i)*(0.5*(a4(3,i)-a4(2,i))/a4(4,i))+g_a4(2,i)&
&*((-0.5)*(a4(3,i)-a4(2,i))/a4(4,i))+g_a4(1,i)
      fmin = a4(1,i)+0.25*(a4(3,i)-a4(2,i))**2/a4(4,i)+a4(4,i)*r12
      if (fmin .lt. 0.) then
        if (a4(1,i) .lt. a4(3,i) .and. a4(1,i) .lt. a4(2,i)) then
          g_a4(3,i) = g_a4(1,i)
          a4(3,i) = a4(1,i)
          g_a4(2,i) = g_a4(1,i)
          a4(2,i) = a4(1,i)
          g_a4(4,i) = 0.
          a4(4,i) = 0.
        else if (a4(3,i) .gt. a4(2,i)) then
          g_a4(4,i) = 3*g_a4(2,i)-3*g_a4(1,i)
          a4(4,i) = 3.*(a4(2,i)-a4(1,i))
          g_a4(3,i) = (-g_a4(4,i))+g_a4(2,i)
          a4(3,i) = a4(2,i)-a4(4,i)
        else
          g_a4(4,i) = 3*g_a4(3,i)-3*g_a4(1,i)
          a4(4,i) = 3.*(a4(3,i)-a4(1,i))
          g_a4(2,i) = (-g_a4(4,i))+g_a4(3,i)
          a4(2,i) = a4(3,i)-a4(4,i)
        endif
      endif
    endif
  end do
else
  do i = 1, im
    if ((a4(1,i)-a4(2,i))*(a4(1,i)-a4(3,i)) .ge. 0.) then
      g_a4(2,i) = g_a4(1,i)
      a4(2,i) = a4(1,i)
      g_a4(3,i) = g_a4(1,i)
      a4(3,i) = a4(1,i)
      g_a4(4,i) = 0.
      a4(4,i) = 0.
    else
      g_da1 = g_a4(3,i)-g_a4(2,i)
      da1 = a4(3,i)-a4(2,i)
      g_da2 = 2*g_da1*da1
      da2 = da1**2
      g_a6da = g_a4(4,i)*da1+g_da1*a4(4,i)
      a6da = a4(4,i)*da1
      if (a6da .lt. (-da2)) then
        g_a4(4,i) = 3*g_a4(2,i)-3*g_a4(1,i)
        a4(4,i) = 3.*(a4(2,i)-a4(1,i))
        g_a4(3,i) = (-g_a4(4,i))+g_a4(2,i)
        a4(3,i) = a4(2,i)-a4(4,i)
      else if (a6da .gt. da2) then
        g_a4(4,i) = 3*g_a4(3,i)-3*g_a4(1,i)
        a4(4,i) = 3.*(a4(3,i)-a4(1,i))
        g_a4(2,i) = (-g_a4(4,i))+g_a4(3,i)
        a4(2,i) = a4(3,i)-a4(4,i)
      endif
    endif
  end do
endif

end subroutine g_cs_limiters


subroutine g_cs_profile( a4, g_a4, delp, g_delp, km, i1, i2, iv, kord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: km
real, intent(inout) :: a4(4,i1:i2,km)
real, intent(in) :: delp(i1:i2,km)
real, intent(inout) :: g_a4(4,i1:i2,km)
real, intent(in) :: g_delp(i1:i2,km)
integer, intent(in) :: iv
integer, intent(in) :: kord

!==============================================
! declare local variables
!==============================================
real :: a4h
real :: a4i
real :: a4j
real :: a4k
real :: a4l
real :: a4m
real :: a4n
real :: a4o
real :: a4p
real :: a4q
real :: a_bot
real :: bet
real :: d4(i1:i2)
real :: g_a4h
real :: g_a4i
real :: g_a4j
real :: g_a4k
real :: g_a4l
real :: g_a4m
real :: g_a4n
real :: g_a4o
real :: g_a4p
real :: g_a4q
real :: g_a_bot
real :: g_bet
real :: g_d4(i1:i2)
real :: g_gam(i1:i2,km)
real :: g_grat
real :: g_lac
real :: g_pmp
real :: g_q(i1:i2,km+1)
real :: g_qh
real :: g_qi
real :: g_qj
real :: g_qk
real :: g_ql
real :: g_qm
real :: gam(i1:i2,km)
real :: grat
integer :: i
integer :: im
integer :: k
real :: lac
real :: pmp
real :: q(i1:i2,km+1)
real :: qh
real :: qi
real :: qj
real :: qk
real :: ql
real :: qm

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do i = i1, i2
  g_grat = g_delp(i,2)/delp(i,1)-g_delp(i,1)*(delp(i,2)/(delp(i,1)*delp(i,1)))
  grat = delp(i,2)/delp(i,1)
  g_bet = g_grat*(0.5+2*grat)
  bet = grat*(grat+0.5)
  g_q(i,1) = g_a4(1,i,2)/bet+g_a4(1,i,1)*(2*grat*(1.+grat)/bet)-g_bet*((2.*grat*(1.+grat)*a4(1,i,1)+a4(1,i,2))/(bet*bet))+g_grat*&
&((2*grat+2*(1.+grat))*a4(1,i,1)/bet)
  q(i,1) = (2.*grat*(grat+1.)*a4(1,i,1)+a4(1,i,2))/bet
  g_gam(i,1) = (-(g_bet*((1.+grat*(1.5+grat))/(bet*bet))))+g_grat*((1.5+2*grat)/bet)
  gam(i,1) = (1.+grat*(grat+1.5))/bet
end do
do k = 2, km
  do i = i1, i2
    g_d4(i) = g_delp(i,k-1)/delp(i,k)-g_delp(i,k)*(delp(i,k-1)/(delp(i,k)*delp(i,k)))
    d4(i) = delp(i,k-1)/delp(i,k)
    g_bet = 2*g_d4(i)-g_gam(i,k-1)
    bet = 2.+2.*d4(i)-gam(i,k-1)
    g_q(i,k) = g_a4(1,i,k-1)*(3/bet)+g_a4(1,i,k)*(3.*d4(i)/bet)-g_bet*((3.*(a4(1,i,k-1)+d4(i)*a4(1,i,k))-q(i,k-1))/(bet*bet))+&
&g_d4(i)*(3.*a4(1,i,k)/bet)-g_q(i,k-1)/bet
    q(i,k) = (3.*(a4(1,i,k-1)+d4(i)*a4(1,i,k))-q(i,k-1))/bet
    g_gam(i,k) = (-(g_bet*(d4(i)/(bet*bet))))+g_d4(i)/bet
    gam(i,k) = d4(i)/bet
  end do
end do
do i = i1, i2
  g_a_bot = g_d4(i)*(1.5+2*d4(i))
  a_bot = 1.+d4(i)*(d4(i)+1.5)
  g_q(i,km+1) = g_a4(1,i,km-1)/(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))+g_a4(1,i,km)*(2*d4(i)*(1.+d4(i))/(d4(i)*(0.5+d4(i))-a_bot*gam(i,&
&km)))+g_a_bot*((-(q(i,km)/(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))))+(2.*d4(i)*(1.+d4(i))*a4(1,i,km)+a4(1,i,km-1)-a_bot*q(i,km))*&
&gam(i,km)/((d4(i)*(0.5+d4(i))-a_bot*gam(i,km))*(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))))+g_d4(i)*((2*d4(i)+2*(1.+d4(i)))*a4(1,i,km)/&
&(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))-(2.*d4(i)*(1.+d4(i))*a4(1,i,km)+a4(1,i,km-1)-a_bot*q(i,km))*(0.5+2*d4(i))/((d4(i)*(0.5+d4(i)&
&)-a_bot*gam(i,km))*(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))))+g_gam(i,km)*((2.*d4(i)*(1.+d4(i))*a4(1,i,km)+a4(1,i,km-1)-a_bot*q(i,km)&
&)*a_bot/((d4(i)*(0.5+d4(i))-a_bot*gam(i,km))*(d4(i)*(0.5+d4(i))-a_bot*gam(i,km))))-g_q(i,km)*(a_bot/(d4(i)*(0.5+d4(i))-a_bot*&
&gam(i,km)))
  q(i,km+1) = (2.*d4(i)*(d4(i)+1.)*a4(1,i,km)+a4(1,i,km-1)-a_bot*q(i,km))/(d4(i)*(d4(i)+0.5)-a_bot*gam(i,km))
end do
do k = km, 1, -1
  do i = i1, i2
    g_q(i,k) = (-(g_gam(i,k)*q(i,k+1)+g_q(i,k+1)*gam(i,k)))+g_q(i,k)
    q(i,k) = q(i,k)-gam(i,k)*q(i,k+1)
  end do
end do
im = i2-i1+1
do k = 2, km
  do i = i1, i2
    g_gam(i,k) = (-g_a4(1,i,k-1))+g_a4(1,i,k)
    gam(i,k) = a4(1,i,k)-a4(1,i,k-1)
  end do
end do
do i = i1, i2
  if ((q(i,2)-q(i,1))*(q(i,3)-q(i,2)) .gt. 0.) then
    g_qm = g_a4(1,i,2)*(0.5-sign(0.5,a4(1,i,1)-a4(1,i,2)))+g_a4(1,i,1)*(0.5+sign(0.5,a4(1,i,1)-a4(1,i,2)))
    qm = max(a4(1,i,1),a4(1,i,2))
    g_q(i,2) = g_q(i,2)*(0.5+sign(0.5,qm-q(i,2)))+g_qm*(0.5-sign(0.5,qm-q(i,2)))
    q(i,2) = min(q(i,2),qm)
    g_ql = g_a4(1,i,2)*(0.5-sign(0.5,a4(1,i,2)-a4(1,i,1)))+g_a4(1,i,1)*(0.5+sign(0.5,a4(1,i,2)-a4(1,i,1)))
    ql = min(a4(1,i,1),a4(1,i,2))
    g_q(i,2) = g_q(i,2)*(0.5+sign(0.5,q(i,2)-ql))+g_ql*(0.5-sign(0.5,q(i,2)-ql))
    q(i,2) = max(q(i,2),ql)
  else if (iv .eq. 0) then
    g_q(i,2) = g_q(i,2)*(0.5-sign(0.5,0.-q(i,2)))
    q(i,2) = max(0.,q(i,2))
  endif
end do
do k = 3, km-1
  do i = i1, i2
    if (gam(i,k-1)*gam(i,k+1) .gt. 0.) then
      g_qk = g_a4(1,i,k-1)*(0.5+sign(0.5,a4(1,i,k-1)-a4(1,i,k)))+g_a4(1,i,k)*(0.5-sign(0.5,a4(1,i,k-1)-a4(1,i,k)))
      qk = max(a4(1,i,k-1),a4(1,i,k))
      g_q(i,k) = g_q(i,k)*(0.5+sign(0.5,qk-q(i,k)))+g_qk*(0.5-sign(0.5,qk-q(i,k)))
      q(i,k) = min(q(i,k),qk)
      g_qj = g_a4(1,i,k-1)*(0.5+sign(0.5,a4(1,i,k)-a4(1,i,k-1)))+g_a4(1,i,k)*(0.5-sign(0.5,a4(1,i,k)-a4(1,i,k-1)))
      qj = min(a4(1,i,k-1),a4(1,i,k))
      g_q(i,k) = g_q(i,k)*(0.5+sign(0.5,q(i,k)-qj))+g_qj*(0.5-sign(0.5,q(i,k)-qj))
      q(i,k) = max(q(i,k),qj)
    else if (iv .eq. 0) then
      g_q(i,k) = g_q(i,k)*(0.5-sign(0.5,0.-q(i,k)))
      q(i,k) = max(0.,q(i,k))
    endif
  end do
end do
do i = i1, i2
  if ((q(i,km)-q(i,km-1))*(q(i,km+1)-q(i,km)) .gt. 0.) then
    g_qi = g_a4(1,i,km-1)*(0.5+sign(0.5,a4(1,i,km-1)-a4(1,i,km)))+g_a4(1,i,km)*(0.5-sign(0.5,a4(1,i,km-1)-a4(1,i,km)))
    qi = max(a4(1,i,km-1),a4(1,i,km))
    g_q(i,km) = g_q(i,km)*(0.5+sign(0.5,qi-q(i,km)))+g_qi*(0.5-sign(0.5,qi-q(i,km)))
    q(i,km) = min(q(i,km),qi)
    g_qh = g_a4(1,i,km-1)*(0.5+sign(0.5,a4(1,i,km)-a4(1,i,km-1)))+g_a4(1,i,km)*(0.5-sign(0.5,a4(1,i,km)-a4(1,i,km-1)))
    qh = min(a4(1,i,km-1),a4(1,i,km))
    g_q(i,km) = g_q(i,km)*(0.5+sign(0.5,q(i,km)-qh))+g_qh*(0.5-sign(0.5,q(i,km)-qh))
    q(i,km) = max(q(i,km),qh)
  else if (iv .eq. 0) then
    g_q(i,km) = g_q(i,km)*(0.5-sign(0.5,0.-q(i,km)))
    q(i,km) = max(0.,q(i,km))
  endif
end do
do k = 1, km
  do i = i1, i2
    g_a4(2,i,k) = g_q(i,k)
    a4(2,i,k) = q(i,k)
    g_a4(3,i,k) = g_q(i,k+1)
    a4(3,i,k) = q(i,k+1)
  end do
end do
do i = i1, i2
  if (a4(2,i,1)*a4(1,i,1) .le. 0.) then
    g_a4(2,i,1) = 0.
    a4(2,i,1) = 0.
  endif
  if (a4(1,i,km)*a4(3,i,km) .le. 0.) then
    g_a4(3,i,km) = 0.
    a4(3,i,km) = 0.
  endif
end do
do k = 1, 2
  do i = i1, i2
    g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
    a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
  end do
  call g_cs_limiters( im,a4(1,i1,k),g_a4(1,i1,k),1 )
end do
do k = 3, km-2
  do i = i1, i2
    g_pmp = g_a4(1,i,k)-2*g_gam(i,k+1)
    pmp = a4(1,i,k)-2.*gam(i,k+1)
    g_lac = 1.5*g_gam(i,k+2)+g_pmp
    lac = pmp+1.5*gam(i,k+2)
    g_a4n = g_a4(1,i,k)*(0.5+sign(0.5,pmp-a4(1,i,k)))+g_pmp*(0.5-sign(0.5,pmp-a4(1,i,k)))
    a4n = min(a4(1,i,k),pmp)
    g_a4o = g_a4n*(0.5+sign(0.5,lac-a4n))+g_lac*(0.5-sign(0.5,lac-a4n))
    a4o = min(a4n,lac)
    g_a4m = g_a4(2,i,k)*(0.5+sign(0.5,a4(2,i,k)-a4o))+g_a4o*(0.5-sign(0.5,a4(2,i,k)-a4o))
    a4m = max(a4(2,i,k),a4o)
    g_a4p = g_a4(1,i,k)*(0.5+sign(0.5,a4(1,i,k)-pmp))+g_pmp*(0.5-sign(0.5,a4(1,i,k)-pmp))
    a4p = max(a4(1,i,k),pmp)
    g_a4q = g_a4p*(0.5+sign(0.5,a4p-lac))+g_lac*(0.5-sign(0.5,a4p-lac))
    a4q = max(a4p,lac)
    g_a4(2,i,k) = g_a4m*(0.5+sign(0.5,a4q-a4m))+g_a4q*(0.5-sign(0.5,a4q-a4m))
    a4(2,i,k) = min(a4m,a4q)
    g_pmp = g_a4(1,i,k)+2*g_gam(i,k)
    pmp = a4(1,i,k)+2.*gam(i,k)
    g_lac = (-1.5)*g_gam(i,k-1)+g_pmp
    lac = pmp-1.5*gam(i,k-1)
    g_a4i = g_a4(1,i,k)*(0.5+sign(0.5,pmp-a4(1,i,k)))+g_pmp*(0.5-sign(0.5,pmp-a4(1,i,k)))
    a4i = min(a4(1,i,k),pmp)
    g_a4j = g_a4i*(0.5+sign(0.5,lac-a4i))+g_lac*(0.5-sign(0.5,lac-a4i))
    a4j = min(a4i,lac)
    g_a4h = g_a4(3,i,k)*(0.5+sign(0.5,a4(3,i,k)-a4j))+g_a4j*(0.5-sign(0.5,a4(3,i,k)-a4j))
    a4h = max(a4(3,i,k),a4j)
    g_a4k = g_a4(1,i,k)*(0.5+sign(0.5,a4(1,i,k)-pmp))+g_pmp*(0.5-sign(0.5,a4(1,i,k)-pmp))
    a4k = max(a4(1,i,k),pmp)
    g_a4l = g_a4k*(0.5+sign(0.5,a4k-lac))+g_lac*(0.5-sign(0.5,a4k-lac))
    a4l = max(a4k,lac)
    g_a4(3,i,k) = g_a4h*(0.5+sign(0.5,a4l-a4h))+g_a4l*(0.5-sign(0.5,a4l-a4h))
    a4(3,i,k) = min(a4h,a4l)
    g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
    a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
  end do
  if (iv .eq. 0) then
    call g_cs_limiters( im,a4(1,i1,k),g_a4(1,i1,k),0 )
  endif
end do
do k = km-1, km
  do i = i1, i2
    g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
    a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
  end do
  call g_cs_limiters( im,a4(1,i1,k),g_a4(1,i1,k),1 )
end do

end subroutine g_cs_profile


subroutine g_lagrangian_to_eulerian( consv, ps, pe, g_pe, delp, g_delp, pkz, g_pkz, pk, g_pk, mdt, km, is, ie, js, je, isd, ied, &
&jsd, jed, nq, u, g_u, v, g_v, w, delz, g_delz, pt, g_pt, q, g_q, hs, grav, r_vir, cp, akap, kord_mt, kord_tr, kord_tm, peln, &
&g_peln, te0_2d, ng, ua, g_ua, va, g_va, omga, g_omga, te, g_te, pem, fill, reproduce_sum, ak, bk, ks, ze0, g_ze0, remap_t, &
&hydrostatic, hybrid_z, ktop, ncnst )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use grid_utils, only : g_cubed_to_latlon
use fill_module, only : g_fillz

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: km
real, intent(in) :: ak(km+1)
real, intent(in) :: akap
real, intent(in) :: bk(km+1)
real, intent(in) :: consv
real, intent(in) :: cp
integer, intent(in) :: ied
integer, intent(in) :: isd
integer, intent(in) :: jed
integer, intent(in) :: jsd
real, intent(inout) :: delp(isd:ied,jsd:jed,km)
integer, intent(in) :: ie
integer, intent(in) :: is
integer, intent(in) :: je
integer, intent(in) :: js
real, intent(inout) :: delz(is:ie,js:je,km)
logical, intent(in) :: fill
real, intent(inout) :: g_delp(isd:ied,jsd:jed,km)
real, intent(inout) :: g_delz(is:ie,js:je,km)
real, intent(inout) :: g_omga(isd:ied,jsd:jed,km)
real, intent(inout) :: g_pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(out) :: g_peln(is:ie,km+1,js:je)
real, intent(inout) :: g_pk(is:ie,js:je,km+1)
real, intent(out) :: g_pkz(is:ie,js:je,km)
real, intent(inout) :: g_pt(isd:ied,jsd:jed,km)
integer, intent(in) :: ncnst
real, intent(inout) :: g_q(isd:ied,jsd:jed,km,ncnst)
real, intent(out) :: g_te(is:ie,js:je,km)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1,km)
real, intent(inout) :: g_ua(isd:ied,jsd:jed,km)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed,km)
real, intent(inout) :: g_va(isd:ied,jsd:jed,km)
real, intent(inout) :: g_ze0(is:ie,js:je,km+1)
real, intent(in) :: grav
real, intent(in) :: hs(isd:ied,jsd:jed)
logical, intent(in) :: hybrid_z
logical, intent(in) :: hydrostatic
integer, intent(in) :: kord_mt
integer, intent(in) :: kord_tm
integer, intent(in) :: kord_tr
integer, intent(in) :: ks
integer, intent(in) :: ktop
real, intent(in) :: mdt
integer, intent(in) :: ng
integer, intent(in) :: nq
real, intent(inout) :: omga(isd:ied,jsd:jed,km)
real, intent(inout) :: pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(out) :: peln(is:ie,km+1,js:je)
real, intent(inout) :: pem(is-1:ie+1,km+1,js-1:je+1)
real, intent(inout) :: pk(is:ie,js:je,km+1)
real, intent(out) :: pkz(is:ie,js:je,km)
real, intent(inout) :: ps(isd:ied,jsd:jed)
real, intent(inout) :: pt(isd:ied,jsd:jed,km)
real, intent(inout) :: q(isd:ied,jsd:jed,km,ncnst)
real, intent(in) :: r_vir
logical, intent(in) :: remap_t
logical, intent(in) :: reproduce_sum
real, intent(out) :: te(is:ie,js:je,km)
real, intent(in) :: te0_2d(is:ie,js:je)
real, intent(inout) :: u(isd:ied,jsd:jed+1,km)
real, intent(inout) :: ua(isd:ied,jsd:jed,km)
real, intent(inout) :: v(isd:ied+1,jsd:jed,km)
real, intent(inout) :: va(isd:ied,jsd:jed,km)
real, intent(inout) :: w(isd:ied,jsd:jed,km)
real, intent(inout) :: ze0(is:ie,js:je,km+1)

!==============================================
! declare local variables
!==============================================
real :: ak1
real :: bkh
real :: deng(is:ie,km)
real :: dlnp
real :: dp2(is:ie,km)
real :: dtmp
real :: g_deng(is:ie,km)
real :: g_dlnp
real :: g_dp2(is:ie,km)
real :: g_dtmp
real :: g_gz(is:ie)
real :: g_help_x
real :: g_help_y
real :: g_pe0(is:ie+1,km+1)
real :: g_pe1(is:ie,km+1)
real :: g_pe2(is:ie,km+1)
real :: g_pe3(is:ie+1,km+1)
real :: g_phis(is:ie,km+1)
real :: g_pk1(is:ie,km+1)
real :: g_pk2(is:ie,km+1)
real :: g_pn2(is:ie,km+1)
real :: g_q2(is:ie,km)
real :: g_tmp
real :: g_tpe
real :: g_ze1(is:ie,km+1)
real :: g_ze2(is:ie,km+1)
real :: gz(is:ie)
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_m
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: help_r
integer :: help_s
integer :: help_t
integer :: help_u
integer :: help_v
integer :: help_w
real :: help_x
real :: help_y
integer :: i
integer :: iq
integer :: j
integer :: k
real :: k1k
logical :: k_loop
integer :: k_next
real :: kapag
integer :: kp
integer :: n
real :: pe0(is:ie+1,km+1)
real :: pe1(is:ie,km+1)
real :: pe2(is:ie,km+1)
real :: pe3(is:ie+1,km+1)
real :: phis(is:ie,km+1)
real :: pk1(is:ie,km+1)
real :: pk2(is:ie,km+1)
real :: pn2(is:ie,km+1)
real :: q2(is:ie,km)
real :: rcp
real :: rg
real :: te_2d(is:ie,js:je)
logical :: te_map
real :: tmp
real :: tpe
real :: ze1(is:ie,km+1)
real :: ze2(is:ie,km+1)
real :: zsum(is:ie,js:je)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
k1k = akap/(1.-akap)
kapag = -(akap/grav)
rg = akap*cp
rcp = 1./cp
ak1 = (akap+1.)/akap
if (kord_tm .lt. 0) then
  te_map =  .false. 
  do j = js, je
    do k = 2, km+1
      do i = is, ie
        g_peln(i,k,j) = g_pe(i,k,j)*(1./pe(i,k,j))
        peln(i,k,j) = log(pe(i,k,j))
      end do
    end do
  end do
  if (remap_t) then
    do k = 1, km
      do j = js, je
        do i = is, ie
          g_pt(i,j,k) = (-(g_peln(i,k+1,j)*(pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))*rg/(rg*(peln(i,k+1,j)-peln(i,k,j))*rg*(peln(i,k+1,j)-&
&peln(i,k,j))))))+g_peln(i,k,j)*(pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))*rg/(rg*(peln(i,k+1,j)-peln(i,k,j))*rg*(peln(i,k+1,j)-&
&peln(i,k,j))))+g_pk(i,j,k+1)*(pt(i,j,k)/(rg*(peln(i,k+1,j)-peln(i,k,j))))-g_pk(i,j,k)*(pt(i,j,k)/(rg*(peln(i,k+1,j)-&
&peln(i,k,j))))+g_pt(i,j,k)*((pk(i,j,k+1)-pk(i,j,k))/(rg*(peln(i,k+1,j)-peln(i,k,j))))
          pt(i,j,k) = pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))/(rg*(peln(i,k+1,j)-peln(i,k,j)))
        end do
      end do
    end do
  endif
else
  te_map =  .true. 
  call g_pkez( km,is,ie,js,je,pe,g_pe,pk,g_pk,akap,peln,g_peln,pkz,g_pkz )
  call g_cubed_to_latlon( u,g_u,v,g_v,ua,g_ua,va,g_va,dx,dy,dxa,dya,km )
  do k = 1, km
    do j = js, je
      do i = is, ie
        g_te(i,j,k) = g_pkz(i,j,k)*pt(i,j,k)+g_pt(i,j,k)*pkz(i,j,k)+g_ua(i,j,k)*ua(i,j,k)+g_va(i,j,k)*va(i,j,k)
        te(i,j,k) = 0.5*(ua(i,j,k)**2+va(i,j,k)**2)+pt(i,j,k)*pkz(i,j,k)
      end do
    end do
  end do
endif
if (( .not. hydrostatic) .and. ( .not. hybrid_z)) then
  do k = 1, km
    do j = js, je
      do i = is, ie
        g_delz(i,j,k) = g_delp(i,j,k)*(delz(i,j,k)/(delp(i,j,k)*delp(i,j,k)))-g_delz(i,j,k)/delp(i,j,k)
        delz(i,j,k) = -(delz(i,j,k)/delp(i,j,k))
      end do
    end do
  end do
endif
do j = js, je+1
  do k = 1, km+1
    do i = is, ie
      g_pe1(i,k) = g_pe(i,k,j)
      pe1(i,k) = pe(i,k,j)
    end do
  end do
  do i = is, ie
    g_pe2(i,1) = 0.
    pe2(i,1) = ptop
    g_pe2(i,km+1) = g_pe(i,km+1,j)
    pe2(i,km+1) = pe(i,km+1,j)
  end do
  if (j .lt. je+1) then
    if (hybrid_z) then
      do i = is, ie
        g_ze1(i,km+1) = g_ze0(i,j,km+1)
        ze1(i,km+1) = ze0(i,j,km+1)
      end do
      do k = km, 1, -1
        do i = is, ie
          g_ze1(i,k) = (-g_delz(i,j,k))+g_ze1(i,k+1)
          ze1(i,k) = ze1(i,k+1)-delz(i,j,k)
        end do
      end do
      do k = 2, km+1
        do i = is, ie
          g_ze2(i,k) = g_ze0(i,j,k)
          ze2(i,k) = ze0(i,j,k)
        end do
      end do
      do i = is, ie
        g_ze2(i,1) = g_ze1(i,1)
        ze2(i,1) = ze1(i,1)
        g_ze0(i,j,1) = g_ze1(i,1)
        ze0(i,j,1) = ze1(i,1)
      end do
      do k = 1, km
        do i = is, ie
          g_deng(i,k) = (-(g_delp(i,j,k)/delz(i,j,k)))+g_delz(i,j,k)*(delp(i,j,k)/(delz(i,j,k)*delz(i,j,k)))
          deng(i,k) = -(delp(i,j,k)/delz(i,j,k))
        end do
      end do
      help_h = abs(kord_tm)
      call g_remap_z( km,ze1,g_ze1,deng,g_deng,km,ze2,g_ze2,deng,g_deng,is,ie,help_h )
      do k = 1, km
        do i = is, ie
          g_delz(i,j,k) = g_ze2(i,k+1)-g_ze2(i,k)
          delz(i,j,k) = ze2(i,k+1)-ze2(i,k)
        end do
      end do
      do k = 1, km-1
        do i = is, ie
          g_dp2(i,k) = -(g_delz(i,j,k)*deng(i,k)+g_deng(i,k)*delz(i,j,k))
          dp2(i,k) = -(deng(i,k)*delz(i,j,k))
          g_pe2(i,k+1) = g_dp2(i,k)+g_pe2(i,k)
          pe2(i,k+1) = pe2(i,k)+dp2(i,k)
        end do
      end do
      do i = is, ie
        g_dp2(i,km) = g_pe2(i,km+1)-g_pe2(i,km)
        dp2(i,km) = pe2(i,km+1)-pe2(i,km)
      end do
    else
      do k = 2, ks+1
        do i = is, ie
          g_pe2(i,k) = 0.
          pe2(i,k) = ak(k)
        end do
      end do
      do k = ks+2, km
        do i = is, ie
          g_pe2(i,k) = g_pe(i,km+1,j)*bk(k)
          pe2(i,k) = ak(k)+bk(k)*pe(i,km+1,j)
        end do
      end do
      do k = 1, km
        do i = is, ie
          g_dp2(i,k) = g_pe2(i,k+1)-g_pe2(i,k)
          dp2(i,k) = pe2(i,k+1)-pe2(i,k)
        end do
      end do
    endif
    do k = 1, km
      do i = is, ie
        g_delp(i,j,k) = g_dp2(i,k)
        delp(i,j,k) = dp2(i,k)
      end do
    end do
    if (nq .ne. 0) then
      do iq = 1, nq
        call g_map1_q2( km,pe1,g_pe1,q(isd,jsd,1,iq),g_q(isd,jsd,1,iq),km,pe2,g_pe2,q2,g_q2,dp2,g_dp2,is,ie,0,kord_tr,j,isd,ied,&
&jsd,jed )
        if (fill) then
          help_i = ie-is+1
          call g_fillz( help_i,km,1,q2,g_q2,dp2,g_dp2 )
        endif
        do k = 1, km
          do i = is, ie
            g_q(i,j,k,iq) = g_q2(i,k)
            q(i,j,k,iq) = q2(i,k)
          end do
        end do
      end do
    endif
    do k = 1, km+1
      do i = is, ie
        g_pk1(i,k) = g_pk(i,j,k)
        pk1(i,k) = pk(i,j,k)
      end do
    end do
    do i = is, ie
      g_pk2(i,1) = g_pk1(i,1)
      pk2(i,1) = pk1(i,1)
      g_pk2(i,km+1) = g_pk1(i,km+1)
      pk2(i,km+1) = pk1(i,km+1)
    end do
    do k = 2, km
      do i = is, ie
        g_pk2(i,k) = g_pe2(i,k)*akap*pe2(i,k)**(akap-1)
        pk2(i,k) = pe2(i,k)**akap
      end do
    end do
    if (te_map) then
      do i = is, ie
        g_phis(i,km+1) = 0.
        phis(i,km+1) = hs(i,j)
      end do
      do k = km, 1, -1
        do i = is, ie
          g_phis(i,k) = g_phis(i,k+1)+g_pk1(i,k+1)*pt(i,j,k)-g_pk1(i,k)*pt(i,j,k)+g_pt(i,j,k)*(pk1(i,k+1)-pk1(i,k))
          phis(i,k) = phis(i,k+1)+pt(i,j,k)*(pk1(i,k+1)-pk1(i,k))
        end do
      end do
      do k = 1, km+1
        do i = is, ie
          g_phis(i,k) = g_pe1(i,k)*phis(i,k)+g_phis(i,k)*pe1(i,k)
          phis(i,k) = phis(i,k)*pe1(i,k)
        end do
      end do
      do k = 1, km
        do i = is, ie
          g_te(i,j,k) = (-(g_pe1(i,k+1)*((phis(i,k+1)-phis(i,k))/((pe1(i,k+1)-pe1(i,k))*(pe1(i,k+1)-pe1(i,k))))))+g_pe1(i,k)*&
&((phis(i,k+1)-phis(i,k))/((pe1(i,k+1)-pe1(i,k))*(pe1(i,k+1)-pe1(i,k))))+g_phis(i,k+1)/(pe1(i,k+1)-pe1(i,k))-g_phis(i,k)/&
&(pe1(i,k+1)-pe1(i,k))+g_te(i,j,k)
          te(i,j,k) = te(i,j,k)+(phis(i,k+1)-phis(i,k))/(pe1(i,k+1)-pe1(i,k))
        end do
      end do
      call g_map1_ppm( km,pe1,g_pe1,te,g_te,km,pe2,g_pe2,te,g_te,is,ie,j,is,ie,js,je,1,kord_tm )
    else
      if (remap_t) then
        do k = 1, km+1
          do i = is, ie
            g_pn2(i,k) = g_pe2(i,k)*(1./pe2(i,k))
            pn2(i,k) = log(pe2(i,k))
          end do
        end do
        help_j = abs(kord_tm)
        call g_map1_ppm( km,peln(is,1,j),g_peln(is,1,j),pt,g_pt,km,pn2,g_pn2,pt,g_pt,is,ie,j,isd,ied,jsd,jed,1,help_j )
      else
        help_k = abs(kord_tm)
        call g_map1_ppm( km,pk1,g_pk1,pt,g_pt,km,pk2,g_pk2,pt,g_pt,is,ie,j,isd,ied,jsd,jed,1,help_k )
      endif
    endif
    if ( .not. hydrostatic) then
      if ( .not. hybrid_z) then
        help_m = abs(kord_tm)
        call g_map1_ppm( km,pe1,g_pe1,delz,g_delz,km,pe2,g_pe2,delz,g_delz,is,ie,j,is,ie,js,je,1,help_m )
        do k = 1, km
          do i = is, ie
            g_delz(i,j,k) = (-(g_delz(i,j,k)*dp2(i,k)))-g_dp2(i,k)*delz(i,j,k)
            delz(i,j,k) = -(delz(i,j,k)*dp2(i,k))
          end do
        end do
      endif
    endif
    do k = 2, km
      do i = is, ie
        g_pk(i,j,k) = g_pk2(i,k)
        pk(i,j,k) = pk2(i,k)
      end do
    end do
    do i = is, ie
      g_pe3(i,1) = 0.
      pe3(i,1) = 0.
    end do
    do k = 2, km+1
      do i = is, ie
        g_pe3(i,k) = g_omga(i,j,k-1)
        pe3(i,k) = omga(i,j,k-1)
      end do
    end do
    do k = 1, km+1
      do i = is, ie
        g_pe0(i,k) = g_peln(i,k,j)
        pe0(i,k) = peln(i,k,j)
      end do
    end do
    if (hybrid_z) then
      do k = 2, km+1
        do i = is, ie
          g_peln(i,k,j) = g_pe2(i,k)*(1./pe2(i,k))
          peln(i,k,j) = log(pe2(i,k))
        end do
      end do
    else
      if (remap_t) then
        do k = 1, km+1
          do i = is, ie
            g_peln(i,k,j) = g_pn2(i,k)
            peln(i,k,j) = pn2(i,k)
          end do
        end do
      else
        do k = 2, ks+1
          g_tmp = 0.
          tmp = log(ak(k))
          do i = is, ie
            g_peln(i,k,j) = g_tmp
            peln(i,k,j) = tmp
          end do
        end do
        do k = ks+2, km+1
          do i = is, ie
            g_peln(i,k,j) = g_pe2(i,k)*(1./pe2(i,k))
            peln(i,k,j) = log(pe2(i,k))
          end do
        end do
        if (ptop .lt. ptop_min) then
          do i = is, ie
            g_peln(i,1,j) = g_peln(i,2,j)
            peln(i,1,j) = peln(i,2,j)-ak1
          end do
        else
          g_tmp = 0.
          tmp = log(ptop)
          do i = is, ie
            g_peln(i,1,j) = g_tmp
            peln(i,1,j) = tmp
          end do
        endif
      endif
    endif
    if (hydrostatic) then
      do k = 1, km
        do i = is, ie
          g_pkz(i,j,k) = (-(g_peln(i,k+1,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-&
&peln(i,k,j))))))+g_peln(i,k,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-peln(i,&
&k,j))))+g_pk2(i,k+1)/(akap*(peln(i,k+1,j)-peln(i,k,j)))-g_pk2(i,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
          pkz(i,j,k) = (pk2(i,k+1)-pk2(i,k))/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        end do
      end do
    else
      if (ktop .gt. 1) then
        do k = 1, ktop-1
          do i = is, ie
            g_pkz(i,j,k) = (-(g_peln(i,k+1,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-&
&peln(i,k,j))))))+g_peln(i,k,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-&
&peln(i,k,j))))+g_pk2(i,k+1)/(akap*(peln(i,k+1,j)-peln(i,k,j)))-g_pk2(i,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
            pkz(i,j,k) = (pk2(i,k+1)-pk2(i,k))/(akap*(peln(i,k+1,j)-peln(i,k,j)))
          end do
        end do
      endif
      do k = ktop, km
        do i = is, ie
          g_pkz(i,j,k) = g_delp(i,j,k)*kapag*pt(i,j,k)/(delz(i,j,k)*(1.+r_vir*q(i,j,k,1)))*k1k*(kapag*delp(i,j,k)*pt(i,j,k)/&
&(delz(i,j,k)*(1.+r_vir*q(i,j,k,1))))**(k1k-1)-g_delz(i,j,k)*kapag*delp(i,j,k)*pt(i,j,k)*(1+r_vir*q(i,j,k,1))/(delz(i,j,&
&k)*(1.+r_vir*q(i,j,k,1))*delz(i,j,k)*(1.+r_vir*q(i,j,k,1)))*k1k*(kapag*delp(i,j,k)*pt(i,j,k)/(delz(i,j,k)*(1.+r_vir*q(i,&
&j,k,1))))**(k1k-1)+g_pt(i,j,k)*kapag*delp(i,j,k)/(delz(i,j,k)*(1.+r_vir*q(i,j,k,1)))*k1k*(kapag*delp(i,j,k)*pt(i,j,k)/&
&(delz(i,j,k)*(1.+r_vir*q(i,j,k,1))))**(k1k-1)-g_q(i,j,k,1)*kapag*delp(i,j,k)*pt(i,j,k)*delz(i,j,k)*r_vir/(delz(i,j,k)*&
&(1.+r_vir*q(i,j,k,1))*delz(i,j,k)*(1.+r_vir*q(i,j,k,1)))*k1k*(kapag*delp(i,j,k)*pt(i,j,k)/(delz(i,j,k)*(1.+r_vir*q(i,j,&
&k,1))))**(k1k-1)
          pkz(i,j,k) = (kapag*delp(i,j,k)*pt(i,j,k)/(delz(i,j,k)*(1.+r_vir*q(i,j,k,1))))**k1k
        end do
      end do
    endif
    do k = 1, km
      do i = is, ie
        g_dp2(i,k) = 0.5*g_peln(i,k+1,j)+0.5*g_peln(i,k,j)
        dp2(i,k) = 0.5*(peln(i,k,j)+peln(i,k+1,j))
      end do
    end do
    do i = is, ie
      k_next = 1
      do n = 1, km
        kp = k_next
        k = kp
        k_loop =  .false. 
        if (dp2(i,n) .le. pe0(i,k+1) .and. dp2(i,n) .ge. pe0(i,k)) then
          g_omga(i,j,n) = g_dp2(i,n)*((pe3(i,k+1)-pe3(i,k))/(pe0(i,k+1)-pe0(i,k)))-g_pe0(i,k+1)*((pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-&
&pe0(i,k))/((pe0(i,k+1)-pe0(i,k))*(pe0(i,k+1)-pe0(i,k))))+g_pe0(i,k)*((-((pe3(i,k+1)-pe3(i,k))/(pe0(i,k+1)-pe0(i,k))))+&
&(pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-pe0(i,k))/((pe0(i,k+1)-pe0(i,k))*(pe0(i,k+1)-pe0(i,k))))+g_pe3(i,k+1)*((dp2(i,n)-pe0(i,&
&k))/(pe0(i,k+1)-pe0(i,k)))+g_pe3(i,k)*(1-(dp2(i,n)-pe0(i,k))/(pe0(i,k+1)-pe0(i,k)))
          omga(i,j,n) = pe3(i,k)+(pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-pe0(i,k))/(pe0(i,k+1)-pe0(i,k))
          k_loop =  .true. 
        endif
        do while ( k_loop .eq.  .false.  .or. k .lt. km )
          k = k+1
          if (dp2(i,n) .le. pe0(i,k+1) .and. dp2(i,n) .ge. pe0(i,k)) then
            g_omga(i,j,n) = g_dp2(i,n)*((pe3(i,k+1)-pe3(i,k))/(pe0(i,k+1)-pe0(i,k)))-g_pe0(i,k+1)*((pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-&
&pe0(i,k))/((pe0(i,k+1)-pe0(i,k))*(pe0(i,k+1)-pe0(i,k))))+g_pe0(i,k)*((-((pe3(i,k+1)-pe3(i,k))/(pe0(i,k+1)-pe0(i,k))))+&
&(pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-pe0(i,k))/((pe0(i,k+1)-pe0(i,k))*(pe0(i,k+1)-pe0(i,k))))+g_pe3(i,k+1)*((dp2(i,n)-&
&pe0(i,k))/(pe0(i,k+1)-pe0(i,k)))+g_pe3(i,k)*(1-(dp2(i,n)-pe0(i,k))/(pe0(i,k+1)-pe0(i,k)))
            omga(i,j,n) = pe3(i,k)+(pe3(i,k+1)-pe3(i,k))*(dp2(i,n)-pe0(i,k))/(pe0(i,k+1)-pe0(i,k))
            k_next = k
            k_loop =  .true. 
          endif
        end do
      end do
    end do
  endif
  if ( .not. hybrid_z) then
    do i = is, ie+1
      g_pe0(i,1) = g_pe(i,1,j)
      pe0(i,1) = pe(i,1,j)
    end do
    do k = 2, km+1
      do i = is, ie
        g_pe0(i,k) = 0.5*g_pe(i,k,j-1)+0.5*g_pe1(i,k)
        pe0(i,k) = 0.5*(pe(i,k,j-1)+pe1(i,k))
      end do
    end do
    do k = 1, ks+1
      do i = is, ie+1
        g_pe3(i,k) = 0.
        pe3(i,k) = ak(k)
      end do
    end do
    do k = ks+2, km+1
      bkh = 0.5*bk(k)
      do i = is, ie
        g_pe3(i,k) = (g_pe(i,km+1,j-1)+g_pe1(i,km+1))*bkh
        pe3(i,k) = ak(k)+bkh*(pe(i,km+1,j-1)+pe1(i,km+1))
      end do
    end do
    help_n = jed+1
    help_o = -1
    call g_map1_ppm( km,pe0(is:ie,:),g_pe0(is:ie,:),u,g_u,km,pe3(is:ie,:),g_pe3(is:ie,:),u,g_u,is,ie,j,isd,ied,jsd,help_n,help_o,&
&kord_mt )
    if (j .lt. je+1) then
      do k = 2, km+1
        do i = is, ie+1
          g_pe0(i,k) = 0.5*g_pe(i-1,k,j)+0.5*g_pe(i,k,j)
          pe0(i,k) = 0.5*(pe(i-1,k,j)+pe(i,k,j))
        end do
      end do
      do k = ks+2, km+1
        bkh = 0.5*bk(k)
        do i = is, ie+1
          g_pe3(i,k) = (g_pe(i-1,km+1,j)+g_pe(i,km+1,j))*bkh
          pe3(i,k) = ak(k)+bkh*(pe(i-1,km+1,j)+pe(i,km+1,j))
        end do
      end do
      help_p = ie+1
      help_q = ied+1
      help_r = -1
      call g_map1_ppm( km,pe0,g_pe0,v,g_v,km,pe3,g_pe3,v,g_v,is,help_p,j,isd,help_q,jsd,jed,help_r,kord_mt )
    endif
  endif
  do k = 1, km
    do i = is, ie
      g_ua(i,j,k) = g_pe2(i,k+1)
      ua(i,j,k) = pe2(i,k+1)
    end do
  end do
end do
if (hybrid_z) then
  do j = js, je+1
    do i = is, ie
      g_pe1(i,1) = 0.
      pe1(i,1) = ptop
      g_pe2(i,1) = 0.
      pe2(i,1) = ptop
    end do
    do k = 2, km+1
      do i = is, ie
        g_pe1(i,k) = 0.5*g_pe(i,k,j-1)+0.5*g_pe(i,k,j)
        pe1(i,k) = 0.5*(pe(i,k,j-1)+pe(i,k,j))
        g_pe2(i,k) = 0.5*g_ua(i,j-1,k-1)+0.5*g_ua(i,j,k-1)
        pe2(i,k) = 0.5*(ua(i,j-1,k-1)+ua(i,j,k-1))
      end do
    end do
    help_s = jed+1
    help_t = -1
    call g_map1_ppm( km,pe1,g_pe1,u,g_u,km,pe2,g_pe2,u,g_u,is,ie,j,isd,ied,jsd,help_s,help_t,kord_mt )
  end do
  do j = js, je
    do i = is, ie+1
      g_pe0(i,1) = 0.
      pe0(i,1) = ptop
      g_pe3(i,1) = 0.
      pe3(i,1) = ptop
    end do
    do k = 2, km+1
      do i = is, ie+1
        g_pe0(i,k) = 0.5*g_pe(i-1,k,j)+0.5*g_pe(i,k,j)
        pe0(i,k) = 0.5*(pe(i-1,k,j)+pe(i,k,j))
        g_pe3(i,k) = 0.5*g_ua(i-1,j,k-1)+0.5*g_ua(i,j,k-1)
        pe3(i,k) = 0.5*(ua(i-1,j,k-1)+ua(i,j,k-1))
      end do
    end do
    help_u = ie+1
    help_v = ied+1
    help_w = -1
    call g_map1_ppm( km,pe0,g_pe0,v,g_v,km,pe3,g_pe3,v,g_v,is,help_u,j,isd,help_v,jsd,jed,help_w,kord_mt )
  end do
endif
do k = 2, km
  do j = js, je
    do i = is, ie
      g_pe(i,k,j) = g_ua(i,j,k-1)
      pe(i,k,j) = ua(i,j,k-1)
    end do
  end do
end do
call g_cubed_to_latlon( u,g_u,v,g_v,ua,g_ua,va,g_va,dx,dy,dxa,dya,km )
if (consv .gt. 0.) then
  if (te_map) then
  else
    do j = js, je
      if (remap_t) then
        do i = is, ie
          g_gz(i) = 0.
          gz(i) = hs(i,j)
          do k = 1, km
            g_gz(i) = g_gz(i)+g_peln(i,k+1,j)*rg*pt(i,j,k)-g_peln(i,k,j)*rg*pt(i,j,k)+g_pt(i,j,k)*rg*(peln(i,k+1,j)-peln(i,k,j))
            gz(i) = gz(i)+rg*pt(i,j,k)*(peln(i,k+1,j)-peln(i,k,j))
          end do
        end do
      else
        do i = is, ie
          g_gz(i) = 0.
          gz(i) = hs(i,j)
          do k = 1, km
            g_gz(i) = g_gz(i)+g_pk(i,j,k+1)*pt(i,j,k)-g_pk(i,j,k)*pt(i,j,k)+g_pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
            gz(i) = gz(i)+pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
          end do
        end do
      endif
    end do
  endif
  help_x = g_sum(te_2d,is,ie,js,je,ng,area)
  g_tpe = g_help_x*consv
  tpe = consv*help_x
  help_y = g_sum(zsum,is,ie,js,je,ng,area)
  g_dtmp = (-(g_help_y*(tpe*cp/(cp*help_y*cp*help_y))))+g_tpe/(cp*help_y)
  dtmp = tpe/(cp*help_y)
  if (reproduce_sum) then
    g_dtmp = real(g_dtmp,4)
    dtmp = real(dtmp,4)
  endif
else
  g_dtmp = 0.
  dtmp = 0.
endif
if (te_map) then
  do j = js, je
    do i = is, ie
      g_gz(i) = 0.
      gz(i) = hs(i,j)
    end do
    do k = km, 1, -1
      do i = is, ie
        g_tpe = (-g_gz(i))+g_te(i,j,k)-g_ua(i,j,k)*ua(i,j,k)-g_va(i,j,k)*va(i,j,k)
        tpe = te(i,j,k)-0.5*(ua(i,j,k)**2+va(i,j,k)**2)-gz(i)
        g_dlnp = g_peln(i,k+1,j)*rg-g_peln(i,k,j)*rg
        dlnp = rg*(peln(i,k+1,j)-peln(i,k,j))
        g_tmp = (-(g_delp(i,j,k)*(tpe*pe(i,k,j)*dlnp/(delp(i,j,k)*delp(i,j,k))*(1.+r_vir*q(i,j,k,1))/((cp-pe(i,k,j)*dlnp/delp(i,j,&
&k))*(1.+r_vir*q(i,j,k,1))*(cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))))))+g_dlnp*(tpe*pe(i,k,j)/delp(i,j,k)*(1.+&
&r_vir*q(i,j,k,1))/((cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))*(cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,&
&k,1))))+g_pe(i,k,j)*(tpe*dlnp/delp(i,j,k)*(1.+r_vir*q(i,j,k,1))/((cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))*&
&(cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))))-g_q(i,j,k,1)*(tpe*(cp-pe(i,k,j)*dlnp/delp(i,j,k))*r_vir/((cp-pe(i,&
&k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))*(cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1))))+g_tpe/((cp-pe(i,k,j)*&
&dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1)))
        tmp = tpe/((cp-pe(i,k,j)*dlnp/delp(i,j,k))*(1.+r_vir*q(i,j,k,1)))
        g_pt(i,j,k) = g_dtmp*(pkz(i,j,k)/(1.+r_vir*q(i,j,k,1)))+g_pkz(i,j,k)*(dtmp/(1.+r_vir*q(i,j,k,1)))-g_q(i,j,k,1)*(dtmp*pkz(i,&
&j,k)*r_vir/((1.+r_vir*q(i,j,k,1))*(1.+r_vir*q(i,j,k,1))))+g_tmp
        pt(i,j,k) = tmp+dtmp*pkz(i,j,k)/(1.+r_vir*q(i,j,k,1))
        g_gz(i) = g_dlnp*tmp*(1.+r_vir*q(i,j,k,1))+g_gz(i)+g_q(i,j,k,1)*dlnp*tmp*r_vir+g_tmp*dlnp*(1.+r_vir*q(i,j,k,1))
        gz(i) = gz(i)+dlnp*tmp*(1.+r_vir*q(i,j,k,1))
      end do
    end do
  end do
else
  if (remap_t) then
    do k = 1, km
      do j = js, je
        do i = is, ie
          g_pt(i,j,k) = g_dtmp*(pkz(i,j,k)/(1.+r_vir*q(i,j,k,1)))+g_pkz(i,j,k)*(dtmp/(1.+r_vir*q(i,j,k,1)))+g_pt(i,j,k)/(1.+r_vir*&
&q(i,j,k,1))-g_q(i,j,k,1)*((pt(i,j,k)+dtmp*pkz(i,j,k))*r_vir/((1.+r_vir*q(i,j,k,1))*(1.+r_vir*q(i,j,k,1))))
          pt(i,j,k) = (pt(i,j,k)+dtmp*pkz(i,j,k))/(1.+r_vir*q(i,j,k,1))
        end do
      end do
    end do
  else
    do k = 1, km
      do j = js, je
        do i = is, ie
          g_pt(i,j,k) = g_dtmp*(pkz(i,j,k)/(1.+r_vir*q(i,j,k,1)))+g_pkz(i,j,k)*((rcp*pt(i,j,k)+dtmp)/(1.+r_vir*q(i,j,k,1)))+g_pt(i,&
&j,k)*(rcp*pkz(i,j,k)/(1.+r_vir*q(i,j,k,1)))-g_q(i,j,k,1)*((rcp*pt(i,j,k)+dtmp)*pkz(i,j,k)*r_vir/((1.+r_vir*q(i,j,k,1))*&
&(1.+r_vir*q(i,j,k,1))))
          pt(i,j,k) = (rcp*pt(i,j,k)+dtmp)*pkz(i,j,k)/(1.+r_vir*q(i,j,k,1))
        end do
      end do
    end do
  endif
endif

end subroutine g_lagrangian_to_eulerian


subroutine g_map1_ppm( km, pe1, g_pe1, q1, g_q1, kn, pe2, g_pe2, q2, g_q2, i1, i2, j, ibeg, iend, jbeg, jend, iv, kord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r23 = 2./3.
real, parameter :: r3 = 1./3.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: km
real, intent(in) :: g_pe1(i1:i2,km+1)
integer, intent(in) :: kn
real, intent(in) :: g_pe2(i1:i2,kn+1)
integer, intent(in) :: ibeg
integer, intent(in) :: iend
integer, intent(in) :: jbeg
integer, intent(in) :: jend
real, intent(in) :: g_q1(ibeg:iend,jbeg:jend,km)
real, intent(inout) :: g_q2(ibeg:iend,jbeg:jend,kn)
integer, intent(in) :: iv
integer, intent(in) :: j
integer, intent(in) :: kord
real, intent(in) :: pe1(i1:i2,km+1)
real, intent(in) :: pe2(i1:i2,kn+1)
real, intent(in) :: q1(ibeg:iend,jbeg:jend,km)
real, intent(inout) :: q2(ibeg:iend,jbeg:jend,kn)

!==============================================
! declare local variables
!==============================================
real :: dp
real :: dp1(i1:i2,km)
real :: esl
real :: g_dp
real :: g_dp1(i1:i2,km)
real :: g_esl
real :: g_pl
real :: g_pr
real :: g_q4(4,i1:i2,km)
real :: g_qsum
integer :: i
integer :: k
integer :: k0
integer :: l
logical :: l_123
logical :: l_555
logical :: l_loop
integer :: m
logical :: m_123
real :: pl
real :: pr
real :: q4(4,i1:i2,km)
real :: qsum

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, km
  do i = i1, i2
    g_dp1(i,k) = g_pe1(i,k+1)-g_pe1(i,k)
    dp1(i,k) = pe1(i,k+1)-pe1(i,k)
    g_q4(1,i,k) = g_q1(i,j,k)
    q4(1,i,k) = q1(i,j,k)
  end do
end do
if (kord .gt. 7) then
  call g_cs_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,iv,kord )
else
  call g_ppm_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,iv,kord )
endif
do i = i1, i2
  k0 = 1
  do k = 1, kn
    l_123 =  .false. 
    l_555 =  .false. 
    l_loop =  .false. 
    l = k0
    if (l_loop .eq.  .false. ) then
      if (pe2(i,k) .ge. pe1(i,l) .and. pe2(i,k) .le. pe1(i,l+1)) then
        g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
        pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
        if (pe2(i,k+1) .le. pe1(i,l+1)) then
          g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
          pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
          g_q2(i,j,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))&
&-q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
          q2(i,j,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
          l_555 =  .true. 
        else
          if (l_123 .eq.  .false. ) then
            m_123 =  .false. 
            m = l+1
            if (m_123 .eq.  .false. ) then
              if (pe2(i,k+1) .gt. pe1(i,m+1)) then
              else
m_123 =  .true. 
              endif
            endif
            do while ( m_123 .eq.  .false.  .or. m .lt. km )
              m = m+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .gt. pe1(i,m+1)) then
else
  m_123 =  .true. 
endif
              endif
            end do
            l_123 =  .true. 
          endif
        endif
      endif
      if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
        l_loop =  .true. 
      endif
    endif
    if (l_loop .eq.  .false.  .and. l .lt. km) then
      l = l+1
    endif
    do while ( l_loop .eq.  .false.  .and. l .le. km )
      if (l_loop .eq.  .false. ) then
        if (pe2(i,k) .ge. pe1(i,l) .and. pe2(i,k) .le. pe1(i,l+1)) then
          g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
          pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
          if (pe2(i,k+1) .le. pe1(i,l+1)) then
            g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
            pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
            g_q2(i,j,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,&
&l))-q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
            q2(i,j,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
            k0 = l
            l_555 =  .true. 
          else
            if (l_123 .eq.  .false. ) then
              g_qsum = g_pe1(i,l+1)*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))-g_pe2(i,k)&
&*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))+g_pl*(pe1(i,l+1)-pe2(i,k))*&
&(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(1+2*pl))+g_q4(4,i,l)*(pe1(i,l+1)-pe2(i,k))*(0.5*(1.+pl)-r3*(1.+&
&pl*(1.+pl)))+0.5*g_q4(3,i,l)*(pe1(i,l+1)-pe2(i,k))*(1.+pl)+g_q4(2,i,l)*(pe1(i,l+1)-pe2(i,k))*(1+(-0.5)*(1.+pl))
              qsum = (pe1(i,l+1)-pe2(i,k))*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))
              m_123 =  .false. 
              m = l+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .gt. pe1(i,m+1)) then
  g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
  qsum = qsum+dp1(i,m)*q4(1,i,m)
else
  g_dp = (-g_pe1(i,m))+g_pe2(i,k+1)
  dp = pe2(i,k+1)-pe1(i,m)
  g_esl = g_dp/dp1(i,m)-g_dp1(i,m)*(dp/(dp1(i,m)*dp1(i,m)))
  esl = dp/dp1(i,m)
  g_qsum = g_dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*dp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*(q4(3,i,&
&m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*dp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*dp*esl+g_q4(2,i,m)*dp*(1+(-0.5)*esl)+&
&g_qsum
  qsum = qsum+dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
  m_123 =  .true. 
endif
              endif
              do while ( m_123 .eq.  .false.  .or. m .lt. km )
m = m+1
if (m_123 .eq.  .false. ) then
  if (pe2(i,k+1) .gt. pe1(i,m+1)) then
    g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
    qsum = qsum+dp1(i,m)*q4(1,i,m)
  else
    g_dp = (-g_pe1(i,m))+g_pe2(i,k+1)
    dp = pe2(i,k+1)-pe1(i,m)
    g_esl = g_dp/dp1(i,m)-g_dp1(i,m)*(dp/(dp1(i,m)*dp1(i,m)))
    esl = dp/dp1(i,m)
    g_qsum = g_dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*dp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*(q4(3,&
&i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*dp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*dp*esl+g_q4(2,i,m)*dp*(1+(-0.5)*&
&esl)+g_qsum
    qsum = qsum+dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
    k0 = m
    m_123 =  .true. 
  endif
endif
              end do
              l_123 =  .true. 
            endif
          endif
        endif
        if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
          l_loop =  .true. 
        endif
      endif
      if (l_loop .eq.  .false.  .and. l .lt. km) then
        l = l+1
      endif
    end do
    if (l_555 .eq.  .false. ) then
      g_q2(i,j,k) = (-(g_pe2(i,k+1)*(qsum/((pe2(i,k+1)-pe2(i,k))*(pe2(i,k+1)-pe2(i,k))))))+g_pe2(i,k)*(qsum/((pe2(i,k+1)-pe2(i,k))*&
&(pe2(i,k+1)-pe2(i,k))))+g_qsum/(pe2(i,k+1)-pe2(i,k))
      q2(i,j,k) = qsum/(pe2(i,k+1)-pe2(i,k))
    endif
  end do
end do

end subroutine g_map1_ppm


subroutine g_map1_q2( km, pe1, g_pe1, q1, g_q1, kn, pe2, g_pe2, q2, g_q2, dp2, g_dp2, i1, i2, iv, kord, j, ibeg, iend, jbeg, jend )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r23 = 2./3.
real, parameter :: r3 = 1./3.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: kn
real, intent(in) :: dp2(i1:i2,kn)
real, intent(in) :: g_dp2(i1:i2,kn)
integer, intent(in) :: km
real, intent(in) :: g_pe1(i1:i2,km+1)
real, intent(in) :: g_pe2(i1:i2,kn+1)
integer, intent(in) :: ibeg
integer, intent(in) :: iend
integer, intent(in) :: jbeg
integer, intent(in) :: jend
real, intent(in) :: g_q1(ibeg:iend,jbeg:jend,km)
real, intent(inout) :: g_q2(i1:i2,kn)
integer, intent(in) :: iv
integer, intent(in) :: j
integer, intent(in) :: kord
real, intent(in) :: pe1(i1:i2,km+1)
real, intent(in) :: pe2(i1:i2,kn+1)
real, intent(in) :: q1(ibeg:iend,jbeg:jend,km)
real, intent(inout) :: q2(i1:i2,kn)

!==============================================
! declare local variables
!==============================================
real :: dp
real :: dp1(i1:i2,km)
real :: esl
real :: g_dp
real :: g_dp1(i1:i2,km)
real :: g_esl
real :: g_pl
real :: g_pr
real :: g_q4(4,i1:i2,km)
real :: g_qsum
integer :: i
integer :: k
integer :: k0
integer :: l
logical :: l_123
logical :: l_555
logical :: l_loop
integer :: m
logical :: m_123
real :: pl
real :: pr
real :: q4(4,i1:i2,km)
real :: qsum

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, km
  do i = i1, i2
    g_dp1(i,k) = g_pe1(i,k+1)-g_pe1(i,k)
    dp1(i,k) = pe1(i,k+1)-pe1(i,k)
    g_q4(1,i,k) = g_q1(i,j,k)
    q4(1,i,k) = q1(i,j,k)
  end do
end do
if (kord .gt. 7) then
  call g_cs_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,iv,kord )
else
  call g_ppm_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,iv,kord )
endif
do i = i1, i2
  k0 = 1
  do k = 1, kn
    l_123 =  .false. 
    l_555 =  .false. 
    l_loop =  .false. 
    l = k0
    if (l_loop .eq.  .false. ) then
      if (pe2(i,k) .ge. pe1(i,l) .and. pe2(i,k) .le. pe1(i,l+1)) then
        g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
        pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
        if (pe2(i,k+1) .le. pe1(i,l+1)) then
          g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
          pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
          g_q2(i,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-&
&q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
          q2(i,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
          l_555 =  .true. 
        else
          if (l_123 .eq.  .false. ) then
            m_123 =  .false. 
            m = l+1
            if (m_123 .eq.  .false. ) then
              if (pe2(i,k+1) .gt. pe1(i,m+1)) then
              else
m_123 =  .true. 
              endif
            endif
            do while ( m_123 .eq.  .false.  .or. m .lt. km )
              m = m+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .gt. pe1(i,m+1)) then
else
  m_123 =  .true. 
endif
              endif
            end do
            l_123 =  .true. 
          endif
        endif
      endif
      if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
        l_loop =  .true. 
      endif
    endif
    if (l_loop .eq.  .false.  .and. l .lt. km) then
      l = l+1
    endif
    do while ( l_loop .eq.  .false.  .and. l .le. km )
      if (l_loop .eq.  .false. ) then
        if (pe2(i,k) .ge. pe1(i,l) .and. pe2(i,k) .le. pe1(i,l+1)) then
          g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
          pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
          if (pe2(i,k+1) .le. pe1(i,l+1)) then
            g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
            pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
            g_q2(i,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))&
&-q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
            q2(i,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
            k0 = l
            l_555 =  .true. 
          else
            if (l_123 .eq.  .false. ) then
              g_qsum = g_pe1(i,l+1)*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))-g_pe2(i,k)&
&*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))+g_pl*(pe1(i,l+1)-pe2(i,k))*&
&(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(1+2*pl))+g_q4(4,i,l)*(pe1(i,l+1)-pe2(i,k))*(0.5*(1.+pl)-r3*(1.+&
&pl*(1.+pl)))+0.5*g_q4(3,i,l)*(pe1(i,l+1)-pe2(i,k))*(1.+pl)+g_q4(2,i,l)*(pe1(i,l+1)-pe2(i,k))*(1+(-0.5)*(1.+pl))
              qsum = (pe1(i,l+1)-pe2(i,k))*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))
              m_123 =  .false. 
              m = l+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .gt. pe1(i,m+1)) then
  g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
  qsum = qsum+dp1(i,m)*q4(1,i,m)
else
  g_dp = (-g_pe1(i,m))+g_pe2(i,k+1)
  dp = pe2(i,k+1)-pe1(i,m)
  g_esl = g_dp/dp1(i,m)-g_dp1(i,m)*(dp/(dp1(i,m)*dp1(i,m)))
  esl = dp/dp1(i,m)
  g_qsum = g_dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*dp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*(q4(3,i,&
&m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*dp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*dp*esl+g_q4(2,i,m)*dp*(1+(-0.5)*esl)+&
&g_qsum
  qsum = qsum+dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
  m_123 =  .true. 
endif
              endif
              do while ( m_123 .eq.  .false.  .or. m .lt. km )
m = m+1
if (m_123 .eq.  .false. ) then
  if (pe2(i,k+1) .gt. pe1(i,m+1)) then
    g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
    qsum = qsum+dp1(i,m)*q4(1,i,m)
  else
    g_dp = (-g_pe1(i,m))+g_pe2(i,k+1)
    dp = pe2(i,k+1)-pe1(i,m)
    g_esl = g_dp/dp1(i,m)-g_dp1(i,m)*(dp/(dp1(i,m)*dp1(i,m)))
    esl = dp/dp1(i,m)
    g_qsum = g_dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*dp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*(q4(3,&
&i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*dp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*dp*esl+g_q4(2,i,m)*dp*(1+(-0.5)*&
&esl)+g_qsum
    qsum = qsum+dp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
    k0 = m
    m_123 =  .true. 
  endif
endif
              end do
              l_123 =  .true. 
            endif
          endif
        endif
        if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
          l_loop =  .true. 
        endif
      endif
      if (l_loop .eq.  .false.  .and. l .lt. km) then
        l = l+1
      endif
    end do
    if (l_555 .eq.  .false. ) then
      g_q2(i,k) = (-(g_dp2(i,k)*(qsum/(dp2(i,k)*dp2(i,k)))))+g_qsum/dp2(i,k)
      q2(i,k) = qsum/dp2(i,k)
    endif
  end do
end do

end subroutine g_map1_q2


subroutine g_pkez( km, ifirst, ilast, jfirst, jlast, pe, g_pe, pk, g_pk, akap, peln, g_peln, pkz, g_pkz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: akap
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real, intent(in) :: g_pe(ifirst-1:ilast+1,km+1,jfirst-1:jlast+1)
real, intent(out) :: g_peln(ifirst:ilast,km+1,jfirst:jlast)
real, intent(in) :: g_pk(ifirst:ilast,jfirst:jlast,km+1)
real, intent(out) :: g_pkz(ifirst:ilast,jfirst:jlast,km)
real, intent(in) :: pe(ifirst-1:ilast+1,km+1,jfirst-1:jlast+1)
real, intent(out) :: peln(ifirst:ilast,km+1,jfirst:jlast)
real, intent(in) :: pk(ifirst:ilast,jfirst:jlast,km+1)
real, intent(out) :: pkz(ifirst:ilast,jfirst:jlast,km)

!==============================================
! declare local variables
!==============================================
real :: ak1
real :: g_pek
real :: g_pk2(ifirst:ilast,km+1)
integer :: i
integer :: j
integer :: k
real :: lnp
real :: pek
real :: pk2(ifirst:ilast,km+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
ak1 = (akap+1.)/akap
do j = jfirst, jlast
  g_pek = g_pk(ifirst,j,1)
  pek = pk(ifirst,j,1)
  do i = ifirst, ilast
    g_pk2(i,1) = g_pek
    pk2(i,1) = pek
  end do
  do k = 2, km+1
    do i = ifirst, ilast
      g_peln(i,k,j) = g_pe(i,k,j)*(1./pe(i,k,j))
      peln(i,k,j) = log(pe(i,k,j))
      g_pk2(i,k) = g_pk(i,j,k)
      pk2(i,k) = pk(i,j,k)
    end do
  end do
  if (ptop .lt. ptop_min) then
    do i = ifirst, ilast
      g_peln(i,1,j) = g_peln(i,2,j)
      peln(i,1,j) = peln(i,2,j)-ak1
    end do
  else
    lnp = log(ptop)
    do i = ifirst, ilast
      g_peln(i,1,j) = 0.
      peln(i,1,j) = lnp
    end do
  endif
  do k = 1, km
    do i = ifirst, ilast
      g_pkz(i,j,k) = (-(g_peln(i,k+1,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-peln(i,k,&
&j))))))+g_peln(i,k,j)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+1,j)-peln(i,k,j))))+&
&g_pk2(i,k+1)/(akap*(peln(i,k+1,j)-peln(i,k,j)))-g_pk2(i,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
      pkz(i,j,k) = (pk2(i,k+1)-pk2(i,k))/(akap*(peln(i,k+1,j)-peln(i,k,j)))
    end do
  end do
end do

end subroutine g_pkez


subroutine g_ppm_limiters( dm, g_dm, a4, g_a4, itot, lmt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r12 = 1./12.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: itot
real, intent(inout) :: a4(4,itot)
real, intent(in) :: dm(itot)
real, intent(inout) :: g_a4(4,itot)
real, intent(in) :: g_dm(itot)
integer, intent(in) :: lmt

!==============================================
! declare local variables
!==============================================
real :: a4h
real :: a4i
real :: a4j
real :: a4k
real :: a6da
real :: da1
real :: da2
real :: fmin
real :: g_a4i
real :: g_a4k
real :: g_a6da
real :: g_da1
real :: g_da2
real :: g_fmin
real :: g_qmp
integer :: i
real :: qmp

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (lmt .ne. 3) then
  if (lmt .eq. 0) then
    do i = 1, itot
      if (dm(i) .eq. 0.) then
        g_a4(2,i) = g_a4(1,i)
        a4(2,i) = a4(1,i)
        g_a4(3,i) = g_a4(1,i)
        a4(3,i) = a4(1,i)
        g_a4(4,i) = 0.
        a4(4,i) = 0.
      else
        g_da1 = g_a4(3,i)-g_a4(2,i)
        da1 = a4(3,i)-a4(2,i)
        g_da2 = 2*g_da1*da1
        da2 = da1**2
        g_a6da = g_a4(4,i)*da1+g_da1*a4(4,i)
        a6da = a4(4,i)*da1
        if (a6da .lt. (-da2)) then
          g_a4(4,i) = 3*g_a4(2,i)-3*g_a4(1,i)
          a4(4,i) = 3.*(a4(2,i)-a4(1,i))
          g_a4(3,i) = (-g_a4(4,i))+g_a4(2,i)
          a4(3,i) = a4(2,i)-a4(4,i)
        else if (a6da .gt. da2) then
          g_a4(4,i) = 3*g_a4(3,i)-3*g_a4(1,i)
          a4(4,i) = 3.*(a4(3,i)-a4(1,i))
          g_a4(2,i) = (-g_a4(4,i))+g_a4(3,i)
          a4(2,i) = a4(3,i)-a4(4,i)
        endif
      endif
    end do
  else if (lmt .eq. 1) then
    do i = 1, itot
      g_qmp = 2*g_dm(i)
      qmp = 2.*dm(i)
      g_a4k = g_a4(2,i)-g_a4(1,i)
      a4k = a4(2,i)-a4(1,i)
      a4j = min(abs(qmp),abs(a4k))
      g_a4(2,i) = g_a4(1,i)-(g_a4k*(0.5-sign(0.5,abs(a4k)-abs(qmp)))*sign(1.,a4k)+g_qmp*(0.5+sign(0.5,abs(a4k)-abs(qmp)))*sign(1.,&
&qmp))*sign(1.,a4j)*sign(1.,qmp)
      a4(2,i) = a4(1,i)-sign(a4j,qmp)
      g_a4i = g_a4(3,i)-g_a4(1,i)
      a4i = a4(3,i)-a4(1,i)
      a4h = min(abs(qmp),abs(a4i))
      g_a4(3,i) = g_a4(1,i)+(g_a4i*(0.5-sign(0.5,abs(a4i)-abs(qmp)))*sign(1.,a4i)+g_qmp*(0.5+sign(0.5,abs(a4i)-abs(qmp)))*sign(1.,&
&qmp))*sign(1.,a4h)*sign(1.,qmp)
      a4(3,i) = a4(1,i)+sign(a4h,qmp)
      g_a4(4,i) = (-3)*g_a4(3,i)-3*g_a4(2,i)+6*g_a4(1,i)
      a4(4,i) = 3.*(2.*a4(1,i)-(a4(2,i)+a4(3,i)))
    end do
  else if (lmt .eq. 2) then
    do i = 1, itot
      if (abs(a4(3,i)-a4(2,i)) .lt. (-a4(4,i))) then
        g_fmin = g_a4(4,i)*((-(0.25*(a4(3,i)-a4(2,i))**2/(a4(4,i)*a4(4,i))))+r12)+g_a4(3,i)*(0.5*(a4(3,i)-a4(2,i))/a4(4,i))+g_a4(2,&
&i)*((-0.5)*(a4(3,i)-a4(2,i))/a4(4,i))+g_a4(1,i)
        fmin = a4(1,i)+0.25*(a4(3,i)-a4(2,i))**2/a4(4,i)+a4(4,i)*r12
        if (fmin .lt. 0.) then
          if (a4(1,i) .lt. a4(3,i) .and. a4(1,i) .lt. a4(2,i)) then
            g_a4(3,i) = g_a4(1,i)
            a4(3,i) = a4(1,i)
            g_a4(2,i) = g_a4(1,i)
            a4(2,i) = a4(1,i)
            g_a4(4,i) = 0.
            a4(4,i) = 0.
          else if (a4(3,i) .gt. a4(2,i)) then
            g_a4(4,i) = 3*g_a4(2,i)-3*g_a4(1,i)
            a4(4,i) = 3.*(a4(2,i)-a4(1,i))
            g_a4(3,i) = (-g_a4(4,i))+g_a4(2,i)
            a4(3,i) = a4(2,i)-a4(4,i)
          else
            g_a4(4,i) = 3*g_a4(3,i)-3*g_a4(1,i)
            a4(4,i) = 3.*(a4(3,i)-a4(1,i))
            g_a4(2,i) = (-g_a4(4,i))+g_a4(3,i)
            a4(2,i) = a4(3,i)-a4(4,i)
          endif
        endif
      endif
    end do
  endif
endif

end subroutine g_ppm_limiters


subroutine g_ppm_profile( a4, g_a4, delp, g_delp, km, i1, i2, iv, kord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: km
real, intent(inout) :: a4(4,i1:i2,km)
real, intent(in) :: delp(i1:i2,km)
real, intent(inout) :: g_a4(4,i1:i2,km)
real, intent(in) :: g_delp(i1:i2,km)
integer, intent(in) :: iv
integer, intent(in) :: kord

!==============================================
! declare local variables
!==============================================
real :: a1
real :: a2
real :: a4h
real :: a4i
real :: a4j
real :: a4k
real :: a4l
real :: a4m
real :: a4n
real :: a4o
real :: a4p
real :: a4q
real :: a4r
real :: a4s
real :: a4t
real :: a4u
real :: c1
real :: c2
real :: c3
real :: d1
real :: d2
real :: d4(i1:i2,km)
real :: dc(i1:i2,km)
real :: dch
real :: dci
real :: dck
real :: dcl
real :: dcn
real :: dco
real :: dcp
real :: delq(i1:i2,km)
real :: df2(i1:i2,km)
real :: dq
real :: dqh
real :: dqi
real :: dqj
real :: dqk
real :: dql
real :: fac
real :: g_a1
real :: g_a2
real :: g_a4h
real :: g_a4i
real :: g_a4j
real :: g_a4k
real :: g_a4l
real :: g_a4m
real :: g_a4n
real :: g_a4o
real :: g_a4p
real :: g_a4q
real :: g_a4r
real :: g_a4s
real :: g_a4t
real :: g_a4u
real :: g_c1
real :: g_c2
real :: g_c3
real :: g_d1
real :: g_d2
real :: g_d4(i1:i2,km)
real :: g_dc(i1:i2,km)
real :: g_dch
real :: g_dci
real :: g_dck
real :: g_dcl
real :: g_dcn
real :: g_dco
real :: g_dcp
real :: g_delq(i1:i2,km)
real :: g_df2(i1:i2,km)
real :: g_dq
real :: g_dqh
real :: g_dqi
real :: g_dqj
real :: g_dqk
real :: g_dql
real :: g_h2(i1:i2,km)
real :: g_lac
real :: g_pmp
real :: g_qm
real :: g_qmp
real :: h2(i1:i2,km)
integer :: i
integer :: it
integer :: k
integer :: km1
real :: lac
integer :: lmt
real :: pmp
real :: qm
real :: qmp

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
km1 = km-1
it = i2-i1+1
do k = 2, km
  do i = i1, i2
    g_delq(i,k-1) = (-g_a4(1,i,k-1))+g_a4(1,i,k)
    delq(i,k-1) = a4(1,i,k)-a4(1,i,k-1)
    g_d4(i,k) = g_delp(i,k-1)+g_delp(i,k)
    d4(i,k) = delp(i,k-1)+delp(i,k)
  end do
end do
do k = 2, km1
  do i = i1, i2
    g_c1 = (-(g_d4(i,k+1)*((delp(i,k-1)+0.5*delp(i,k))/(d4(i,k+1)*d4(i,k+1)))))+g_delp(i,k-1)/d4(i,k+1)+g_delp(i,k)*(0.5/d4(i,k+1))
    c1 = (delp(i,k-1)+0.5*delp(i,k))/d4(i,k+1)
    g_c2 = (-(g_d4(i,k)*((delp(i,k+1)+0.5*delp(i,k))/(d4(i,k)*d4(i,k)))))+g_delp(i,k+1)/d4(i,k)+g_delp(i,k)*(0.5/d4(i,k))
    c2 = (delp(i,k+1)+0.5*delp(i,k))/d4(i,k)
    g_df2(i,k) = g_c1*(delp(i,k)*delq(i,k)/(d4(i,k)+delp(i,k+1)))+g_c2*(delp(i,k)*delq(i,k-1)/(d4(i,k)+delp(i,k+1)))-g_d4(i,k)*&
&(delp(i,k)*(c1*delq(i,k)+c2*delq(i,k-1))/((d4(i,k)+delp(i,k+1))*(d4(i,k)+delp(i,k+1))))-g_delp(i,k+1)*(delp(i,k)*(c1*delq(i,k)&
&+c2*delq(i,k-1))/((d4(i,k)+delp(i,k+1))*(d4(i,k)+delp(i,k+1))))+g_delp(i,k)*((c1*delq(i,k)+c2*delq(i,k-1))/(d4(i,k)+delp(i,k+&
&1)))+g_delq(i,k-1)*(delp(i,k)*c2/(d4(i,k)+delp(i,k+1)))+g_delq(i,k)*(delp(i,k)*c1/(d4(i,k)+delp(i,k+1)))
    df2(i,k) = delp(i,k)*(c1*delq(i,k)+c2*delq(i,k-1))/(d4(i,k)+delp(i,k+1))
    g_dch = g_df2(i,k)*sign(1.,df2(i,k))
    dch = abs(df2(i,k))
    g_dci = g_a4(1,i,k-1)*(0.5+sign(0.5,a4(1,i,k-1)-a4(1,i,k)))+g_a4(1,i,k)*(0.5-sign(0.5,a4(1,i,k-1)-a4(1,i,k)))
    dci = max(a4(1,i,k-1),a4(1,i,k))
    g_dck = (-g_a4(1,i,k))+g_a4(1,i,k+1)*(0.5-sign(0.5,dci-a4(1,i,k+1)))+g_dci*(0.5+sign(0.5,dci-a4(1,i,k+1)))
    dck = max(dci,a4(1,i,k+1))-a4(1,i,k)
    g_dcl = g_a4(1,i,k-1)*(0.5+sign(0.5,a4(1,i,k)-a4(1,i,k-1)))+g_a4(1,i,k)*(0.5-sign(0.5,a4(1,i,k)-a4(1,i,k-1)))
    dcl = min(a4(1,i,k-1),a4(1,i,k))
    g_dcn = g_a4(1,i,k)-(g_a4(1,i,k+1)*(0.5-sign(0.5,a4(1,i,k+1)-dcl))+g_dcl*(0.5+sign(0.5,a4(1,i,k+1)-dcl)))
    dcn = a4(1,i,k)-min(dcl,a4(1,i,k+1))
    g_dco = g_dch*(0.5+sign(0.5,dck-dch))+g_dck*(0.5-sign(0.5,dck-dch))
    dco = min(dch,dck)
    g_dcp = g_dcn*(0.5-sign(0.5,dcn-dco))+g_dco*(0.5+sign(0.5,dcn-dco))
    dcp = min(dco,dcn)
    g_dc(i,k) = g_dcp*sign(1.,dcp)*sign(1.,df2(i,k))
    dc(i,k) = sign(dcp,df2(i,k))
  end do
end do
do k = 3, km1
  do i = i1, i2
    g_c1 = (-(g_d4(i,k)*(delq(i,k-1)*delp(i,k-1)/(d4(i,k)*d4(i,k)))))+g_delp(i,k-1)*(delq(i,k-1)/d4(i,k))+g_delq(i,k-1)*(delp(i,k-&
&1)/d4(i,k))
    c1 = delq(i,k-1)*delp(i,k-1)/d4(i,k)
    g_a1 = g_d4(i,k-1)/(d4(i,k)+delp(i,k-1))-g_d4(i,k)*(d4(i,k-1)/((d4(i,k)+delp(i,k-1))*(d4(i,k)+delp(i,k-1))))-g_delp(i,k-1)*&
&(d4(i,k-1)/((d4(i,k)+delp(i,k-1))*(d4(i,k)+delp(i,k-1))))
    a1 = d4(i,k-1)/(d4(i,k)+delp(i,k-1))
    g_a2 = g_d4(i,k+1)/(d4(i,k)+delp(i,k))-g_d4(i,k)*(d4(i,k+1)/((d4(i,k)+delp(i,k))*(d4(i,k)+delp(i,k))))-g_delp(i,k)*(d4(i,k+1)/&
&((d4(i,k)+delp(i,k))*(d4(i,k)+delp(i,k))))
    a2 = d4(i,k+1)/(d4(i,k)+delp(i,k))
    g_a4(2,i,k) = g_a1*2./(d4(i,k-1)+d4(i,k+1))*(delp(i,k)*c1-delp(i,k-1)*dc(i,k))+g_a2*2./(d4(i,k-1)+d4(i,k+1))*delp(i,k)*((-c1)+&
&dc(i,k-1))+g_a4(1,i,k-1)+g_c1*(1+2./(d4(i,k-1)+d4(i,k+1))*delp(i,k)*(a1-a2))-g_d4(i,k-1)*2/((d4(i,k-1)+d4(i,k+1))*(d4(i,k-1)+&
&d4(i,k+1)))*(delp(i,k)*(c1*(a1-a2)+a2*dc(i,k-1))-delp(i,k-1)*a1*dc(i,k))-g_d4(i,k+1)*2/((d4(i,k-1)+d4(i,k+1))*(d4(i,k-1)+d4(i,&
&k+1)))*(delp(i,k)*(c1*(a1-a2)+a2*dc(i,k-1))-delp(i,k-1)*a1*dc(i,k))+g_dc(i,k-1)*2./(d4(i,k-1)+d4(i,k+1))*delp(i,k)*a2-g_dc(i,&
&k)*2./(d4(i,k-1)+d4(i,k+1))*delp(i,k-1)*a1-g_delp(i,k-1)*2./(d4(i,k-1)+d4(i,k+1))*a1*dc(i,k)+g_delp(i,k)*2./(d4(i,k-1)+d4(i,k+&
&1))*(c1*(a1-a2)+a2*dc(i,k-1))
    a4(2,i,k) = a4(1,i,k-1)+c1+2./(d4(i,k-1)+d4(i,k+1))*(delp(i,k)*(c1*(a1-a2)+a2*dc(i,k-1))-delp(i,k-1)*a1*dc(i,k))
  end do
end do
if (km .gt. 8 .and. kord .gt. 3) then
  call g_steepz( i1,i2,km,a4,g_a4,df2,g_df2,dc,g_dc,delq,g_delq,delp,g_delp,d4,g_d4 )
endif
do i = i1, i2
  g_d1 = g_delp(i,1)
  d1 = delp(i,1)
  g_d2 = g_delp(i,2)
  d2 = delp(i,2)
  g_qm = g_a4(1,i,2)*(d1/(d1+d2))+g_a4(1,i,1)*(d2/(d1+d2))+g_d1*(a4(1,i,2)/(d1+d2)-(d2*a4(1,i,1)+d1*a4(1,i,2))/((d1+d2)*(d1+d2)))+&
&g_d2*(a4(1,i,1)/(d1+d2)-(d2*a4(1,i,1)+d1*a4(1,i,2))/((d1+d2)*(d1+d2)))
  qm = (d2*a4(1,i,1)+d1*a4(1,i,2))/(d1+d2)
  g_dq = g_a4(1,i,2)*(2/(d1+d2))+g_a4(1,i,1)*((-2)/(d1+d2))-g_d1*(2*(a4(1,i,2)-a4(1,i,1))/((d1+d2)*(d1+d2)))-g_d2*(2*(a4(1,i,2)-&
&a4(1,i,1))/((d1+d2)*(d1+d2)))
  dq = 2.*(a4(1,i,2)-a4(1,i,1))/(d1+d2)
  g_c1 = g_a4(2,i,3)*(4/(d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_d1*(4.*(a4(2,i,3)-qm-d2*dq)*d2*(3*d1+d2+3.*d1)/(d2*(2.*d2*d2+d1*(d2+3.*d1)&
&)*d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_d2*(4.*dq/(d2*(2.*d2*d2+d1*(d2+3.*d1)))+4.*(a4(2,i,3)-qm-d2*dq)*(d2*(4*d2+d1)+2.*d2*d2+d1*(d2+&
&3.*d1))/(d2*(2.*d2*d2+d1*(d2+3.*d1))*d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_dq*(4.*d2/(d2*(2.*d2*d2+d1*(d2+3.*d1))))+g_qm*((-4)/(d2*&
&(2.*d2*d2+d1*(d2+3.*d1))))
  c1 = 4.*(a4(2,i,3)-qm-d2*dq)/(d2*(2.*d2*d2+d1*(d2+3.*d1)))
  g_c3 = (-(0.5*g_c1*(d2*(5.*d1+d2)-3.*d1*d1)+0.5*g_d1*c1*(5*d2-6*d1)+0.5*g_d2*c1*(d2+5.*d1+d2)))+g_dq
  c3 = dq-0.5*c1*(d2*(5.*d1+d2)-3.*d1*d1)
  g_a4(2,i,2) = (-(0.25*g_c1*d1*d2*(d2+3.*d1)+g_d1*(0.75*c1*d1*d2+0.25*c1*d2*(d2+3.*d1))+g_d2*(0.25*c1*d1*d2+0.25*c1*d1*(d2+3.*d1))&
&))+g_qm
  a4(2,i,2) = qm-0.25*c1*d1*d2*(d2+3.*d1)
  g_a4(2,i,1) = g_a4(2,i,2)+2*g_c1*d1*d1**2-g_c3*d1+g_d1*(4*d1*c1*d1+2.*c1*d1**2-c3)
  a4(2,i,1) = d1*(2.*c1*d1**2-c3)+a4(2,i,2)
  g_a4u = g_a4(1,i,2)*(0.5-sign(0.5,a4(1,i,2)-a4(1,i,1)))+g_a4(1,i,1)*(0.5+sign(0.5,a4(1,i,2)-a4(1,i,1)))
  a4u = min(a4(1,i,1),a4(1,i,2))
  g_a4(2,i,2) = g_a4(2,i,2)*(0.5+sign(0.5,a4(2,i,2)-a4u))+g_a4u*(0.5-sign(0.5,a4(2,i,2)-a4u))
  a4(2,i,2) = max(a4(2,i,2),a4u)
  g_a4t = g_a4(1,i,2)*(0.5-sign(0.5,a4(1,i,1)-a4(1,i,2)))+g_a4(1,i,1)*(0.5+sign(0.5,a4(1,i,1)-a4(1,i,2)))
  a4t = max(a4(1,i,1),a4(1,i,2))
  g_a4(2,i,2) = g_a4(2,i,2)*(0.5+sign(0.5,a4t-a4(2,i,2)))+g_a4t*(0.5-sign(0.5,a4t-a4(2,i,2)))
  a4(2,i,2) = min(a4(2,i,2),a4t)
  g_dc(i,1) = 0.5*g_a4(2,i,2)-0.5*g_a4(1,i,1)
  dc(i,1) = 0.5*(a4(2,i,2)-a4(1,i,1))
end do
if (iv .eq. 0) then
  do i = i1, i2
    g_a4(2,i,1) = g_a4(2,i,1)*(0.5-sign(0.5,0.-a4(2,i,1)))
    a4(2,i,1) = max(0.,a4(2,i,1))
    g_a4(2,i,2) = g_a4(2,i,2)*(0.5-sign(0.5,0.-a4(2,i,2)))
    a4(2,i,2) = max(0.,a4(2,i,2))
  end do
else if (iv .eq. (-1)) then
  do i = i1, i2
    if (a4(2,i,1)*a4(1,i,1) .le. 0.) then
      g_a4(2,i,1) = 0.
      a4(2,i,1) = 0.
    endif
  end do
endif
do i = i1, i2
  g_d1 = g_delp(i,km)
  d1 = delp(i,km)
  g_d2 = g_delp(i,km1)
  d2 = delp(i,km1)
  g_qm = g_a4(1,i,km)*(d2/(d1+d2))+g_a4(1,i,km1)*(d1/(d1+d2))+g_d1*(a4(1,i,km1)/(d1+d2)-(d2*a4(1,i,km)+d1*a4(1,i,km1))/((d1+d2)*&
&(d1+d2)))+g_d2*(a4(1,i,km)/(d1+d2)-(d2*a4(1,i,km)+d1*a4(1,i,km1))/((d1+d2)*(d1+d2)))
  qm = (d2*a4(1,i,km)+d1*a4(1,i,km1))/(d1+d2)
  g_dq = g_a4(1,i,km)*((-2)/(d1+d2))+g_a4(1,i,km1)*(2/(d1+d2))-g_d1*(2*(a4(1,i,km1)-a4(1,i,km))/((d1+d2)*(d1+d2)))-g_d2*(2*(a4(1,i,&
&km1)-a4(1,i,km))/((d1+d2)*(d1+d2)))
  dq = 2.*(a4(1,i,km1)-a4(1,i,km))/(d1+d2)
  g_c1 = g_a4(2,i,km1)/(d2*(2.*d2*d2+d1*(d2+3.*d1)))-g_d1*((a4(2,i,km1)-qm-d2*dq)*d2*(3*d1+d2+3.*d1)/(d2*(2.*d2*d2+d1*(d2+3.*d1))*&
&d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_d2*(dq/(d2*(2.*d2*d2+d1*(d2+3.*d1)))+(a4(2,i,km1)-qm-d2*dq)*(d2*(4*d2+d1)+2.*d2*d2+d1*(d2+3.*d1)&
&)/(d2*(2.*d2*d2+d1*(d2+3.*d1))*d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_dq*(d2/(d2*(2.*d2*d2+d1*(d2+3.*d1))))-g_qm/(d2*(2.*d2*d2+d1*(d2+&
&3.*d1)))
  c1 = (a4(2,i,km1)-qm-d2*dq)/(d2*(2.*d2*d2+d1*(d2+3.*d1)))
  g_c3 = (-(2*g_c1*(d2*(5.*d1+d2)-3.*d1*d1)+2.*g_d1*c1*(5*d2-6*d1)+2.*g_d2*c1*(d2+5.*d1+d2)))+g_dq
  c3 = dq-2.*c1*(d2*(5.*d1+d2)-3.*d1*d1)
  g_a4(2,i,km) = (-(g_c1*d1*d2*(d2+3.*d1)+g_d1*(3*c1*d1*d2+c1*d2*(d2+3.*d1))+g_d2*c1*d1*(2*d2+3.*d1)))+g_qm
  a4(2,i,km) = qm-c1*d1*d2*(d2+3.*d1)
  g_a4(3,i,km) = g_a4(2,i,km)+8*g_c1*d1*d1**2-g_c3*d1+g_d1*(16*d1*c1*d1+8.*c1*d1**2-c3)
  a4(3,i,km) = d1*(8.*c1*d1**2-c3)+a4(2,i,km)
  g_a4s = g_a4(1,i,km)*(0.5+sign(0.5,a4(1,i,km1)-a4(1,i,km)))+g_a4(1,i,km1)*(0.5-sign(0.5,a4(1,i,km1)-a4(1,i,km)))
  a4s = min(a4(1,i,km),a4(1,i,km1))
  g_a4(2,i,km) = g_a4(2,i,km)*(0.5+sign(0.5,a4(2,i,km)-a4s))+g_a4s*(0.5-sign(0.5,a4(2,i,km)-a4s))
  a4(2,i,km) = max(a4(2,i,km),a4s)
  g_a4r = g_a4(1,i,km)*(0.5+sign(0.5,a4(1,i,km)-a4(1,i,km1)))+g_a4(1,i,km1)*(0.5-sign(0.5,a4(1,i,km)-a4(1,i,km1)))
  a4r = max(a4(1,i,km),a4(1,i,km1))
  g_a4(2,i,km) = g_a4(2,i,km)*(0.5+sign(0.5,a4r-a4(2,i,km)))+g_a4r*(0.5-sign(0.5,a4r-a4(2,i,km)))
  a4(2,i,km) = min(a4(2,i,km),a4r)
  g_dc(i,km) = (-0.5)*g_a4(2,i,km)+0.5*g_a4(1,i,km)
  dc(i,km) = 0.5*(a4(1,i,km)-a4(2,i,km))
end do
if (bot_mono_kim) then
  do i = i1, i2
    g_a4(4,i,km) = 0.
    a4(4,i,km) = 0
    if (a4(3,i,km)*a4(1,i,km) .le. 0.) then
      g_a4(3,i,km) = 0.
      a4(3,i,km) = 0.
    endif
    g_d1 = (-g_a4(2,i,km))+g_a4(1,i,km)
    d1 = a4(1,i,km)-a4(2,i,km)
    g_d2 = g_a4(3,i,km)-g_a4(1,i,km)
    d2 = a4(3,i,km)-a4(1,i,km)
    if (d1*d2 .lt. 0.) then
      g_a4(2,i,km) = g_a4(1,i,km)
      a4(2,i,km) = a4(1,i,km)
      g_a4(3,i,km) = g_a4(1,i,km)
      a4(3,i,km) = a4(1,i,km)
    else
      g_dqh = g_d1*sign(1.,d1)
      dqh = abs(d1)
      g_dqi = g_d2*sign(1.,d2)
      dqi = abs(d2)
      g_dqj = 0.5*g_delq(i,km-1)*sign(1.,delq(i,km-1))
      dqj = 0.5*abs(delq(i,km-1))
      g_dqk = g_dqh*(0.5+sign(0.5,dqi-dqh))+g_dqi*(0.5-sign(0.5,dqi-dqh))
      dqk = min(dqh,dqi)
      g_dql = g_dqj*(0.5-sign(0.5,dqj-dqk))+g_dqk*(0.5+sign(0.5,dqj-dqk))
      dql = min(dqk,dqj)
      g_dq = g_dql*sign(1.,dql)*sign(1.,d1)
      dq = sign(dql,d1)
      g_a4(2,i,km) = g_a4(1,i,km)-g_dq
      a4(2,i,km) = a4(1,i,km)-dq
      g_a4(3,i,km) = g_a4(1,i,km)+g_dq
      a4(3,i,km) = a4(1,i,km)+dq
    endif
  end do
else
  if (iv .eq. 0) then
    do i = i1, i2
      g_a4(2,i,km) = g_a4(2,i,km)*(0.5-sign(0.5,0.-a4(2,i,km)))
      a4(2,i,km) = max(0.,a4(2,i,km))
      g_a4(3,i,km) = g_a4(3,i,km)*(0.5-sign(0.5,0.-a4(3,i,km)))
      a4(3,i,km) = max(0.,a4(3,i,km))
    end do
  else if (iv .eq. (-1)) then
    do i = i1, i2
      if (a4(1,i,km)*a4(3,i,km) .le. 0.) then
        g_a4(3,i,km) = 0.
        a4(3,i,km) = 0.
      endif
    end do
  endif
endif
do k = 1, km1
  do i = i1, i2
    g_a4(3,i,k) = g_a4(2,i,k+1)
    a4(3,i,k) = a4(2,i,k+1)
  end do
end do
do k = 1, 2
  do i = i1, i2
    g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
    a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
  end do
  call g_ppm_limiters( dc(i1,k),g_dc(i1,k),a4(1,i1,k),g_a4(1,i1,k),it,0 )
end do
if (kord .ge. 7) then
  do k = 2, km1
    do i = i1, i2
      g_h2(i,k) = (-(g_dc(i,k-1)*2.*(1/delp(i,k-1))/(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))*delp(i,k)**2))+g_dc(i,k+1)*2.*(1/&
&delp(i,k+1))/(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))*delp(i,k)**2+g_delp(i,k-1)*(2.*(dc(i,k-1)/(delp(i,k-1)*delp(i,k-1)))/&
&(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))-(dc(i,k+1)/delp(i,k+1)-dc(i,k-1)/delp(i,k-1))/((delp(i,k)+0.5*(delp(i,k-1)+delp(i,&
&k+1)))*(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))))*delp(i,k)**2-g_delp(i,k+1)*(2.*(dc(i,k+1)/(delp(i,k+1)*delp(i,k+1)))/&
&(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))+(dc(i,k+1)/delp(i,k+1)-dc(i,k-1)/delp(i,k-1))/((delp(i,k)+0.5*(delp(i,k-1)+delp(i,&
&k+1)))*(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))))*delp(i,k)**2+g_delp(i,k)*(2*2.*(dc(i,k+1)/delp(i,k+1)-dc(i,k-1)/delp(i,k-&
&1))/(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))*delp(i,k)-2*(dc(i,k+1)/delp(i,k+1)-dc(i,k-1)/delp(i,k-1))/((delp(i,k)+0.5*&
&(delp(i,k-1)+delp(i,k+1)))*(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1))))*delp(i,k)**2)
      h2(i,k) = 2.*(dc(i,k+1)/delp(i,k+1)-dc(i,k-1)/delp(i,k-1))/(delp(i,k)+0.5*(delp(i,k-1)+delp(i,k+1)))*delp(i,k)**2
    end do
  end do
  fac = 1.5
  do k = 3, km-2
    do i = i1, i2
      g_pmp = 2*g_dc(i,k)
      pmp = 2.*dc(i,k)
      g_qmp = g_a4(1,i,k)+g_pmp
      qmp = a4(1,i,k)+pmp
      g_lac = g_a4(1,i,k)+g_dc(i,k)+g_h2(i,k-1)*fac
      lac = a4(1,i,k)+fac*h2(i,k-1)+dc(i,k)
      g_a4n = g_a4(1,i,k)*(0.5+sign(0.5,qmp-a4(1,i,k)))+g_qmp*(0.5-sign(0.5,qmp-a4(1,i,k)))
      a4n = min(a4(1,i,k),qmp)
      g_a4o = g_a4n*(0.5+sign(0.5,lac-a4n))+g_lac*(0.5-sign(0.5,lac-a4n))
      a4o = min(a4n,lac)
      g_a4m = g_a4(3,i,k)*(0.5+sign(0.5,a4(3,i,k)-a4o))+g_a4o*(0.5-sign(0.5,a4(3,i,k)-a4o))
      a4m = max(a4(3,i,k),a4o)
      g_a4p = g_a4(1,i,k)*(0.5+sign(0.5,a4(1,i,k)-qmp))+g_qmp*(0.5-sign(0.5,a4(1,i,k)-qmp))
      a4p = max(a4(1,i,k),qmp)
      g_a4q = g_a4p*(0.5+sign(0.5,a4p-lac))+g_lac*(0.5-sign(0.5,a4p-lac))
      a4q = max(a4p,lac)
      g_a4(3,i,k) = g_a4m*(0.5+sign(0.5,a4q-a4m))+g_a4q*(0.5-sign(0.5,a4q-a4m))
      a4(3,i,k) = min(a4m,a4q)
      g_qmp = g_a4(1,i,k)-g_pmp
      qmp = a4(1,i,k)-pmp
      g_lac = g_a4(1,i,k)-g_dc(i,k)+g_h2(i,k+1)*fac
      lac = a4(1,i,k)+fac*h2(i,k+1)-dc(i,k)
      g_a4i = g_a4(1,i,k)*(0.5+sign(0.5,qmp-a4(1,i,k)))+g_qmp*(0.5-sign(0.5,qmp-a4(1,i,k)))
      a4i = min(a4(1,i,k),qmp)
      g_a4j = g_a4i*(0.5+sign(0.5,lac-a4i))+g_lac*(0.5-sign(0.5,lac-a4i))
      a4j = min(a4i,lac)
      g_a4h = g_a4(2,i,k)*(0.5+sign(0.5,a4(2,i,k)-a4j))+g_a4j*(0.5-sign(0.5,a4(2,i,k)-a4j))
      a4h = max(a4(2,i,k),a4j)
      g_a4k = g_a4(1,i,k)*(0.5+sign(0.5,a4(1,i,k)-qmp))+g_qmp*(0.5-sign(0.5,a4(1,i,k)-qmp))
      a4k = max(a4(1,i,k),qmp)
      g_a4l = g_a4k*(0.5+sign(0.5,a4k-lac))+g_lac*(0.5-sign(0.5,a4k-lac))
      a4l = max(a4k,lac)
      g_a4(2,i,k) = g_a4h*(0.5+sign(0.5,a4l-a4h))+g_a4l*(0.5-sign(0.5,a4l-a4h))
      a4(2,i,k) = min(a4h,a4l)
      g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
      a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
    end do
    if (iv .eq. 0 .and. kord .ge. 6) then
      call g_ppm_limiters( dc(i1,k),g_dc(i1,k),a4(1,i1,k),g_a4(1,i1,k),it,2 )
    endif
  end do
else
  lmt = kord-3
  lmt = max(0,lmt)
  if (iv .eq. 0) then
    lmt = min(2,lmt)
  endif
  do k = 3, km-2
    if (kord .ne. 4) then
      do i = i1, i2
        g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
        a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
      end do
    endif
    if (kord .ne. 6) then
      call g_ppm_limiters( dc(i1,k),g_dc(i1,k),a4(1,i1,k),g_a4(1,i1,k),it,lmt )
    endif
  end do
endif
do k = km1, km
  do i = i1, i2
    g_a4(4,i,k) = (-3)*g_a4(3,i,k)-3*g_a4(2,i,k)+6*g_a4(1,i,k)
    a4(4,i,k) = 3.*(2.*a4(1,i,k)-(a4(2,i,k)+a4(3,i,k)))
  end do
  call g_ppm_limiters( dc(i1,k),g_dc(i1,k),a4(1,i1,k),g_a4(1,i1,k),it,0 )
end do

end subroutine g_ppm_profile


subroutine g_remap_z( km, pe1, g_pe1, q1, g_q1, kn, pe2, g_pe2, q2, g_q2, i1, i2, kord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r23 = 2./3.
real, parameter :: r3 = 1./3.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: km
real, intent(in) :: g_pe1(i1:i2,km+1)
integer, intent(in) :: kn
real, intent(in) :: g_pe2(i1:i2,kn+1)
real, intent(in) :: g_q1(i1:i2,km)
real, intent(inout) :: g_q2(i1:i2,kn)
integer, intent(in) :: kord
real, intent(in) :: pe1(i1:i2,km+1)
real, intent(in) :: pe2(i1:i2,kn+1)
real, intent(in) :: q1(i1:i2,km)
real, intent(inout) :: q2(i1:i2,kn)

!==============================================
! declare local variables
!==============================================
real :: delp
real :: dp1(i1:i2,km)
real :: esl
real :: g_delp
real :: g_dp1(i1:i2,km)
real :: g_esl
real :: g_pl
real :: g_pr
real :: g_q4(4,i1:i2,km)
real :: g_qsum
integer :: i
integer :: k
integer :: k0
integer :: l
logical :: l_123
logical :: l_555
logical :: l_loop
integer :: m
logical :: m_123
real :: pl
real :: pr
real :: q4(4,i1:i2,km)
real :: qsum

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, km
  do i = i1, i2
    g_dp1(i,k) = g_pe1(i,k+1)-g_pe1(i,k)
    dp1(i,k) = pe1(i,k+1)-pe1(i,k)
    g_q4(1,i,k) = g_q1(i,k)
    q4(1,i,k) = q1(i,k)
  end do
end do
if (kord .gt. 7) then
  call g_cs_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,1,kord )
else
  call g_ppm_profile( q4,g_q4,dp1,g_dp1,km,i1,i2,1,kord )
endif
do i = i1, i2
  k0 = 1
  do k = 1, kn
    l_123 =  .false. 
    l_555 =  .false. 
    l_loop =  .false. 
    l = k0
    if (l_loop .eq.  .false. ) then
      if (pe2(i,k) .le. pe1(i,l) .and. pe2(i,k) .ge. pe1(i,l+1)) then
        g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
        pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
        if (pe2(i,k+1) .ge. pe1(i,l+1)) then
          if (l_555 .eq.  .false. ) then
            g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
            pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
            g_q2(i,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))&
&-q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
            q2(i,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
            l_555 =  .true. 
          endif
        else
          if (l_123 .eq.  .false. ) then
            m_123 =  .false. 
            m = l+1
            if (m_123 .eq.  .false. ) then
              if (pe2(i,k+1) .lt. pe1(i,m+1)) then
              else
m_123 =  .true. 
              endif
            endif
            do while ( m_123 .eq.  .false.  .or. m .lt. km )
              m = m+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .lt. pe1(i,m+1)) then
else
  m_123 =  .true. 
endif
              endif
            end do
            l_123 =  .true. 
          endif
        endif
      endif
      if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
        l_loop =  .true. 
      endif
    endif
    if (l_loop .eq.  .false.  .and. l .lt. km) then
      l = l+1
    endif
    do while ( l_loop .eq.  .false.  .and. l .le. km )
      if (l_loop .eq.  .false. ) then
        if (pe2(i,k) .le. pe1(i,l) .and. pe2(i,k) .ge. pe1(i,l+1)) then
          g_pl = (-(g_dp1(i,l)*((pe2(i,k)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k)/dp1(i,l)
          pl = (pe2(i,k)-pe1(i,l))/dp1(i,l)
          if (pe2(i,k+1) .ge. pe1(i,l+1)) then
            if (l_555 .eq.  .false. ) then
              g_pr = (-(g_dp1(i,l)*((pe2(i,k+1)-pe1(i,l))/(dp1(i,l)*dp1(i,l)))+g_pe1(i,l)/dp1(i,l)))+g_pe2(i,k+1)/dp1(i,l)
              pr = (pe2(i,k+1)-pe1(i,l))/dp1(i,l)
              g_q2(i,k) = g_pl*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(pr+2*pl))+g_pr*(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,&
&l))-q4(4,i,l)*r3*(2*pr+pl))+g_q4(4,i,l)*(0.5*(pr+pl)-r3*(pr*(pr+pl)+pl**2))+0.5*g_q4(3,i,l)*(pr+pl)+g_q4(2,i,l)*(1+(-0.5)*(pr+pl))
              q2(i,k) = q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(pr+pl)-q4(4,i,l)*r3*(pr*(pr+pl)+pl**2)
              k0 = l
              l_555 =  .true. 
            endif
          else
            if (l_123 .eq.  .false. ) then
              g_qsum = g_pe1(i,l+1)*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))-g_pe2(i,k)&
&*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))+g_pl*(pe1(i,l+1)-pe2(i,k))*&
&(0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))-q4(4,i,l)*r3*(1+2*pl))+g_q4(4,i,l)*(pe1(i,l+1)-pe2(i,k))*(0.5*(1.+pl)-r3*(1.+&
&pl*(1.+pl)))+0.5*g_q4(3,i,l)*(pe1(i,l+1)-pe2(i,k))*(1.+pl)+g_q4(2,i,l)*(pe1(i,l+1)-pe2(i,k))*(1+(-0.5)*(1.+pl))
              qsum = (pe1(i,l+1)-pe2(i,k))*(q4(2,i,l)+0.5*(q4(4,i,l)+q4(3,i,l)-q4(2,i,l))*(1.+pl)-q4(4,i,l)*r3*(1.+pl*(1.+pl)))
              m_123 =  .false. 
              m = l+1
              if (m_123 .eq.  .false. ) then
if (pe2(i,k+1) .lt. pe1(i,m+1)) then
  g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
  qsum = qsum+dp1(i,m)*q4(1,i,m)
else
  g_delp = (-g_pe1(i,m))+g_pe2(i,k+1)
  delp = pe2(i,k+1)-pe1(i,m)
  g_esl = g_delp/dp1(i,m)-g_dp1(i,m)*(delp/(dp1(i,m)*dp1(i,m)))
  esl = delp/dp1(i,m)
  g_qsum = g_delp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*delp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*&
&(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*delp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*delp*esl+g_q4(2,i,m)*delp*&
&(1+(-0.5)*esl)+g_qsum
  qsum = qsum+delp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
  m_123 =  .true. 
endif
              endif
              do while ( m_123 .eq.  .false.  .or. m .lt. km )
m = m+1
if (m_123 .eq.  .false. ) then
  if (pe2(i,k+1) .lt. pe1(i,m+1)) then
    g_qsum = g_dp1(i,m)*q4(1,i,m)+g_q4(1,i,m)*dp1(i,m)+g_qsum
    qsum = qsum+dp1(i,m)*q4(1,i,m)
  else
    g_delp = (-g_pe1(i,m))+g_pe2(i,k+1)
    delp = pe2(i,k+1)-pe1(i,m)
    g_esl = g_delp/dp1(i,m)-g_dp1(i,m)*(delp/(dp1(i,m)*dp1(i,m)))
    esl = delp/dp1(i,m)
    g_qsum = g_delp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+g_esl*delp*((-(0.5*esl*q4(4,i,m)*r23))+0.5*&
&(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))+0.5*g_q4(4,i,m)*delp*esl*(1.-r23*esl)+0.5*g_q4(3,i,m)*delp*esl+g_q4(2,i,m)*delp*&
&(1+(-0.5)*esl)+g_qsum
    qsum = qsum+delp*(q4(2,i,m)+0.5*esl*(q4(3,i,m)-q4(2,i,m)+q4(4,i,m)*(1.-r23*esl)))
    k0 = m
    m_123 =  .true. 
  endif
endif
              end do
              l_123 =  .true. 
            endif
          endif
        endif
        if (l_555 .eq. ( .true. ) .or. l_123 .eq. ( .true. ) .or. m_123 .eq. ( .true. )) then
          l_loop =  .true. 
        endif
      endif
      if (l_loop .eq.  .false.  .and. l .lt. km) then
        l = l+1
      endif
    end do
    if (l_555 .eq.  .false. ) then
      g_q2(i,k) = (-(g_pe2(i,k+1)*(qsum/((pe2(i,k+1)-pe2(i,k))*(pe2(i,k+1)-pe2(i,k))))))+g_pe2(i,k)*(qsum/((pe2(i,k+1)-pe2(i,k))*&
&(pe2(i,k+1)-pe2(i,k))))+g_qsum/(pe2(i,k+1)-pe2(i,k))
      q2(i,k) = qsum/(pe2(i,k+1)-pe2(i,k))
    endif
  end do
end do

end subroutine g_remap_z


subroutine g_steepz( i1, i2, km, a4, g_a4, df2, g_df2, dm, g_dm, dq, g_dq, dp, g_dp, d4, g_d4 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: i1
integer, intent(in) :: i2
integer, intent(in) :: km
real, intent(inout) :: a4(4,i1:i2,km)
real, intent(in) :: d4(i1:i2,km)
real, intent(in) :: df2(i1:i2,km)
real, intent(in) :: dm(i1:i2,km)
real, intent(in) :: dp(i1:i2,km)
real, intent(in) :: dq(i1:i2,km)
real, intent(inout) :: g_a4(4,i1:i2,km)
real, intent(in) :: g_d4(i1:i2,km)
real, intent(in) :: g_df2(i1:i2,km)
real, intent(in) :: g_dm(i1:i2,km)
real, intent(in) :: g_dp(i1:i2,km)
real, intent(in) :: g_dq(i1:i2,km)

!==============================================
! declare local variables
!==============================================
real :: alfa(i1:i2,km)
real :: alfah
real :: dg2
real :: f(i1:i2,km)
real :: g_alfa(i1:i2,km)
real :: g_alfah
real :: g_dg2
real :: g_f(i1:i2,km)
real :: g_rat(i1:i2,km)
integer :: i
integer :: k
real :: rat(i1:i2,km)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 2, km
  do i = i1, i2
    g_rat(i,k) = (-(g_d4(i,k)*(dq(i,k-1)/(d4(i,k)*d4(i,k)))))+g_dq(i,k-1)/d4(i,k)
    rat(i,k) = dq(i,k-1)/d4(i,k)
  end do
end do
do k = 2, km-1
  do i = i1, i2
    g_f(i,k) = (-((g_dp(i,k-1)+g_dp(i,k+1)+g_dp(i,k))*((rat(i,k+1)-rat(i,k))/((dp(i,k-1)+dp(i,k)+dp(i,k+1))*(dp(i,k-1)+dp(i,k)+&
&dp(i,k+1))))))+g_rat(i,k+1)/(dp(i,k-1)+dp(i,k)+dp(i,k+1))-g_rat(i,k)/(dp(i,k-1)+dp(i,k)+dp(i,k+1))
    f(i,k) = (rat(i,k+1)-rat(i,k))/(dp(i,k-1)+dp(i,k)+dp(i,k+1))
  end do
end do
do k = 3, km-2
  do i = i1, i2
    if (f(i,k+1)*f(i,k-1) .lt. 0. .and. df2(i,k) .ne. 0.) then
      g_dg2 = g_d4(i,k+1)*(f(i,k+1)-f(i,k-1))*d4(i,k)+g_d4(i,k)*(f(i,k+1)-f(i,k-1))*d4(i,k+1)-2*g_dp(i,k-1)*(f(i,k+1)-f(i,k-1))*&
&(dp(i,k+1)-dp(i,k-1))+2*g_dp(i,k+1)*(f(i,k+1)-f(i,k-1))*(dp(i,k+1)-dp(i,k-1))-g_f(i,k-1)*((dp(i,k+1)-dp(i,k-1))**2+d4(i,k)*&
&d4(i,k+1))+g_f(i,k+1)*((dp(i,k+1)-dp(i,k-1))**2+d4(i,k)*d4(i,k+1))
      dg2 = (f(i,k+1)-f(i,k-1))*((dp(i,k+1)-dp(i,k-1))**2+d4(i,k)*d4(i,k+1))
      g_alfah = g_df2(i,k)*(0.5-sign(0.5,(-(0.1875*dg2/df2(i,k)))-0.5))*(0.1875*dg2/(df2(i,k)*df2(i,k)))-g_dg2*(0.5-sign(0.5,(-&
&(0.1875*dg2/df2(i,k)))-0.5))*(0.1875/df2(i,k))
      alfah = min(0.5,-(0.1875*dg2/df2(i,k)))
      g_alfa(i,k) = g_alfah*(0.5-sign(0.5,0.-alfah))
      alfa(i,k) = max(0.,alfah)
    else
      g_alfa(i,k) = 0.
      alfa(i,k) = 0.
    endif
  end do
end do
do k = 4, km-2
  do i = i1, i2
    g_a4(2,i,k) = g_a4(1,i,k-1)*alfa(i,k)+g_a4(2,i,k)*(1.-alfa(i,k-1)-alfa(i,k))+g_a4(1,i,k)*alfa(i,k-1)+g_alfa(i,k-1)*((-a4(2,i,k)&
&)+a4(1,i,k)-dm(i,k))+g_alfa(i,k)*((-a4(2,i,k))+a4(1,i,k-1)+dm(i,k-1))+g_dm(i,k-1)*alfa(i,k)-g_dm(i,k)*alfa(i,k-1)
    a4(2,i,k) = (1.-alfa(i,k-1)-alfa(i,k))*a4(2,i,k)+alfa(i,k-1)*(a4(1,i,k)-dm(i,k))+alfa(i,k)*(a4(1,i,k-1)+dm(i,k-1))
  end do
end do

end subroutine g_steepz


end module     g_mapz_module


