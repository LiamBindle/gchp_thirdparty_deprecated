!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine g_f_dyn( npx, npy, npz, nq, ng, bdt, consv_te, fill, reproduce_sum, kappa, cp_air, zvir, ks, ncnst, n_split, q_split, u,&
& g_u, v, g_v, w, g_w, delz, g_delz, hydrostatic, pt, g_pt, delp, g_delp, q, g_q, ps, pe, g_pe, pk, peln, pkz, g_pkz, phis, omga, &
&ua, g_ua, va, g_va, uc, vc, ak, bk, mfx, mfy, cx, cy, u_srf, v_srf, srf_init, ze0, g_ze0, hybrid_z, time_total, y_u, g_y_u, y_v, &
&g_y_v, y_pt, g_y_pt, y_delp, g_y_delp, y_q, g_y_q )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_dynamics_mod, only : fv_dynamics
use mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use g_fv_dynamics_mod, only : g_fv_dynamics

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(in) :: ak(npz+1)
real, intent(in) :: bdt
real, intent(in) :: bk(npz+1)
real, intent(in) :: consv_te
real, intent(in) :: cp_air
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
logical, intent(in) :: fill
real, intent(inout) :: g_delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_delz(is:ie,js:je,npz)
real, intent(inout) :: g_pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: g_pkz(is:ie,js:je,npz)
real, intent(inout) :: g_pt(isd:ied,jsd:jed,npz)
integer, intent(in) :: ncnst
real, intent(inout) :: g_q(isd:ied,jsd:jed,npz,ncnst)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: g_ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: g_va(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_w(isd:ied,jsd:jed,npz)
real, intent(out) :: g_y_delp(isd:ied,jsd:jed,npz)
real, intent(out) :: g_y_pt(isd:ied,jsd:jed,npz)
real, intent(out) :: g_y_q(isd:ied,jsd:jed,npz,ncnst)
real, intent(out) :: g_y_u(isd:ied,jsd:jed+1,npz)
real, intent(out) :: g_y_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: g_ze0(is:ie,js:je,npz+1)
logical, intent(in) :: hybrid_z
logical, intent(in) :: hydrostatic
real, intent(in) :: kappa
integer, intent(in) :: ks
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: nq
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pkz(is:ie,js:je,npz)
real, intent(inout) :: ps(isd:ied,jsd:jed)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: q(isd:ied,jsd:jed,npz,ncnst)
integer, intent(in) :: q_split
logical, intent(in) :: reproduce_sum
logical, intent(inout) :: srf_init
real,optional, intent(in) :: time_total
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(out) :: u_srf(is:ie,js:je)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(out) :: v_srf(is:ie,js:je)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)
real, intent(out) :: y_delp(isd:ied,jsd:jed,npz)
real, intent(out) :: y_pt(isd:ied,jsd:jed,npz)
real, intent(out) :: y_q(isd:ied,jsd:jed,npz,ncnst)
real, intent(out) :: y_u(isd:ied,jsd:jed+1,npz)
real, intent(out) :: y_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: ze0(is:ie,js:je,npz+1)
real, intent(in) :: zvir

!==============================================
! declare local variables
!==============================================
real :: g_cxh(is:ie+1,jsd:jed,npz)
real :: g_cyh(isd:ied,js:je+1,npz)
real :: g_mfxh(is:ie+1,js:je,npz)
real :: g_mfyh(is:ie,js:je+1,npz)
real :: g_omgah(isd:ied,jsd:jed,npz)
real :: g_pkh(is:ie,js:je,npz+1)

!----------------------------------------------
! RESET ACTIVE INPUT VARIABLES
!----------------------------------------------
g_delz(:,:,:) = 0.
g_pe(:,:,:) = 0.
g_pkz(:,:,:) = 0.
g_ua(:,:,:) = 0.
g_va(:,:,:) = 0.
g_w(:,:,:) = 0.

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
g_pkh = 0.
g_omgah = 0.
g_mfxh = 0.
g_mfyh = 0.
g_cxh = 0.
g_cyh = 0.
call g_fv_dynamics( npx,npy,npz,nq,ng,bdt,consv_te,fill,reproduce_sum,kappa,cp_air,zvir,ks,ncnst,n_split,q_split,u,g_u,v,g_v,w,g_w,&
&delz,g_delz,hydrostatic,pt,g_pt,delp,g_delp,q,g_q,ps,pe,g_pe,pk,g_pkh,peln,pkz,g_pkz,phis,omga,g_omgah,ua,g_ua,va,g_va,uc,vc,ak,&
&bk,mfx,g_mfxh,mfy,g_mfyh,cx,g_cxh,cy,g_cyh,u_srf,v_srf,srf_init,ze0,g_ze0,hybrid_z,time_total )
g_y_u(isd:ied,jsd:jed+1,npz) = g_u(isd:ied,jsd:jed+1,npz)
y_u(isd:ied,jsd:jed+1,npz) = u(isd:ied,jsd:jed+1,npz)
g_y_v(isd:ied+1,jsd:jed,npz) = g_v(isd:ied+1,jsd:jed,npz)
y_v(isd:ied+1,jsd:jed,npz) = v(isd:ied+1,jsd:jed,npz)
g_y_pt(isd:ied,jsd:jed,npz) = g_pt(isd:ied,jsd:jed,npz)
y_pt(isd:ied,jsd:jed,npz) = pt(isd:ied,jsd:jed,npz)
g_y_delp(isd:ied,jsd:jed,npz) = g_delp(isd:ied,jsd:jed,npz)
y_delp(isd:ied,jsd:jed,npz) = delp(isd:ied,jsd:jed,npz)
g_y_q(isd:ied,jsd:jed,npz,nq) = g_q(isd:ied,jsd:jed,npz,nq)
y_q(isd:ied,jsd:jed,npz,nq) = q(isd:ied,jsd:jed,npz,nq)

end subroutine g_f_dyn


