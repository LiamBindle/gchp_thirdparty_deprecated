module     g_fv_tracer2d_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use tp_core_mod, only : fv_tp_2d
use fv_grid_tools_mod, only : area,dx,dxa,dy,dya,rarea
use fv_grid_utils_mod, only : sina_u,sina_v
use fv_mp_mod, only : domain,gid,ie,ied,is,isd,je,jed,js,jsd,ng
use mpp_domains_mod, only : mpp_update_domains,mpp_update_domains_ad
use fv_timing_mod, only : timing_off, timing_on
use fv_tracer2d_mod
      use fv_my_mpp,  only: mpp_update_domains_dummy,mp_reduce_max_dummy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine g_tracer_2d( q, g_q, dp1, g_dp1, mfx, g_mfx, mfy, g_mfy, cx, g_cx, cy, g_cy, npx, npy, npz, nq, hord, q_split, dt, &
&uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_tp_core_mod, only : g_fv_tp_2d
use g_fv_my_mpp, only : g_mp_reduce_max_dummy, g_mpp_update_domains_dummy4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: dp1(is:ie,js:je,npz)
real, intent(in) :: dt
real, intent(inout) :: g_cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: g_cy(isd:ied,js:je+1,npz)
real, intent(inout) :: g_dp1(is:ie,js:je,npz)
real, intent(inout) :: g_mfx(is:ie+1,js:je,npz)
real, intent(inout) :: g_mfy(is:ie,js:je+1,npz)
integer, intent(in) :: nq
real, intent(inout) :: g_q(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: hord
integer, intent(in) :: id_divg
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: c_global
real :: cmax(npz)
real :: cmaxh
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
real :: g_c_global
real :: g_cmax(npz)
real :: g_cmaxh
real :: g_dp2(isd:ied,jsd:jed)
real :: g_frac
real :: g_fx(is:ie+1,js:je)
real :: g_fy(is:ie,js:je+1)
real :: g_ra_x(is:ie,jsd:jed)
real :: g_ra_y(isd:ied,js:je)
real :: g_rdt
real :: g_xfx(is:ie+1,jsd:jed,npz)
real :: g_yfx(isd:ied,js:je+1,npz)
integer :: i
integer :: iq
integer :: it
integer :: j
integer :: k
integer :: nsplt
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, npz
  do j = jsd, jed
    do i = is, ie+1
      if (cx(i,j,k) .gt. 0.) then
        g_xfx(i,j,k) = g_cx(i,j,k)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
        xfx(i,j,k) = cx(i,j,k)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      else
        g_xfx(i,j,k) = g_cx(i,j,k)*dxa(i,j)*dy(i,j)*sina_u(i,j)
        xfx(i,j,k) = cx(i,j,k)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      endif
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      if (cy(i,j,k) .gt. 0.) then
        g_yfx(i,j,k) = g_cy(i,j,k)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
        yfx(i,j,k) = cy(i,j,k)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      else
        g_yfx(i,j,k) = g_cy(i,j,k)*dya(i,j)*dx(i,j)*sina_v(i,j)
        yfx(i,j,k) = cy(i,j,k)*dya(i,j)*dx(i,j)*sina_v(i,j)
      endif
    end do
  end do
end do
if (q_split .eq. 0) then
  do k = 1, npz
    g_cmax(k) = 0.
    cmax(k) = 0.
    do j = js, je
      do i = is, ie
        g_cmaxh = g_cx(i,j,k)*(0.5+sign(0.5,abs(cx(i,j,k))+1.-sina_u(i,j)-(abs(cy(i,j,k))+1.-sina_v(i,j))))*sign(1.,cx(i,j,k))+&
&g_cy(i,j,k)*(0.5-sign(0.5,abs(cx(i,j,k))+1.-sina_u(i,j)-(abs(cy(i,j,k))+1.-sina_v(i,j))))*sign(1.,cy(i,j,k))
        cmaxh = max(abs(cx(i,j,k))+1.-sina_u(i,j),abs(cy(i,j,k))+1.-sina_v(i,j))
        g_cmax(k) = g_cmax(k)*(0.5-sign(0.5,cmaxh-cmax(k)))+g_cmaxh*(0.5+sign(0.5,cmaxh-cmax(k)))
        cmax(k) = max(cmaxh,cmax(k))
      end do
    end do
  end do
  call g_mp_reduce_max_dummy( cmax,g_cmax,npz )
  g_c_global = g_cmax(1)
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      g_c_global = g_c_global*(0.5-sign(0.5,cmax(k)-c_global))+g_cmax(k)*(0.5+sign(0.5,cmax(k)-c_global))
      c_global = max(cmax(k),c_global)
    end do
  endif
  nsplt = int(1.+c_global)
else
  nsplt = q_split
endif
g_frac = 0.
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do k = 1, npz
    do j = jsd, jed
      do i = is, ie+1
        g_cx(i,j,k) = g_cx(i,j,k)*frac+g_frac*cx(i,j,k)
        cx(i,j,k) = cx(i,j,k)*frac
        g_xfx(i,j,k) = g_frac*xfx(i,j,k)+g_xfx(i,j,k)*frac
        xfx(i,j,k) = xfx(i,j,k)*frac
      end do
    end do
    do j = js, je
      do i = is, ie+1
        g_mfx(i,j,k) = g_frac*mfx(i,j,k)+g_mfx(i,j,k)*frac
        mfx(i,j,k) = mfx(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = isd, ied
        g_cy(i,j,k) = g_cy(i,j,k)*frac+g_frac*cy(i,j,k)
        cy(i,j,k) = cy(i,j,k)*frac
        g_yfx(i,j,k) = g_frac*yfx(i,j,k)+g_yfx(i,j,k)*frac
        yfx(i,j,k) = yfx(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = is, ie
        g_mfy(i,j,k) = g_frac*mfy(i,j,k)+g_mfy(i,j,k)*frac
        mfy(i,j,k) = mfy(i,j,k)*frac
      end do
    end do
  end do
endif
do it = 1, nsplt
  call g_mpp_update_domains_dummy4( q,g_q,is,ie,js,je,isd,ied,jsd,jed,npz,nq )
  do k = 1, npz
    do j = jsd, jed
      do i = is, ie
        g_ra_x(i,j) = (-g_xfx(i+1,j,k))+g_xfx(i,j,k)
        ra_x(i,j) = area(i,j)+xfx(i,j,k)-xfx(i+1,j,k)
      end do
    end do
    do j = js, je
      do i = isd, ied
        g_ra_y(i,j) = (-g_yfx(i,j+1,k))+g_yfx(i,j,k)
        ra_y(i,j) = area(i,j)+yfx(i,j,k)-yfx(i,j+1,k)
      end do
    end do
    do j = js, je
      do i = is, ie
        g_dp2(i,j) = g_dp1(i,j,k)-g_mfx(i+1,j,k)*rarea(i,j)+g_mfx(i,j,k)*rarea(i,j)-g_mfy(i,j+1,k)*rarea(i,j)+g_mfy(i,j,k)*rarea(i,&
&j)
        dp2(i,j) = dp1(i,j,k)+(mfx(i,j,k)-mfx(i+1,j,k)+mfy(i,j,k)-mfy(i,j+1,k))*rarea(i,j)
      end do
    end do
    do iq = 1, nq
      call g_fv_tp_2d( q(isd,jsd,k,iq),g_q(isd,jsd,k,iq),cx(is,jsd,k),g_cx(is,jsd,k),cy(isd,js,k),g_cy(isd,js,k),npx,npy,hord,fx,&
&g_fx,fy,g_fy,xfx(is,jsd,k),g_xfx(is,jsd,k),yfx(isd,js,k),g_yfx(isd,js,k),area,ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,mfx(is,js,&
&k),g_mfx(is,js,k),mfy(is,js,k),g_mfy(is,js,k), .true. ,k )
      do j = js, je
        do i = is, ie
          g_q(i,j,k,iq) = g_dp1(i,j,k)*(q(i,j,k,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,k,iq)*dp1(i,j,k)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,&
&j+1))*rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*&
&(rarea(i,j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,k,iq)*(dp1(i,j,k)/dp2(i,j))
          q(i,j,k,iq) = (q(i,j,k,iq)*dp1(i,j,k)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    end do
    do j = js, je
      do i = is, ie
        g_dp1(i,j,k) = g_dp2(i,j)
        dp1(i,j,k) = dp2(i,j)
      end do
    end do
  end do
end do
if (id_divg .gt. 0) then
  g_rdt = -(g_frac*(1.*dt/(frac*dt*frac*dt)))
  rdt = 1./(frac*dt)
  do k = 1, npz
    do j = js, je
      do i = is, ie
        g_dp1(i,j,k) = g_rdt*(xfx(i+1,j,k)-xfx(i,j,k)+yfx(i,j+1,k)-yfx(i,j,k))*rarea(i,j)+g_xfx(i+1,j,k)*rarea(i,j)*rdt-g_xfx(i,j,&
&k)*rarea(i,j)*rdt+g_yfx(i,j+1,k)*rarea(i,j)*rdt-g_yfx(i,j,k)*rarea(i,j)*rdt
        dp1(i,j,k) = (xfx(i+1,j,k)-xfx(i,j,k)+yfx(i,j+1,k)-yfx(i,j,k))*rarea(i,j)*rdt
      end do
    end do
  end do
endif

end subroutine g_tracer_2d


subroutine g_tracer_2d_1l( q, g_q, dp1, g_dp1, mfx, g_mfx, mfy, g_mfy, cx, g_cx, cy, g_cy, npx, npy, npz, nq, hord, q_split, k, q3,&
& g_q3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_tp_core_mod, only : g_fv_tp_2d
use g_fv_my_mpp, only : g_mp_reduce_max_dummy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
real, intent(inout) :: g_cx(is:ie+1,jsd:jed)
real, intent(inout) :: g_cy(isd:ied,js:je+1)
real, intent(inout) :: g_dp1(is:ie,js:je)
real, intent(inout) :: g_mfx(is:ie+1,js:je)
real, intent(inout) :: g_mfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: g_q(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: g_q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
real, intent(inout) :: q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: cmax
real :: cmaxh
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
real :: g_cmax
real :: g_cmaxh
real :: g_dp2(isd:ied,jsd:jed)
real :: g_frac
real :: g_fx(is:ie+1,js:je)
real :: g_fy(is:ie,js:je+1)
real :: g_ra_x(is:ie,jsd:jed)
real :: g_ra_y(isd:ied,js:je)
real :: g_rdt
real :: g_xfx(is:ie+1,jsd:jed)
real :: g_yfx(isd:ied,js:je+1)
integer :: i
integer :: iq
integer :: it
integer :: j
integer :: nsplt
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      g_xfx(i,j) = g_cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      g_xfx(i,j) = g_cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      g_yfx(i,j) = g_cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      g_yfx(i,j) = g_cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (q_split .eq. 0) then
  g_cmax = 0.
  cmax = 0.
  do j = js, je
    do i = is, ie
      g_cmaxh = g_cx(i,j)*(0.5+sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cx(i,j))+g_cy(i,j)*&
&(0.5-sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cy(i,j))
      cmaxh = max(abs(cx(i,j))+1.-sina_u(i,j),abs(cy(i,j))+1.-sina_v(i,j))
      g_cmax = g_cmax*(0.5-sign(0.5,cmaxh-cmax))+g_cmaxh*(0.5+sign(0.5,cmaxh-cmax))
      cmax = max(cmaxh,cmax)
    end do
  end do
  call g_mp_reduce_max_dummy( cmax,g_cmax )
  nsplt = int(1.0001+cmax)
else
  nsplt = q_split
endif
g_frac = 0.
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      g_cx(i,j) = g_cx(i,j)*frac+g_frac*cx(i,j)
      cx(i,j) = cx(i,j)*frac
      g_xfx(i,j) = g_frac*xfx(i,j)+g_xfx(i,j)*frac
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      g_mfx(i,j) = g_frac*mfx(i,j)+g_mfx(i,j)*frac
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      g_cy(i,j) = g_cy(i,j)*frac+g_frac*cy(i,j)
      cy(i,j) = cy(i,j)*frac
      g_yfx(i,j) = g_frac*yfx(i,j)+g_yfx(i,j)*frac
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      g_mfy(i,j) = g_frac*mfy(i,j)+g_mfy(i,j)*frac
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie
    g_ra_x(i,j) = (-g_xfx(i+1,j))+g_xfx(i,j)
    ra_x(i,j) = area(i,j)+xfx(i,j)-xfx(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    g_ra_y(i,j) = (-g_yfx(i,j+1))+g_yfx(i,j)
    ra_y(i,j) = area(i,j)+yfx(i,j)-yfx(i,j+1)
  end do
end do
do it = 1, nsplt
  do j = js, je
    do i = is, ie
      g_dp2(i,j) = g_dp1(i,j)-g_mfx(i+1,j)*rarea(i,j)+g_mfx(i,j)*rarea(i,j)-g_mfy(i,j+1)*rarea(i,j)+g_mfy(i,j)*rarea(i,j)
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  do iq = 1, nq
    call g_fv_tp_2d( q(isd,jsd,iq),g_q(isd,jsd,iq),cx,g_cx,cy,g_cy,npx,npy,hord,fx,g_fx,fy,g_fy,xfx,g_xfx,yfx,g_yfx,area,ra_x,&
&g_ra_x,ra_y,g_ra_y,uniform_ppm,mfx,g_mfx,mfy,g_mfy, .true. ,k )
    if (it .eq. nsplt) then
      do j = js, je
        do i = is, ie
          g_q3(i,j,k,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q3(i,j,k,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    else
      do j = js, je
        do i = is, ie
          g_q(i,j,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q(i,j,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    endif
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        g_dp1(i,j) = g_dp2(i,j)
        dp1(i,j) = dp2(i,j)
      end do
    end do
  endif
end do
if (id_divg .gt. 0) then
  g_rdt = -(g_frac*(1.*dt/(frac*dt*frac*dt)))
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      g_dp1(i,j) = g_rdt*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)+g_xfx(i+1,j)*rarea(i,j)*rdt-g_xfx(i,j)*rarea(i,j)*&
&rdt+g_yfx(i,j+1)*rarea(i,j)*rdt-g_yfx(i,j)*rarea(i,j)*rdt
      dp1(i,j) = (xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)*rdt
    end do
  end do
endif

end subroutine g_tracer_2d_1l


end module     g_fv_tracer2d_mod


