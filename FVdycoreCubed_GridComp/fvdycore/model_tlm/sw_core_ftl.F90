!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.30
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_sw_core_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.30  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd,ng,mp_corner_comm
use fv_grid_tools_mod, only : area,cosa,dx,dxa,dxc,dy,dya,dyc,npx=>npx_g,npy=>npy_g,rarea,rarea_c,rdx,rdxa,rdxc,rdy,rdya,rdyc,sina
use fv_grid_tools_mod, only : grid_type
use tp_core_mod, only : copy_corners, fv_tp_2d, pert_ppm
use fv_grid_utils_mod, only : big_number,cosa_s,cosa_u,cosa_v,da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,es,&
&ew,f0,fc,gnomonic_grid,ne_corner,nw_corner,rsin2,rsin_u,rsin_v,rsina,se_corner,sina_s,sina_u,sina_v,sw_corner
use sw_core_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none
contains
subroutine g_c_sw( delpc, g_delpc, delp, g_delp, ptc, g_ptc, pt, g_pt, u, g_u, v, g_v, w, g_w, uc, g_uc, vc, g_vc, ua, g_ua, va, &
&g_va, wc, g_wc, ut, g_ut, vt, g_vt, dt2, hydrostatic, dord4, taf_rec_npz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: delp(isd:ied,jsd:jed)
real, intent(out) :: delpc(isd:ied,jsd:jed)
logical, intent(in) :: dord4
real, intent(in) :: dt2
real, intent(inout) :: g_delp(isd:ied,jsd:jed)
real, intent(out) :: g_delpc(isd:ied,jsd:jed)
real, intent(inout) :: g_pt(isd:ied,jsd:jed)
real, intent(out) :: g_ptc(isd:ied,jsd:jed)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1)
real, intent(inout) :: g_ua(isd:ied,jsd:jed)
real, intent(inout) :: g_uc(isd:ied+1,jsd:jed)
real, intent(out) :: g_ut(isd:ied,jsd:jed)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed)
real, intent(inout) :: g_va(isd:ied,jsd:jed)
real, intent(inout) :: g_vc(isd:ied,jsd:jed+1)
real, intent(out) :: g_vt(isd:ied,jsd:jed)
real, intent(inout) :: g_w(isd:ied,jsd:jed)
real, intent(out) :: g_wc(isd:ied,jsd:jed)
logical, intent(in) :: hydrostatic
real, intent(inout) :: pt(isd:ied,jsd:jed)
real, intent(out) :: ptc(isd:ied,jsd:jed)
integer :: taf_rec_npz
real, intent(inout) :: u(isd:ied,jsd:jed+1)
real, intent(inout) :: ua(isd:ied,jsd:jed)
real, intent(inout) :: uc(isd:ied+1,jsd:jed)
real, intent(out) :: ut(isd:ied,jsd:jed)
real, intent(inout) :: v(isd:ied+1,jsd:jed)
real, intent(inout) :: va(isd:ied,jsd:jed)
real, intent(inout) :: vc(isd:ied,jsd:jed+1)
real, intent(out) :: vt(isd:ied,jsd:jed)
real, intent(inout) :: w(isd:ied,jsd:jed)
real, intent(out) :: wc(isd:ied,jsd:jed)

!==============================================
! declare local variables
!==============================================
real :: dt4
real :: fx(is-1:ie+2,js-1:je+1)
real :: fx1(is-1:ie+2,js-1:je+1)
real :: fx2(is-1:ie+2,js-1:je+1)
real :: fy(is-1:ie+1,js-1:je+2)
real :: fy1(is-1:ie+1,js-1:je+2)
real :: fy2(is-1:ie+1,js-1:je+2)
real :: g_fx(is-1:ie+2,js-1:je+1)
real :: g_fx1(is-1:ie+2,js-1:je+1)
real :: g_fx2(is-1:ie+2,js-1:je+1)
real :: g_fy(is-1:ie+1,js-1:je+2)
real :: g_fy1(is-1:ie+1,js-1:je+2)
real :: g_fy2(is-1:ie+1,js-1:je+2)
real :: g_ke(is-1:ie+1,js-1:je+1)
real :: g_vort(is-1:ie+1,js-1:je+1)
integer :: i
integer :: ie1
integer :: iep1
integer :: is2
integer :: j
integer :: jep1
real :: ke(is-1:ie+1,js-1:je+1)
real :: vort(is-1:ie+1,js-1:je+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
iep1 = ie+1
jep1 = je+1
g_vort(is-1,js-1) = 0.
vort(is-1,js-1) = 0.
g_vort(ie+1,je+1) = 0.
vort(ie+1,je+1) = 0.
g_ke(is-1,js-1) = 0.
ke(is-1,js-1) = 0.
g_ke(ie+1,je+1) = 0.
ke(ie+1,je+1) = 0.
g_fx(is-1,js-1) = 0.
fx(is-1,js-1) = 0.
g_fx(ie+1:ie+2,je+1) = 0.
fx(ie+1:ie+2,je+1) = 0.
g_fx1(is-1,js-1) = 0.
fx1(is-1,js-1) = 0.
g_fx1(ie+1:ie+2,je+1) = 0.
fx1(ie+1:ie+2,je+1) = 0.
g_fx2(is-1,js-1) = 0.
fx2(is-1,js-1) = 0.
g_fx2(ie+1:ie+2,je+1) = 0.
fx2(ie+1:ie+2,je+1) = 0.
g_fy(is-1,js-1) = 0.
fy(is-1,js-1) = 0.
g_fy(ie+1,je+1:je+2) = 0.
fy(ie+1,je+1:je+2) = 0.
g_fy1(is-1,js-1) = 0.
fy1(is-1,js-1) = 0.
g_fy1(ie+1,je+1:je+2) = 0.
fy1(ie+1,je+1:je+2) = 0.
g_fy2(is-1,js-1) = 0.
fy2(is-1,js-1) = 0.
g_fy2(ie+1,je+1:je+2) = 0.
fy2(ie+1,je+1:je+2) = 0.
iep1 = ie+1
jep1 = je+1
call g_d2a2c_vect( u,g_u,v,g_v,ua,g_ua,va,g_va,uc,g_uc,vc,g_vc,ut,g_ut,vt,g_vt,dord4 )
do j = js-1, jep1
  do i = is-1, iep1+1
    g_ut(i,j) = g_ut(i,j)*dt2*dy(i,j)*sina_u(i,j)
    ut(i,j) = dt2*ut(i,j)*dy(i,j)*sina_u(i,j)
  end do
end do
do j = js-1, jep1+1
  do i = is-1, iep1
    g_vt(i,j) = g_vt(i,j)*dt2*dx(i,j)*sina_v(i,j)
    vt(i,j) = dt2*vt(i,j)*dx(i,j)*sina_v(i,j)
  end do
end do
if (grid_type .lt. 3) then
  call g_fill2_4corners( delp,g_delp,pt,g_pt,1 )
endif
if (hydrostatic) then
  do j = js-1, jep1
    do i = is-1, iep1+1
      if (ut(i,j) .gt. 0.) then
        g_fx1(i,j) = g_delp(i-1,j)
        fx1(i,j) = delp(i-1,j)
        g_fx(i,j) = g_pt(i-1,j)
        fx(i,j) = pt(i-1,j)
      else
        g_fx1(i,j) = g_delp(i,j)
        fx1(i,j) = delp(i,j)
        g_fx(i,j) = g_pt(i,j)
        fx(i,j) = pt(i,j)
      endif
      g_fx1(i,j) = g_fx1(i,j)*ut(i,j)+g_ut(i,j)*fx1(i,j)
      fx1(i,j) = ut(i,j)*fx1(i,j)
      g_fx(i,j) = g_fx(i,j)*fx1(i,j)+g_fx1(i,j)*fx(i,j)
      fx(i,j) = fx1(i,j)*fx(i,j)
    end do
  end do
else
  if (grid_type .lt. 3) then
    call g_fill_4corners( w,g_w,1 )
  endif
  do j = js-1, je+1
    do i = is-1, ie+2
      if (ut(i,j) .gt. 0.) then
        g_fx1(i,j) = g_delp(i-1,j)
        fx1(i,j) = delp(i-1,j)
        g_fx(i,j) = g_pt(i-1,j)
        fx(i,j) = pt(i-1,j)
        g_fx2(i,j) = g_w(i-1,j)
        fx2(i,j) = w(i-1,j)
      else
        g_fx1(i,j) = g_delp(i,j)
        fx1(i,j) = delp(i,j)
        g_fx(i,j) = g_pt(i,j)
        fx(i,j) = pt(i,j)
        g_fx2(i,j) = g_w(i,j)
        fx2(i,j) = w(i,j)
      endif
      g_fx1(i,j) = g_fx1(i,j)*ut(i,j)+g_ut(i,j)*fx1(i,j)
      fx1(i,j) = ut(i,j)*fx1(i,j)
      g_fx(i,j) = g_fx(i,j)*fx1(i,j)+g_fx1(i,j)*fx(i,j)
      fx(i,j) = fx1(i,j)*fx(i,j)
      g_fx2(i,j) = g_fx1(i,j)*fx2(i,j)+g_fx2(i,j)*fx1(i,j)
      fx2(i,j) = fx1(i,j)*fx2(i,j)
    end do
  end do
endif
if (grid_type .lt. 3) then
  call g_fill2_4corners( delp,g_delp,pt,g_pt,2 )
endif
if (hydrostatic) then
  do j = js-1, jep1+1
    do i = is-1, iep1
      if (vt(i,j) .gt. 0.) then
        g_fy1(i,j) = g_delp(i,j-1)
        fy1(i,j) = delp(i,j-1)
        g_fy(i,j) = g_pt(i,j-1)
        fy(i,j) = pt(i,j-1)
      else
        g_fy1(i,j) = g_delp(i,j)
        fy1(i,j) = delp(i,j)
        g_fy(i,j) = g_pt(i,j)
        fy(i,j) = pt(i,j)
      endif
      g_fy1(i,j) = g_fy1(i,j)*vt(i,j)+g_vt(i,j)*fy1(i,j)
      fy1(i,j) = vt(i,j)*fy1(i,j)
      g_fy(i,j) = g_fy(i,j)*fy1(i,j)+g_fy1(i,j)*fy(i,j)
      fy(i,j) = fy1(i,j)*fy(i,j)
    end do
  end do
  do j = js-1, jep1
    do i = is-1, iep1
      g_delpc(i,j) = g_delp(i,j)-g_fx1(i+1,j)*rarea(i,j)+g_fx1(i,j)*rarea(i,j)-g_fy1(i,j+1)*rarea(i,j)+g_fy1(i,j)*rarea(i,j)
      delpc(i,j) = delp(i,j)+(fx1(i,j)-fx1(i+1,j)+fy1(i,j)-fy1(i,j+1))*rarea(i,j)
      g_ptc(i,j) = g_delp(i,j)*(pt(i,j)/delpc(i,j))-g_delpc(i,j)*((pt(i,j)*delp(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,&
&j))/(delpc(i,j)*delpc(i,j)))-g_fx(i+1,j)*(rarea(i,j)/delpc(i,j))+g_fx(i,j)*(rarea(i,j)/delpc(i,j))-g_fy(i,j+1)*(rarea(i,j)/&
&delpc(i,j))+g_fy(i,j)*(rarea(i,j)/delpc(i,j))+g_pt(i,j)*(delp(i,j)/delpc(i,j))
      ptc(i,j) = (pt(i,j)*delp(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/delpc(i,j)
    end do
  end do
else
  if (grid_type .lt. 3) then
    call g_fill_4corners( w,g_w,2 )
  endif
  do j = js-1, je+2
    do i = is-1, ie+1
      if (vt(i,j) .gt. 0.) then
        g_fy1(i,j) = g_delp(i,j-1)
        fy1(i,j) = delp(i,j-1)
        g_fy(i,j) = g_pt(i,j-1)
        fy(i,j) = pt(i,j-1)
        g_fy2(i,j) = g_w(i,j-1)
        fy2(i,j) = w(i,j-1)
      else
        g_fy1(i,j) = g_delp(i,j)
        fy1(i,j) = delp(i,j)
        g_fy(i,j) = g_pt(i,j)
        fy(i,j) = pt(i,j)
        g_fy2(i,j) = g_w(i,j)
        fy2(i,j) = w(i,j)
      endif
      g_fy1(i,j) = g_fy1(i,j)*vt(i,j)+g_vt(i,j)*fy1(i,j)
      fy1(i,j) = vt(i,j)*fy1(i,j)
      g_fy(i,j) = g_fy(i,j)*fy1(i,j)+g_fy1(i,j)*fy(i,j)
      fy(i,j) = fy1(i,j)*fy(i,j)
      g_fy2(i,j) = g_fy1(i,j)*fy2(i,j)+g_fy2(i,j)*fy1(i,j)
      fy2(i,j) = fy1(i,j)*fy2(i,j)
    end do
  end do
  do j = js-1, je+1
    do i = is-1, ie+1
      g_delpc(i,j) = g_delp(i,j)-g_fx1(i+1,j)*rarea(i,j)+g_fx1(i,j)*rarea(i,j)-g_fy1(i,j+1)*rarea(i,j)+g_fy1(i,j)*rarea(i,j)
      delpc(i,j) = delp(i,j)+(fx1(i,j)-fx1(i+1,j)+fy1(i,j)-fy1(i,j+1))*rarea(i,j)
      g_ptc(i,j) = g_delp(i,j)*(pt(i,j)/delpc(i,j))-g_delpc(i,j)*((pt(i,j)*delp(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,&
&j))/(delpc(i,j)*delpc(i,j)))-g_fx(i+1,j)*(rarea(i,j)/delpc(i,j))+g_fx(i,j)*(rarea(i,j)/delpc(i,j))-g_fy(i,j+1)*(rarea(i,j)/&
&delpc(i,j))+g_fy(i,j)*(rarea(i,j)/delpc(i,j))+g_pt(i,j)*(delp(i,j)/delpc(i,j))
      ptc(i,j) = (pt(i,j)*delp(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/delpc(i,j)
      g_wc(i,j) = g_delp(i,j)*(w(i,j)/delpc(i,j))-g_delpc(i,j)*((w(i,j)*delp(i,j)+(fx2(i,j)-fx2(i+1,j)+fy2(i,j)-fy2(i,j+1))*&
&rarea(i,j))/(delpc(i,j)*delpc(i,j)))-g_fx2(i+1,j)*(rarea(i,j)/delpc(i,j))+g_fx2(i,j)*(rarea(i,j)/delpc(i,j))-g_fy2(i,j+1)*&
&(rarea(i,j)/delpc(i,j))+g_fy2(i,j)*(rarea(i,j)/delpc(i,j))+g_w(i,j)*(delp(i,j)/delpc(i,j))
      wc(i,j) = (w(i,j)*delp(i,j)+(fx2(i,j)-fx2(i+1,j)+fy2(i,j)-fy2(i,j+1))*rarea(i,j))/delpc(i,j)
    end do
  end do
endif
do j = js-1, jep1
  do i = is-1, iep1
    if (ua(i,j) .gt. 0.) then
      if (i .eq. 1) then
        g_ke(1,j) = g_uc(1,j)*sina_u(1,j)+g_v(1,j)*cosa_u(1,j)
        ke(1,j) = uc(1,j)*sina_u(1,j)+v(1,j)*cosa_u(1,j)
      else if (i .eq. npx) then
        g_ke(i,j) = g_uc(npx,j)*sina_u(npx,j)-g_v(npx,j)*cosa_u(npx,j)
        ke(i,j) = uc(npx,j)*sina_u(npx,j)-v(npx,j)*cosa_u(npx,j)
      else
        g_ke(i,j) = g_uc(i,j)
        ke(i,j) = uc(i,j)
      endif
    else
      if (i .eq. 0) then
        g_ke(0,j) = g_uc(1,j)*sina_u(1,j)-g_v(1,j)*cosa_u(1,j)
        ke(0,j) = uc(1,j)*sina_u(1,j)-v(1,j)*cosa_u(1,j)
      else if (i .eq. npx-1) then
        g_ke(i,j) = g_uc(npx,j)*sina_u(npx,j)+g_v(npx,j)*cosa_u(npx,j)
        ke(i,j) = uc(npx,j)*sina_u(npx,j)+v(npx,j)*cosa_u(npx,j)
      else
        g_ke(i,j) = g_uc(i+1,j)
        ke(i,j) = uc(i+1,j)
      endif
    endif
  end do
end do
do j = js-1, jep1
  do i = is-1, iep1
    if (va(i,j) .gt. 0.) then
      if (j .eq. 1) then
        g_vort(i,1) = g_u(i,1)*cosa_v(i,1)+g_vc(i,1)*sina_v(i,1)
        vort(i,1) = vc(i,1)*sina_v(i,1)+u(i,1)*cosa_v(i,1)
      else if (j .eq. npy) then
        g_vort(i,j) = (-(g_u(i,npy)*cosa_v(i,npy)))+g_vc(i,npy)*sina_v(i,npy)
        vort(i,j) = vc(i,npy)*sina_v(i,npy)-u(i,npy)*cosa_v(i,npy)
      else
        g_vort(i,j) = g_vc(i,j)
        vort(i,j) = vc(i,j)
      endif
    else
      if (j .eq. 0) then
        g_vort(i,0) = (-(g_u(i,1)*cosa_v(i,1)))+g_vc(i,1)*sina_v(i,1)
        vort(i,0) = vc(i,1)*sina_v(i,1)-u(i,1)*cosa_v(i,1)
      else if (j .eq. npy-1) then
        g_vort(i,j) = g_u(i,npy)*cosa_v(i,npy)+g_vc(i,npy)*sina_v(i,npy)
        vort(i,j) = vc(i,npy)*sina_v(i,npy)+u(i,npy)*cosa_v(i,npy)
      else
        g_vort(i,j) = g_vc(i,j+1)
        vort(i,j) = vc(i,j+1)
      endif
    endif
  end do
end do
dt4 = 0.5*dt2
do j = js-1, jep1
  do i = is-1, iep1
    g_ke(i,j) = g_ke(i,j)*dt4*ua(i,j)+g_ua(i,j)*dt4*ke(i,j)+g_va(i,j)*dt4*vort(i,j)+g_vort(i,j)*dt4*va(i,j)
    ke(i,j) = dt4*(ua(i,j)*ke(i,j)+va(i,j)*vort(i,j))
  end do
end do
is2 = max(2,is)
ie1 = min(npx-1,ie+1)
do j = js-1, je+1
  do i = is2, ie1
    g_fx(i,j) = g_uc(i,j)*dxc(i,j)
    fx(i,j) = uc(i,j)*dxc(i,j)
  end do
  if (is .eq. 1) then
    g_fx(1,j) = g_uc(1,j)*sina_u(1,j)*dxc(1,j)
    fx(1,j) = uc(1,j)*sina_u(1,j)*dxc(1,j)
  endif
  if (ie+1 .eq. npx) then
    g_fx(npx,j) = g_uc(npx,j)*sina_u(npx,j)*dxc(npx,j)
    fx(npx,j) = uc(npx,j)*sina_u(npx,j)*dxc(npx,j)
  endif
end do
do j = js, je+1
  if (j .eq. 1 .or. j .eq. npy) then
    do i = is-1, ie+1
      g_fy(i,j) = g_vc(i,j)*sina_v(i,j)*dyc(i,j)
      fy(i,j) = vc(i,j)*sina_v(i,j)*dyc(i,j)
    end do
  else
    do i = is-1, ie+1
      g_fy(i,j) = g_vc(i,j)*dyc(i,j)
      fy(i,j) = vc(i,j)*dyc(i,j)
    end do
  endif
end do
do j = js, je+1
  do i = is, ie+1
    g_vort(i,j) = g_fx(i,j-1)-g_fx(i,j)-g_fy(i-1,j)+g_fy(i,j)
    vort(i,j) = fx(i,j-1)-fx(i,j)-fy(i-1,j)+fy(i,j)
  end do
end do
if (sw_corner) then
  g_vort(1,1) = g_fy(0,1)+g_vort(1,1)
  vort(1,1) = vort(1,1)+fy(0,1)
endif
if (se_corner) then
  g_vort(npx,1) = (-g_fy(npx,1))+g_vort(npx,1)
  vort(npx,1) = vort(npx,1)-fy(npx,1)
endif
if (ne_corner) then
  g_vort(npx,npy) = (-g_fy(npx,npy))+g_vort(npx,npy)
  vort(npx,npy) = vort(npx,npy)-fy(npx,npy)
endif
if (nw_corner) then
  g_vort(1,npy) = g_fy(0,npy)+g_vort(1,npy)
  vort(1,npy) = vort(1,npy)+fy(0,npy)
endif
do j = js, je+1
  do i = is, ie+1
    g_vort(i,j) = g_vort(i,j)*rarea_c(i,j)
    vort(i,j) = fc(i,j)+rarea_c(i,j)*vort(i,j)
  end do
end do
do j = js, je
  do i = is, iep1
    if (i .eq. 1 .or. i .eq. npx) then
      g_fy1(i,j) = g_v(i,j)*dt2*sina_u(i,j)
      fy1(i,j) = dt2*v(i,j)*sina_u(i,j)
    else
      g_fy1(i,j) = (-(g_uc(i,j)*(dt2*cosa_u(i,j)/sina_u(i,j))))+g_v(i,j)*(dt2/sina_u(i,j))
      fy1(i,j) = dt2*(v(i,j)-uc(i,j)*cosa_u(i,j))/sina_u(i,j)
    endif
    if (fy1(i,j) .gt. 0.) then
      g_fy(i,j) = g_vort(i,j)
      fy(i,j) = vort(i,j)
    else
      g_fy(i,j) = g_vort(i,j+1)
      fy(i,j) = vort(i,j+1)
    endif
  end do
end do
do j = js, jep1
  if (j .eq. 1 .or. j .eq. npy) then
    do i = is, ie
      g_fx1(i,j) = g_u(i,j)*dt2*sina_v(i,j)
      fx1(i,j) = dt2*u(i,j)*sina_v(i,j)
      if (fx1(i,j) .gt. 0.) then
        g_fx(i,j) = g_vort(i,j)
        fx(i,j) = vort(i,j)
      else
        g_fx(i,j) = g_vort(i+1,j)
        fx(i,j) = vort(i+1,j)
      endif
    end do
  else
    do i = is, ie
      g_fx1(i,j) = g_u(i,j)*(dt2/sina_v(i,j))-g_vc(i,j)*(dt2*cosa_v(i,j)/sina_v(i,j))
      fx1(i,j) = dt2*(u(i,j)-vc(i,j)*cosa_v(i,j))/sina_v(i,j)
      if (fx1(i,j) .gt. 0.) then
        g_fx(i,j) = g_vort(i,j)
        fx(i,j) = vort(i,j)
      else
        g_fx(i,j) = g_vort(i+1,j)
        fx(i,j) = vort(i+1,j)
      endif
    end do
  endif
end do
do j = js, je
  do i = is, iep1
    g_uc(i,j) = g_fy(i,j)*fy1(i,j)+g_fy1(i,j)*fy(i,j)+g_ke(i-1,j)*rdxc(i,j)-g_ke(i,j)*rdxc(i,j)+g_uc(i,j)
    uc(i,j) = uc(i,j)+fy1(i,j)*fy(i,j)+rdxc(i,j)*(ke(i-1,j)-ke(i,j))
  end do
end do
do j = js, jep1
  do i = is, ie
    g_vc(i,j) = (-(g_fx(i,j)*fx1(i,j)+g_fx1(i,j)*fx(i,j)))+g_ke(i,j-1)*rdyc(i,j)-g_ke(i,j)*rdyc(i,j)+g_vc(i,j)
    vc(i,j) = vc(i,j)-fx1(i,j)*fx(i,j)+rdyc(i,j)*(ke(i,j-1)-ke(i,j))
  end do
end do

end subroutine g_c_sw


subroutine g_d2a2c_vect( u, g_u, v, g_v, ua, g_ua, va, g_va, uc, g_uc, vc, g_vc, ut, g_ut, vt, g_vt, dord4 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: a1 = 0.5625
real, parameter :: a2 = -0.0625
real, parameter :: b1 = 7./12.
real, parameter :: b2 = -(1./12.)
real, parameter :: c1 = -0.125
real, parameter :: c2 = 0.75
real, parameter :: c3 = 0.375
real, parameter :: t12 = -(13./28.)
real, parameter :: t14 = 6./7.
real, parameter :: t15 = 3./28.

!==============================================
! declare arguments
!==============================================
logical, intent(in) :: dord4
real, intent(in) :: g_u(isd:ied,jsd:jed+1)
real, intent(out) :: g_ua(isd:ied,jsd:jed)
real, intent(out) :: g_uc(isd:ied+1,jsd:jed)
real, intent(out) :: g_ut(isd:ied,jsd:jed)
real, intent(in) :: g_v(isd:ied+1,jsd:jed)
real, intent(out) :: g_va(isd:ied,jsd:jed)
real, intent(out) :: g_vc(isd:ied,jsd:jed+1)
real, intent(out) :: g_vt(isd:ied,jsd:jed)
real, intent(in) :: u(isd:ied,jsd:jed+1)
real, intent(out) :: ua(isd:ied,jsd:jed)
real, intent(out) :: uc(isd:ied+1,jsd:jed)
real, intent(out) :: ut(isd:ied,jsd:jed)
real, intent(in) :: v(isd:ied+1,jsd:jed)
real, intent(out) :: va(isd:ied,jsd:jed)
real, intent(out) :: vc(isd:ied,jsd:jed+1)
real, intent(out) :: vt(isd:ied,jsd:jed)

!==============================================
! declare local variables
!==============================================
real :: g_utmp(isd:ied,jsd:jed)
real :: g_vtmp(isd:ied,jsd:jed)
integer :: i
integer :: id
integer :: ifirst
integer :: ilast
integer :: j
integer :: npt
real :: utmp(isd:ied,jsd:jed)
real :: vtmp(isd:ied,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (dord4) then
  id = 1
else
  id = 0
endif
if (grid_type .lt. 3) then
  npt = 4
else
  npt = -2
endif
do j = max(npt,js-1), min(npy-npt,je+1)
  do i = max(npt,isd), min(npx-npt,ied)
    g_utmp(i,j) = (g_u(i,j-1)+g_u(i,j+2))*a2+(g_u(i,j+1)+g_u(i,j))*a1
    utmp(i,j) = a2*(u(i,j-1)+u(i,j+2))+a1*(u(i,j)+u(i,j+1))
  end do
end do
do j = max(npt,jsd), min(npy-npt,jed)
  do i = max(npt,is-1), min(npx-npt,ie+1)
    g_vtmp(i,j) = (g_v(i-1,j)+g_v(i+2,j))*a2+(g_v(i+1,j)+g_v(i,j))*a1
    vtmp(i,j) = a2*(v(i-1,j)+v(i+2,j))+a1*(v(i,j)+v(i+1,j))
  end do
end do
if (grid_type .lt. 3) then
  if (js .eq. 1 .or. jsd .lt. npt) then
    do j = jsd, npt-1
      do i = isd, ied
        g_utmp(i,j) = 0.5*g_u(i,j+1)+0.5*g_u(i,j)
        utmp(i,j) = 0.5*(u(i,j)+u(i,j+1))
        g_vtmp(i,j) = 0.5*g_v(i+1,j)+0.5*g_v(i,j)
        vtmp(i,j) = 0.5*(v(i,j)+v(i+1,j))
      end do
    end do
  endif
  if (je+1 .eq. npy .or. jed .ge. npy-npt) then
    do j = npy-npt+1, jed
      do i = isd, ied
        g_utmp(i,j) = 0.5*g_u(i,j+1)+0.5*g_u(i,j)
        utmp(i,j) = 0.5*(u(i,j)+u(i,j+1))
        g_vtmp(i,j) = 0.5*g_v(i+1,j)+0.5*g_v(i,j)
        vtmp(i,j) = 0.5*(v(i,j)+v(i+1,j))
      end do
    end do
  endif
  if (is .eq. 1 .or. isd .lt. npt) then
    do j = max(npt,jsd), min(npy-npt,jed)
      do i = isd, npt-1
        g_utmp(i,j) = 0.5*g_u(i,j+1)+0.5*g_u(i,j)
        utmp(i,j) = 0.5*(u(i,j)+u(i,j+1))
        g_vtmp(i,j) = 0.5*g_v(i+1,j)+0.5*g_v(i,j)
        vtmp(i,j) = 0.5*(v(i,j)+v(i+1,j))
      end do
    end do
  endif
  if (ie+1 .eq. npx .or. ied .ge. npx-npt) then
    do j = max(npt,jsd), min(npy-npt,jed)
      do i = npx-npt+1, ied
        g_utmp(i,j) = 0.5*g_u(i,j+1)+0.5*g_u(i,j)
        utmp(i,j) = 0.5*(u(i,j)+u(i,j+1))
        g_vtmp(i,j) = 0.5*g_v(i+1,j)+0.5*g_v(i,j)
        vtmp(i,j) = 0.5*(v(i,j)+v(i+1,j))
      end do
    end do
  endif
endif
do j = js-1-id, je+1+id
  do i = is-1-id, ie+1+id
    g_ua(i,j) = g_utmp(i,j)*rsin2(i,j)-g_vtmp(i,j)*cosa_s(i,j)*rsin2(i,j)
    ua(i,j) = (utmp(i,j)-vtmp(i,j)*cosa_s(i,j))*rsin2(i,j)
    g_va(i,j) = (-(g_utmp(i,j)*cosa_s(i,j)*rsin2(i,j)))+g_vtmp(i,j)*rsin2(i,j)
    va(i,j) = (vtmp(i,j)-utmp(i,j)*cosa_s(i,j))*rsin2(i,j)
  end do
end do
if (sw_corner) then
  do i = -2, 0
    g_utmp(i,0) = -g_vtmp(0,1-i)
    utmp(i,0) = -vtmp(0,1-i)
  end do
endif
if (se_corner) then
  do i = 0, 2
    g_utmp(npx+i,0) = g_vtmp(npx,i+1)
    utmp(npx+i,0) = vtmp(npx,i+1)
  end do
endif
if (ne_corner) then
  do i = 0, 2
    g_utmp(npx+i,npy) = -g_vtmp(npx,je-i)
    utmp(npx+i,npy) = -vtmp(npx,je-i)
  end do
endif
if (nw_corner) then
  do i = -2, 0
    g_utmp(i,npy) = g_vtmp(0,je+i)
    utmp(i,npy) = vtmp(0,je+i)
  end do
endif
if (grid_type .lt. 3) then
  ifirst = max(3,is-1)
  ilast = min(npx-2,ie+2)
else
  ifirst = is-1
  ilast = ie+2
endif
do j = js-1, je+1
  do i = ifirst, ilast
    g_uc(i,j) = g_utmp(i-2,j)*a2+g_utmp(i-1,j)*a1+g_utmp(i+1,j)*a2+g_utmp(i,j)*a1
    uc(i,j) = a1*(utmp(i-1,j)+utmp(i,j))+a2*(utmp(i-2,j)+utmp(i+1,j))
    g_ut(i,j) = g_uc(i,j)*rsin_u(i,j)-g_v(i,j)*cosa_u(i,j)*rsin_u(i,j)
    ut(i,j) = (uc(i,j)-v(i,j)*cosa_u(i,j))*rsin_u(i,j)
  end do
end do
if (grid_type .lt. 3) then
  if (is .eq. 1) then
    do j = js-1, je+1
      g_uc(0,j) = g_utmp(-2,j)*c1+g_utmp(-1,j)*c2+g_utmp(0,j)*c3
      uc(0,j) = c1*utmp(-2,j)+c2*utmp(-1,j)+c3*utmp(0,j)
      g_uc(1,j) = g_utmp(-2,j)*t15*rsin_u(1,j)+g_utmp(-1,j)*t12*rsin_u(1,j)+g_utmp(3,j)*t15*rsin_u(1,j)+g_utmp(2,j)*t12*rsin_u(1,j)&
&+(g_utmp(1,j)+g_utmp(0,j))*t14*rsin_u(1,j)
      uc(1,j) = (t14*(utmp(0,j)+utmp(1,j))+t12*(utmp(-1,j)+utmp(2,j))+t15*(utmp(-2,j)+utmp(3,j)))*rsin_u(1,j)
      g_uc(2,j) = g_utmp(3,j)*c1+g_utmp(2,j)*c2+g_utmp(1,j)*c3
      uc(2,j) = c1*utmp(3,j)+c2*utmp(2,j)+c3*utmp(1,j)
      g_ut(0,j) = g_uc(0,j)*rsin_u(0,j)-g_v(0,j)*cosa_u(0,j)*rsin_u(0,j)
      ut(0,j) = (uc(0,j)-v(0,j)*cosa_u(0,j))*rsin_u(0,j)
      g_ut(1,j) = g_uc(1,j)*rsin_u(1,j)
      ut(1,j) = uc(1,j)*rsin_u(1,j)
      g_ut(2,j) = g_uc(2,j)*rsin_u(2,j)-g_v(2,j)*cosa_u(2,j)*rsin_u(2,j)
      ut(2,j) = (uc(2,j)-v(2,j)*cosa_u(2,j))*rsin_u(2,j)
    end do
  endif
  if (ie+1 .eq. npx) then
    do j = js-1, je+1
      g_uc(npx-1,j) = g_utmp(npx-3,j)*c1+g_utmp(npx-2,j)*c2+g_utmp(npx-1,j)*c3
      uc(npx-1,j) = c1*utmp(npx-3,j)+c2*utmp(npx-2,j)+c3*utmp(npx-1,j)
      g_uc(npx,j) = g_utmp(npx-3,j)*t15*rsin_u(npx,j)+g_utmp(npx-2,j)*t12*rsin_u(npx,j)+g_utmp(npx-1,j)*t14*rsin_u(npx,j)+&
&g_utmp(npx+2,j)*t15*rsin_u(npx,j)+g_utmp(npx+1,j)*t12*rsin_u(npx,j)+g_utmp(npx,j)*t14*rsin_u(npx,j)
      uc(npx,j) = (t14*(utmp(npx-1,j)+utmp(npx,j))+t12*(utmp(npx-2,j)+utmp(npx+1,j))+t15*(utmp(npx-3,j)+utmp(npx+2,j)))*rsin_u(npx,&
&j)
      g_uc(npx+1,j) = g_utmp(npx+2,j)*c1+g_utmp(npx+1,j)*c2+g_utmp(npx,j)*c3
      uc(npx+1,j) = c3*utmp(npx,j)+c2*utmp(npx+1,j)+c1*utmp(npx+2,j)
      g_ut(npx-1,j) = g_uc(npx-1,j)*rsin_u(npx-1,j)-g_v(npx-1,j)*cosa_u(npx-1,j)*rsin_u(npx-1,j)
      ut(npx-1,j) = (uc(npx-1,j)-v(npx-1,j)*cosa_u(npx-1,j))*rsin_u(npx-1,j)
      g_ut(npx,j) = g_uc(npx,j)*rsin_u(npx,j)
      ut(npx,j) = uc(npx,j)*rsin_u(npx,j)
      g_ut(npx+1,j) = g_uc(npx+1,j)*rsin_u(npx+1,j)-g_v(npx+1,j)*cosa_u(npx+1,j)*rsin_u(npx+1,j)
      ut(npx+1,j) = (uc(npx+1,j)-v(npx+1,j)*cosa_u(npx+1,j))*rsin_u(npx+1,j)
    end do
  endif
endif
if (sw_corner) then
  do j = -2, 0
    g_vtmp(0,j) = -g_utmp(1-j,0)
    vtmp(0,j) = -utmp(1-j,0)
  end do
endif
if (nw_corner) then
  do j = 0, 2
    g_vtmp(0,npy+j) = g_utmp(j+1,npy)
    vtmp(0,npy+j) = utmp(j+1,npy)
  end do
endif
if (se_corner) then
  do j = -2, 0
    g_vtmp(npx,j) = g_utmp(ie+j,0)
    vtmp(npx,j) = utmp(ie+j,0)
  end do
endif
if (ne_corner) then
  do j = 0, 2
    g_vtmp(npx,npy+j) = -g_utmp(ie-j,npy)
    vtmp(npx,npy+j) = -utmp(ie-j,npy)
  end do
endif
if (grid_type .lt. 3) then
  do j = js-1, je+2
    if (j .eq. 1) then
      do i = is-1, ie+1
        g_vc(i,1) = g_vtmp(i,-2)*t15*rsin_v(i,1)+g_vtmp(i,-1)*t12*rsin_v(i,1)+g_vtmp(i,3)*t15*rsin_v(i,1)+g_vtmp(i,2)*t12*rsin_v(i,&
&1)+(g_vtmp(i,1)+g_vtmp(i,0))*t14*rsin_v(i,1)
        vc(i,1) = (t14*(vtmp(i,0)+vtmp(i,1))+t12*(vtmp(i,-1)+vtmp(i,2))+t15*(vtmp(i,-2)+vtmp(i,3)))*rsin_v(i,1)
        g_vt(i,1) = g_vc(i,1)*rsin_v(i,1)
        vt(i,1) = vc(i,1)*rsin_v(i,1)
      end do
    else if (j .eq. 0 .or. j .eq. npy-1) then
      do i = is-1, ie+1
        g_vc(i,j) = g_vtmp(i,j-2)*c1+g_vtmp(i,j-1)*c2+g_vtmp(i,j)*c3
        vc(i,j) = c1*vtmp(i,j-2)+c2*vtmp(i,j-1)+c3*vtmp(i,j)
        g_vt(i,j) = (-(g_u(i,j)*cosa_v(i,j)*rsin_v(i,j)))+g_vc(i,j)*rsin_v(i,j)
        vt(i,j) = (vc(i,j)-u(i,j)*cosa_v(i,j))*rsin_v(i,j)
      end do
    else if (j .eq. 2 .or. j .eq. npy+1) then
      do i = is-1, ie+1
        g_vc(i,j) = g_vtmp(i,j-1)*c3+g_vtmp(i,j+1)*c1+g_vtmp(i,j)*c2
        vc(i,j) = c1*vtmp(i,j+1)+c2*vtmp(i,j)+c3*vtmp(i,j-1)
        g_vt(i,j) = (-(g_u(i,j)*cosa_v(i,j)*rsin_v(i,j)))+g_vc(i,j)*rsin_v(i,j)
        vt(i,j) = (vc(i,j)-u(i,j)*cosa_v(i,j))*rsin_v(i,j)
      end do
    else if (j .eq. npy) then
      do i = is-1, ie+1
        g_vc(i,npy) = g_vtmp(i,npy-3)*t15*rsin_v(i,npy)+g_vtmp(i,npy-2)*t12*rsin_v(i,npy)+g_vtmp(i,npy-1)*t14*rsin_v(i,npy)+&
&g_vtmp(i,npy+2)*t15*rsin_v(i,npy)+g_vtmp(i,npy+1)*t12*rsin_v(i,npy)+g_vtmp(i,npy)*t14*rsin_v(i,npy)
        vc(i,npy) = (t14*(vtmp(i,npy-1)+vtmp(i,npy))+t12*(vtmp(i,npy-2)+vtmp(i,npy+1))+t15*(vtmp(i,npy-3)+vtmp(i,npy+2)))*rsin_v(i,&
&npy)
        g_vt(i,npy) = g_vc(i,npy)*rsin_v(i,npy)
        vt(i,npy) = vc(i,npy)*rsin_v(i,npy)
      end do
    else
      do i = is-1, ie+1
        g_vc(i,j) = g_vtmp(i,j-2)*a2+g_vtmp(i,j-1)*a1+g_vtmp(i,j+1)*a2+g_vtmp(i,j)*a1
        vc(i,j) = a2*(vtmp(i,j-2)+vtmp(i,j+1))+a1*(vtmp(i,j-1)+vtmp(i,j))
        g_vt(i,j) = (-(g_u(i,j)*cosa_v(i,j)*rsin_v(i,j)))+g_vc(i,j)*rsin_v(i,j)
        vt(i,j) = (vc(i,j)-u(i,j)*cosa_v(i,j))*rsin_v(i,j)
      end do
    endif
  end do
else
  do j = js-1, je+2
    do i = is-1, ie+1
      g_vc(i,j) = g_vtmp(i,j-2)*b2+g_vtmp(i,j-1)*b1+g_vtmp(i,j+1)*b2+g_vtmp(i,j)*b1
      vc(i,j) = b2*(vtmp(i,j-2)+vtmp(i,j+1))+b1*(vtmp(i,j-1)+vtmp(i,j))
      g_vt(i,j) = g_vc(i,j)
      vt(i,j) = vc(i,j)
    end do
  end do
endif

end subroutine g_d2a2c_vect


subroutine g_d_sw( delpc, g_delpc, delp, g_delp, ptc, g_ptc, pt, g_pt, u, g_u, v, g_v, w, g_w, uc, g_uc, vc, g_vc, ua, g_ua, va, &
&g_va, divg_d, g_divg_d, xflux, g_xflux, yflux, g_yflux, cx, g_cx, cy, g_cy, crx_adv, g_crx_adv, cry_adv, g_cry_adv, xfx_adv, &
&g_xfx_adv, yfx_adv, g_yfx_adv, dt, hord_mt, hord_vt, hord_tm, dddmp, dddm4, hydrostatic, uniform_ppm, taf_rec_npz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_tp_core_mod, only : g_fv_tp_2d


!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r3 = 1./3.

!==============================================
! declare arguments
!==============================================
real, intent(out) :: crx_adv(is:ie+1,jsd:jed)
real, intent(out) :: cry_adv(isd:ied,js:je+1)
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(in) :: dddm4
real, intent(in) :: dddmp
real, intent(inout) :: delp(isd:ied,jsd:jed)
real, intent(out) :: delpc(isd:ied,jsd:jed)
real, intent(in) :: divg_d(isd:ied+1,jsd:jed+1)
real, intent(in) :: dt
real, intent(out) :: g_crx_adv(is:ie+1,jsd:jed)
real, intent(out) :: g_cry_adv(isd:ied,js:je+1)
real, intent(inout) :: g_cx(is:ie+1,jsd:jed)
real, intent(inout) :: g_cy(isd:ied,js:je+1)
real, intent(inout) :: g_delp(isd:ied,jsd:jed)
real, intent(out) :: g_delpc(isd:ied,jsd:jed)
real, intent(in) :: g_divg_d(isd:ied+1,jsd:jed+1)
real, intent(inout) :: g_pt(isd:ied,jsd:jed)
real, intent(out) :: g_ptc(isd:ied,jsd:jed)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1)
real, intent(inout) :: g_ua(isd:ied,jsd:jed)
real, intent(inout) :: g_uc(isd:ied+1,jsd:jed)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed)
real, intent(inout) :: g_va(isd:ied,jsd:jed)
real, intent(inout) :: g_vc(isd:ied,jsd:jed+1)
real, intent(inout) :: g_w(isd:ied,jsd:jed)
real, intent(inout) :: g_xflux(is:ie+1,js:je)
real, intent(out) :: g_xfx_adv(is:ie+1,jsd:jed)
real, intent(inout) :: g_yflux(is:ie,js:je+1)
real, intent(out) :: g_yfx_adv(isd:ied,js:je+1)
integer, intent(in) :: hord_mt
integer, intent(in) :: hord_tm
integer, intent(in) :: hord_vt
logical, intent(in) :: hydrostatic
real, intent(inout) :: pt(isd:ied,jsd:jed)
real, intent(out) :: ptc(isd:ied,jsd:jed)
integer :: taf_rec_npz
real, intent(inout) :: u(isd:ied,jsd:jed+1)
real, intent(inout) :: ua(isd:ied,jsd:jed)
real, intent(inout) :: uc(isd:ied+1,jsd:jed)
logical, intent(in) :: uniform_ppm
real, intent(inout) :: v(isd:ied+1,jsd:jed)
real, intent(inout) :: va(isd:ied,jsd:jed)
real, intent(inout) :: vc(isd:ied,jsd:jed+1)
real, intent(inout) :: w(isd:ied,jsd:jed)
real, intent(inout) :: xflux(is:ie+1,js:je)
real, intent(out) :: xfx_adv(is:ie+1,jsd:jed)
real, intent(inout) :: yflux(is:ie,js:je+1)
real, intent(out) :: yfx_adv(isd:ied,js:je+1)

!==============================================
! declare local variables
!==============================================
real :: damp
real :: damp4
real :: damp_divg
real :: dt4
real :: dt5
real :: dt6
real :: fx(is:ie+1,js:je)
real :: fx_kill(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
real :: fy_kill(is:ie,js:je+1)
real :: g_fx(is:ie+1,js:je)
real, allocatable :: g_fx_killh(:,:)
real, allocatable :: g_fx_killi(:,:)
real :: g_fy(is:ie,js:je+1)
real, allocatable :: g_fy_killh(:,:)
real, allocatable :: g_fy_killi(:,:)
real :: g_gy(is:ie,js:je+1)
real :: g_ke(isd:ied+1,jsd:jed+1)
real :: g_ke_ub(isd:ied+1,jsd:jed+1)
real :: g_ke_vb(isd:ied+1,jsd:jed+1)
real :: g_ra_x(is:ie,jsd:jed)
real :: g_ra_y(isd:ied,js:je)
real :: g_ub(is:ie+1,js:je+1)
real :: g_ut(is-1:ie+2,jsd:jed)
real :: g_vb(is:ie+1,js:je+1)
real :: g_vort(isd:ied,jsd:jed)
real :: g_vt(isd:ied,js-1:je+2)
real :: g_wk(isd:ied+1,jsd:jed+1)
real :: gy(is:ie,js:je+1)
integer :: i
integer :: ie1
integer :: is2
integer :: j
integer :: je1
integer :: js2
real :: ke(isd:ied+1,jsd:jed+1)
real :: ke_ub(isd:ied+1,jsd:jed+1)
real :: ke_vb(isd:ied+1,jsd:jed+1)
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: ub(is:ie+1,js:je+1)
real :: ut(is-1:ie+2,jsd:jed)
real :: vb(is:ie+1,js:je+1)
real :: vort(isd:ied,jsd:jed)
real :: vt(isd:ied,js-1:je+2)
real :: wk(isd:ied+1,jsd:jed+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
g_ub = 0.
ub = 0.
g_vb = 0.
vb = 0.
g_ut = 0.
ut = 0.
g_vt = 0.
vt = 0.
g_wk = 0.
wk = 0.
g_ke = 0.
ke = 0.
g_ke_ub = 0.
ke_ub = 0.
g_ke_vb = 0.
ke_vb = 0.
g_vort = 0.
vort = 0.
fx = 0.
fy = 0.
gy = 0.
g_ra_x = 0.
ra_x = 0.
g_ra_y = 0.
ra_y = 0.
fx_kill = 0.
fy_kill = 0.
if (grid_type .lt. 3) then
  do j = jsd, jed
    if (j .ne. 0 .and. j .ne. 1 .and. j .ne. npy-1 .and. j .ne. npy) then
      do i = is-1, ie+2
        g_ut(i,j) = g_uc(i,j)*rsin_u(i,j)-0.25*g_vc(i-1,j+1)*cosa_u(i,j)*rsin_u(i,j)-0.25*g_vc(i,j+1)*cosa_u(i,j)*rsin_u(i,j)-0.25*&
&g_vc(i-1,j)*cosa_u(i,j)*rsin_u(i,j)-0.25*g_vc(i,j)*cosa_u(i,j)*rsin_u(i,j)
        ut(i,j) = (uc(i,j)-0.25*cosa_u(i,j)*(vc(i-1,j)+vc(i,j)+vc(i-1,j+1)+vc(i,j+1)))*rsin_u(i,j)
      end do
    endif
  end do
  do j = js-1, je+2
    if (j .ne. 1 .and. j .ne. npy) then
      do i = isd, ied
        g_vt(i,j) = (-(0.25*g_uc(i+1,j-1)*cosa_v(i,j)*rsin_v(i,j)+0.25*g_uc(i,j-1)*cosa_v(i,j)*rsin_v(i,j)+0.25*g_uc(i+1,j)*&
&cosa_v(i,j)*rsin_v(i,j)+0.25*g_uc(i,j)*cosa_v(i,j)*rsin_v(i,j)))+g_vc(i,j)*rsin_v(i,j)
        vt(i,j) = (vc(i,j)-0.25*cosa_v(i,j)*(uc(i,j-1)+uc(i+1,j-1)+uc(i,j)+uc(i+1,j)))*rsin_v(i,j)
      end do
    endif
  end do
  if (is .eq. 1) then
    do j = jsd, jed
      g_ut(1,j) = g_uc(1,j)*rsin_u(1,j)
      ut(1,j) = uc(1,j)*rsin_u(1,j)
    end do
    do j = max(3,js), min(npy-2,je+1)
      g_vt(0,j) = 0.25*g_ut(1,j-1)*cosa_v(1,j)+0.25*g_ut(0,j-1)*cosa_v(1,j)+0.25*g_ut(1,j)*cosa_v(1,j)+0.25*g_ut(0,j)*cosa_v(1,j)+&
&g_vc(0,j)
      vt(0,j) = vc(0,j)+0.25*cosa_v(1,j)*(ut(0,j-1)+ut(1,j-1)+ut(0,j)+ut(1,j))
      g_vt(1,j) = (-(0.25*g_ut(2,j-1)*cosa_v(1,j)+0.25*g_ut(1,j-1)*cosa_v(1,j)+0.25*g_ut(2,j)*cosa_v(1,j)+0.25*g_ut(1,j)*cosa_v(1,&
&j)))+g_vc(1,j)
      vt(1,j) = vc(1,j)-0.25*cosa_v(1,j)*(ut(1,j-1)+ut(2,j-1)+ut(1,j)+ut(2,j))
    end do
  endif
  if (ie+1 .eq. npx) then
    do j = jsd, jed
      g_ut(npx,j) = g_uc(npx,j)*rsin_u(npx,j)
      ut(npx,j) = uc(npx,j)*rsin_u(npx,j)
    end do
    do j = max(3,js), min(npy-2,je+1)
      g_vt(npx-1,j) = (-(0.25*g_ut(npx-1,j-1)*cosa_v(npx-1,j)+0.25*g_ut(npx,j-1)*cosa_v(npx-1,j)+0.25*g_ut(npx-1,j)*cosa_v(npx-1,j)&
&+0.25*g_ut(npx,j)*cosa_v(npx-1,j)))+g_vc(npx-1,j)
      vt(npx-1,j) = vc(npx-1,j)-0.25*cosa_v(npx-1,j)*(ut(npx-1,j-1)+ut(npx,j-1)+ut(npx-1,j)+ut(npx,j))
      g_vt(npx,j) = 0.25*g_ut(npx+1,j-1)*cosa_v(npx-1,j)+0.25*g_ut(npx,j-1)*cosa_v(npx-1,j)+0.25*g_ut(npx+1,j)*cosa_v(npx-1,j)+&
&0.25*g_ut(npx,j)*cosa_v(npx-1,j)+g_vc(npx,j)
      vt(npx,j) = vc(npx,j)+0.25*cosa_v(npx-1,j)*(ut(npx,j-1)+ut(npx+1,j-1)+ut(npx,j)+ut(npx+1,j))
    end do
  endif
  if (js .eq. 1) then
    do i = isd, ied
      g_vt(i,1) = g_vc(i,1)*rsin_v(i,1)
      vt(i,1) = vc(i,1)*rsin_v(i,1)
    end do
    do i = max(3,is), min(npx-2,ie+1)
      g_ut(i,0) = g_uc(i,0)+0.25*g_vt(i-1,1)*cosa_u(i,1)+0.25*g_vt(i,1)*cosa_u(i,1)+0.25*g_vt(i-1,0)*cosa_u(i,1)+0.25*g_vt(i,0)*&
&cosa_u(i,1)
      ut(i,0) = uc(i,0)+0.25*cosa_u(i,1)*(vt(i-1,0)+vt(i,0)+vt(i-1,1)+vt(i,1))
      g_ut(i,1) = g_uc(i,1)-0.25*g_vt(i-1,2)*cosa_u(i,1)-0.25*g_vt(i,2)*cosa_u(i,1)-0.25*g_vt(i-1,1)*cosa_u(i,1)-0.25*g_vt(i,1)*&
&cosa_u(i,1)
      ut(i,1) = uc(i,1)-0.25*cosa_u(i,1)*(vt(i-1,1)+vt(i,1)+vt(i-1,2)+vt(i,2))
    end do
  endif
  if (je+1 .eq. npy) then
    do i = isd, ied
      g_vt(i,npy) = g_vc(i,npy)*rsin_v(i,npy)
      vt(i,npy) = vc(i,npy)*rsin_v(i,npy)
    end do
    do i = max(3,is), min(npx-2,ie+1)
      g_ut(i,npy-1) = g_uc(i,npy-1)-0.25*g_vt(i-1,npy-1)*cosa_u(i,npy-1)-0.25*g_vt(i,npy-1)*cosa_u(i,npy-1)-0.25*g_vt(i-1,npy)*&
&cosa_u(i,npy-1)-0.25*g_vt(i,npy)*cosa_u(i,npy-1)
      ut(i,npy-1) = uc(i,npy-1)-0.25*cosa_u(i,npy-1)*(vt(i-1,npy-1)+vt(i,npy-1)+vt(i-1,npy)+vt(i,npy))
      g_ut(i,npy) = g_uc(i,npy)+0.25*g_vt(i-1,npy+1)*cosa_u(i,npy-1)+0.25*g_vt(i,npy+1)*cosa_u(i,npy-1)+0.25*g_vt(i-1,npy)*&
&cosa_u(i,npy-1)+0.25*g_vt(i,npy)*cosa_u(i,npy-1)
      ut(i,npy) = uc(i,npy)+0.25*cosa_u(i,npy-1)*(vt(i-1,npy)+vt(i,npy)+vt(i-1,npy+1)+vt(i,npy+1))
    end do
  endif
  if (sw_corner) then
    damp = 1./(1.-0.0625*cosa_u(2,1)*cosa_v(1,2))
    g_ut(2,0) = g_uc(2,0)*damp+0.0625*g_ut(2,-1)*cosa_u(2,0)*cosa_v(1,0)*damp+0.0625*g_ut(1,-1)*cosa_u(2,0)*cosa_v(1,0)*damp+&
&0.0625*g_ut(1,0)*cosa_u(2,0)*cosa_v(1,0)*damp-0.25*g_vc(1,0)*cosa_u(2,0)*damp-0.25*g_vt(2,1)*cosa_u(2,0)*damp-0.25*g_vt(1,1)*&
&cosa_u(2,0)*damp-0.25*g_vt(2,0)*cosa_u(2,0)*damp
    ut(2,0) = (uc(2,0)-0.25*cosa_u(2,0)*(vt(1,1)+vt(2,1)+vt(2,0)+vc(1,0)-0.25*cosa_v(1,0)*(ut(1,0)+ut(1,-1)+ut(2,-1))))*damp
    g_ut(2,1) = g_uc(2,1)*damp+0.0625*g_ut(2,2)*cosa_u(2,1)*cosa_v(1,2)*damp+0.0625*g_ut(1,2)*cosa_u(2,1)*cosa_v(1,2)*damp+0.0625*&
&g_ut(1,1)*cosa_u(2,1)*cosa_v(1,2)*damp-0.25*g_vc(1,2)*cosa_u(2,1)*damp-0.25*g_vt(2,2)*cosa_u(2,1)*damp-0.25*g_vt(2,1)*&
&cosa_u(2,1)*damp-0.25*g_vt(1,1)*cosa_u(2,1)*damp
    ut(2,1) = (uc(2,1)-0.25*cosa_u(2,1)*(vt(1,1)+vt(2,1)+vt(2,2)+vc(1,2)-0.25*cosa_v(1,2)*(ut(1,1)+ut(1,2)+ut(2,2))))*damp
    g_vt(1,2) = (-(0.25*g_uc(2,1)*cosa_v(1,2)*damp+0.25*g_ut(2,2)*cosa_v(1,2)*damp+0.25*g_ut(1,2)*cosa_v(1,2)*damp+0.25*g_ut(1,1)*&
&cosa_v(1,2)*damp))+g_vc(1,2)*damp+0.0625*g_vt(2,2)*cosa_v(1,2)*cosa_u(2,1)*damp+0.0625*g_vt(2,1)*cosa_v(1,2)*cosa_u(2,1)*damp+&
&0.0625*g_vt(1,1)*cosa_v(1,2)*cosa_u(2,1)*damp
    vt(1,2) = (vc(1,2)-0.25*cosa_v(1,2)*(ut(1,1)+ut(1,2)+ut(2,2)+uc(2,1)-0.25*cosa_u(2,1)*(vt(1,1)+vt(2,1)+vt(2,2))))*damp
    g_vt(0,2) = (-(0.25*g_uc(0,1)*cosa_v(0,2)*damp+0.25*g_ut(1,2)*cosa_v(0,2)*damp+0.25*g_ut(0,2)*cosa_v(0,2)*damp+0.25*g_ut(1,1)*&
&cosa_v(0,2)*damp))+g_vc(0,2)*damp+0.0625*g_vt(-1,2)*cosa_v(0,2)*cosa_u(0,1)*damp+0.0625*g_vt(-1,1)*cosa_v(0,2)*cosa_u(0,1)*&
&damp+0.0625*g_vt(0,1)*cosa_v(0,2)*cosa_u(0,1)*damp
    vt(0,2) = (vc(0,2)-0.25*cosa_v(0,2)*(ut(1,1)+ut(1,2)+ut(0,2)+uc(0,1)-0.25*cosa_u(0,1)*(vt(0,1)+vt(-1,1)+vt(-1,2))))*damp
  endif
  if (se_corner) then
    damp = 1./(1.-0.0625*cosa_u(npx-1,1)*cosa_v(npx-1,2))
    g_ut(npx-1,0) = g_uc(npx-1,0)*damp+0.0625*g_ut(npx-1,-1)*cosa_u(npx-1,1)*cosa_v(npx-1,2)*damp+0.0625*g_ut(npx,-1)*cosa_u(npx-1,&
&1)*cosa_v(npx-1,2)*damp+0.0625*g_ut(npx,0)*cosa_u(npx-1,1)*cosa_v(npx-1,2)*damp+0.25*g_vc(npx-1,0)*cosa_u(npx-1,1)*damp+0.25*&
&g_vt(npx-2,1)*cosa_u(npx-1,1)*damp+0.25*g_vt(npx-1,1)*cosa_u(npx-1,1)*damp+0.25*g_vt(npx-2,0)*cosa_u(npx-1,1)*damp
    ut(npx-1,0) = (uc(npx-1,0)+0.25*cosa_u(npx-1,1)*(vt(npx-1,1)+vt(npx-2,1)+vt(npx-2,0)+vc(npx-1,0)+0.25*cosa_v(npx-1,2)*(ut(npx,&
&0)+ut(npx,-1)+ut(npx-1,-1))))*damp
    g_ut(npx-1,1) = g_uc(npx-1,1)*damp+0.0625*g_ut(npx-1,2)*cosa_u(npx-1,1)*cosa_v(npx-1,2)*damp+0.0625*g_ut(npx,2)*cosa_u(npx-1,1)&
&*cosa_v(npx-1,2)*damp+0.0625*g_ut(npx,1)*cosa_u(npx-1,1)*cosa_v(npx-1,2)*damp-0.25*g_vc(npx-1,2)*cosa_u(npx-1,1)*damp-0.25*&
&g_vt(npx-2,2)*cosa_u(npx-1,1)*damp-0.25*g_vt(npx-2,1)*cosa_u(npx-1,1)*damp-0.25*g_vt(npx-1,1)*cosa_u(npx-1,1)*damp
    ut(npx-1,1) = (uc(npx-1,1)-0.25*cosa_u(npx-1,1)*(vt(npx-1,1)+vt(npx-2,1)+vt(npx-2,2)+vc(npx-1,2)-0.25*cosa_v(npx-1,2)*(ut(npx,&
&1)+ut(npx,2)+ut(npx-1,2))))*damp
    g_vt(npx-1,2) = (-(0.25*g_uc(npx-1,1)*cosa_v(npx-1,2)*damp+0.25*g_ut(npx-1,2)*cosa_v(npx-1,2)*damp+0.25*g_ut(npx,2)*cosa_v(npx-&
&1,2)*damp+0.25*g_ut(npx,1)*cosa_v(npx-1,2)*damp))+g_vc(npx-1,2)*damp+0.0625*g_vt(npx-2,2)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*&
&damp+0.0625*g_vt(npx-2,1)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*damp+0.0625*g_vt(npx-1,1)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*damp
    vt(npx-1,2) = (vc(npx-1,2)-0.25*cosa_v(npx-1,2)*(ut(npx,1)+ut(npx,2)+ut(npx-1,2)+uc(npx-1,1)-0.25*cosa_u(npx-1,1)*(vt(npx-1,1)+&
&vt(npx-2,1)+vt(npx-2,2))))*damp
    g_vt(npx,2) = 0.25*g_uc(npx+1,1)*cosa_v(npx-1,2)*damp+0.25*g_ut(npx+1,2)*cosa_v(npx-1,2)*damp+0.25*g_ut(npx,2)*cosa_v(npx-1,2)*&
&damp+0.25*g_ut(npx,1)*cosa_v(npx-1,2)*damp+g_vc(npx,2)*damp+0.0625*g_vt(npx+1,2)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*damp+0.0625*&
&g_vt(npx+1,1)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*damp+0.0625*g_vt(npx,1)*cosa_v(npx-1,2)*cosa_u(npx-1,1)*damp
    vt(npx,2) = (vc(npx,2)+0.25*cosa_v(npx-1,2)*(ut(npx,1)+ut(npx,2)+ut(npx+1,2)+uc(npx+1,1)+0.25*cosa_u(npx-1,1)*(vt(npx,1)+&
&vt(npx+1,1)+vt(npx+1,2))))*damp
  endif
  if (ne_corner) then
    damp = 1./(1.-0.0625*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1))
    g_ut(npx-1,npy) = g_uc(npx-1,npy)*damp+0.0625*g_ut(npx-1,npy+1)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.0625*g_ut(npx,&
&npy+1)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.0625*g_ut(npx,npy)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.25*&
&g_vc(npx-1,npy+1)*cosa_u(npx-1,npy-1)*damp+0.25*g_vt(npx-2,npy+1)*cosa_u(npx-1,npy-1)*damp+0.25*g_vt(npx-2,npy)*cosa_u(npx-1,&
&npy-1)*damp+0.25*g_vt(npx-1,npy)*cosa_u(npx-1,npy-1)*damp
    ut(npx-1,npy) = (uc(npx-1,npy)+0.25*cosa_u(npx-1,npy-1)*(vt(npx-1,npy)+vt(npx-2,npy)+vt(npx-2,npy+1)+vc(npx-1,npy+1)+0.25*&
&cosa_v(npx-1,npy-1)*(ut(npx,npy)+ut(npx,npy+1)+ut(npx-1,npy+1))))*damp
    g_ut(npx-1,npy-1) = g_uc(npx-1,npy-1)*damp+0.0625*g_ut(npx-1,npy-2)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.0625*&
&g_ut(npx,npy-2)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.0625*g_ut(npx,npy-1)*cosa_u(npx-1,npy-1)*cosa_v(npx-1,npy-1)*&
&damp-0.25*g_vc(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp-0.25*g_vt(npx-2,npy-1)*cosa_u(npx-1,npy-1)*damp-0.25*g_vt(npx-2,npy)*&
&cosa_u(npx-1,npy-1)*damp-0.25*g_vt(npx-1,npy)*cosa_u(npx-1,npy-1)*damp
    ut(npx-1,npy-1) = (uc(npx-1,npy-1)-0.25*cosa_u(npx-1,npy-1)*(vt(npx-1,npy)+vt(npx-2,npy)+vt(npx-2,npy-1)+vc(npx-1,npy-1)-0.25*&
&cosa_v(npx-1,npy-1)*(ut(npx,npy-1)+ut(npx,npy-2)+ut(npx-1,npy-2))))*damp
    g_vt(npx-1,npy-1) = (-(0.25*g_uc(npx-1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.25*g_ut(npx-1,npy-2)*cosa_v(npx-1,npy-1)*damp+0.25*&
&g_ut(npx,npy-2)*cosa_v(npx-1,npy-1)*damp+0.25*g_ut(npx,npy-1)*cosa_v(npx-1,npy-1)*damp))+g_vc(npx-1,npy-1)*damp+0.0625*&
&g_vt(npx-2,npy-1)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp+0.0625*g_vt(npx-2,npy)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*&
&damp+0.0625*g_vt(npx-1,npy)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp
    vt(npx-1,npy-1) = (vc(npx-1,npy-1)-0.25*cosa_v(npx-1,npy-1)*(ut(npx,npy-1)+ut(npx,npy-2)+ut(npx-1,npy-2)+uc(npx-1,npy-1)-0.25*&
&cosa_u(npx-1,npy-1)*(vt(npx-1,npy)+vt(npx-2,npy)+vt(npx-2,npy-1))))*damp
    g_vt(npx,npy-1) = 0.25*g_uc(npx+1,npy-1)*cosa_v(npx-1,npy-1)*damp+0.25*g_ut(npx+1,npy-2)*cosa_v(npx-1,npy-1)*damp+0.25*&
&g_ut(npx,npy-2)*cosa_v(npx-1,npy-1)*damp+0.25*g_ut(npx,npy-1)*cosa_v(npx-1,npy-1)*damp+g_vc(npx,npy-1)*damp+0.0625*g_vt(npx+1,&
&npy-1)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp+0.0625*g_vt(npx+1,npy)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp+&
&0.0625*g_vt(npx,npy)*cosa_v(npx-1,npy-1)*cosa_u(npx-1,npy-1)*damp
    vt(npx,npy-1) = (vc(npx,npy-1)+0.25*cosa_v(npx-1,npy-1)*(ut(npx,npy-1)+ut(npx,npy-2)+ut(npx+1,npy-2)+uc(npx+1,npy-1)+0.25*&
&cosa_u(npx-1,npy-1)*(vt(npx,npy)+vt(npx+1,npy)+vt(npx+1,npy-1))))*damp
  endif
  if (nw_corner) then
    damp = 1./(1.-0.0625*cosa_u(2,npy-1)*cosa_v(1,npy-1))
    g_ut(2,npy) = g_uc(2,npy)*damp+0.0625*g_ut(2,npy+1)*cosa_u(2,npy-1)*cosa_v(1,npy-1)*damp+0.0625*g_ut(1,npy+1)*cosa_u(2,npy-1)*&
&cosa_v(1,npy-1)*damp+0.0625*g_ut(1,npy)*cosa_u(2,npy-1)*cosa_v(1,npy-1)*damp+0.25*g_vc(1,npy+1)*cosa_u(2,npy-1)*damp+0.25*&
&g_vt(2,npy+1)*cosa_u(2,npy-1)*damp+0.25*g_vt(2,npy)*cosa_u(2,npy-1)*damp+0.25*g_vt(1,npy)*cosa_u(2,npy-1)*damp
    ut(2,npy) = (uc(2,npy)+0.25*cosa_u(2,npy-1)*(vt(1,npy)+vt(2,npy)+vt(2,npy+1)+vc(1,npy+1)+0.25*cosa_v(1,npy-1)*(ut(1,npy)+ut(1,&
&npy+1)+ut(2,npy+1))))*damp
    g_ut(2,npy-1) = g_uc(2,npy-1)*damp+0.0625*g_ut(2,npy-2)*cosa_u(2,npy-1)*cosa_v(1,npy-1)*damp+0.0625*g_ut(1,npy-2)*cosa_u(2,npy-&
&1)*cosa_v(1,npy-1)*damp+0.0625*g_ut(1,npy-1)*cosa_u(2,npy-1)*cosa_v(1,npy-1)*damp-0.25*g_vc(1,npy-1)*cosa_u(2,npy-1)*damp-&
&0.25*g_vt(2,npy-1)*cosa_u(2,npy-1)*damp-0.25*g_vt(2,npy)*cosa_u(2,npy-1)*damp-0.25*g_vt(1,npy)*cosa_u(2,npy-1)*damp
    ut(2,npy-1) = (uc(2,npy-1)-0.25*cosa_u(2,npy-1)*(vt(1,npy)+vt(2,npy)+vt(2,npy-1)+vc(1,npy-1)-0.25*cosa_v(1,npy-1)*(ut(1,npy-1)+&
&ut(1,npy-2)+ut(2,npy-2))))*damp
    g_vt(1,npy-1) = (-(0.25*g_uc(2,npy-1)*cosa_v(1,npy-1)*damp+0.25*g_ut(2,npy-2)*cosa_v(1,npy-1)*damp+0.25*g_ut(1,npy-2)*cosa_v(1,&
&npy-1)*damp+0.25*g_ut(1,npy-1)*cosa_v(1,npy-1)*damp))+g_vc(1,npy-1)*damp+0.0625*g_vt(2,npy-1)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*&
&damp+0.0625*g_vt(2,npy)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*damp+0.0625*g_vt(1,npy)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*damp
    vt(1,npy-1) = (vc(1,npy-1)-0.25*cosa_v(1,npy-1)*(ut(1,npy-1)+ut(1,npy-2)+ut(2,npy-2)+uc(2,npy-1)-0.25*cosa_u(2,npy-1)*(vt(1,&
&npy)+vt(2,npy)+vt(2,npy-1))))*damp
    g_vt(0,npy-1) = 0.25*g_uc(0,npy-1)*cosa_v(1,npy-1)*damp+0.25*g_ut(1,npy-2)*cosa_v(1,npy-1)*damp+0.25*g_ut(0,npy-2)*cosa_v(1,&
&npy-1)*damp+0.25*g_ut(1,npy-1)*cosa_v(1,npy-1)*damp+g_vc(0,npy-1)*damp+0.0625*g_vt(-1,npy-1)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*&
&damp+0.0625*g_vt(-1,npy)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*damp+0.0625*g_vt(0,npy)*cosa_v(1,npy-1)*cosa_u(2,npy-1)*damp
    vt(0,npy-1) = (vc(0,npy-1)+0.25*cosa_v(1,npy-1)*(ut(1,npy-1)+ut(1,npy-2)+ut(0,npy-2)+uc(0,npy-1)+0.25*cosa_u(2,npy-1)*(vt(0,&
&npy)+vt(-1,npy)+vt(-1,npy-1))))*damp
  endif
else
  do j = jsd, jed
    do i = is-1, ie+2
      g_ut(i,j) = g_uc(i,j)
      ut(i,j) = uc(i,j)
    end do
  end do
  do j = js-1, je+2
    do i = isd, ied
      g_vt(i,j) = g_vc(i,j)
      vt(i,j) = vc(i,j)
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie+1
    g_xfx_adv(i,j) = g_ut(i,j)*dt
    xfx_adv(i,j) = dt*ut(i,j)
  end do
end do
do j = js, je+1
  do i = isd, ied
    g_yfx_adv(i,j) = g_vt(i,j)*dt
    yfx_adv(i,j) = dt*vt(i,j)
  end do
end do
do j = jsd, jed
  do i = is, ie+1
    if (xfx_adv(i,j) .gt. 0.) then
      g_crx_adv(i,j) = g_xfx_adv(i,j)*rdxa(i-1,j)
      crx_adv(i,j) = xfx_adv(i,j)*rdxa(i-1,j)
    else
      g_crx_adv(i,j) = g_xfx_adv(i,j)*rdxa(i,j)
      crx_adv(i,j) = xfx_adv(i,j)*rdxa(i,j)
    endif
  end do
end do
do j = jsd, jed
  do i = is, ie+1
    g_xfx_adv(i,j) = g_xfx_adv(i,j)*dy(i,j)*sina_u(i,j)
    xfx_adv(i,j) = dy(i,j)*xfx_adv(i,j)*sina_u(i,j)
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (yfx_adv(i,j) .gt. 0.) then
      g_cry_adv(i,j) = g_yfx_adv(i,j)*rdya(i,j-1)
      cry_adv(i,j) = yfx_adv(i,j)*rdya(i,j-1)
    else
      g_cry_adv(i,j) = g_yfx_adv(i,j)*rdya(i,j)
      cry_adv(i,j) = yfx_adv(i,j)*rdya(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    g_yfx_adv(i,j) = g_yfx_adv(i,j)*dx(i,j)*sina_v(i,j)
    yfx_adv(i,j) = dx(i,j)*yfx_adv(i,j)*sina_v(i,j)
  end do
end do
do j = jsd, jed
  do i = is, ie
    g_ra_x(i,j) = (-g_xfx_adv(i+1,j))+g_xfx_adv(i,j)
    ra_x(i,j) = area(i,j)+xfx_adv(i,j)-xfx_adv(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    g_ra_y(i,j) = (-g_yfx_adv(i,j+1))+g_yfx_adv(i,j)
    ra_y(i,j) = area(i,j)+yfx_adv(i,j)-yfx_adv(i,j+1)
  end do
end do
allocate( g_fy_killi(is:ie,js:je+1) )
allocate( g_fx_killi(is:ie+1,js:je) )
g_fx_killi = 0.
g_fy_killi = 0.
call g_fv_tp_2d( delp,g_delp,crx_adv,g_crx_adv,cry_adv,g_cry_adv,npx,npy,hord_tm,fx,g_fx,fy,g_fy,xfx_adv,g_xfx_adv,yfx_adv,&
&g_yfx_adv,area,ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,fx_kill,g_fx_killi,fy_kill,g_fy_killi, .false. ,taf_rec_npz )
deallocate( g_fx_killi )
deallocate( g_fy_killi )
do j = jsd, jed
  do i = is, ie+1
    g_cx(i,j) = g_crx_adv(i,j)+g_cx(i,j)
    cx(i,j) = cx(i,j)+crx_adv(i,j)
  end do
end do
do j = js, je
  do i = is, ie+1
    g_xflux(i,j) = g_fx(i,j)+g_xflux(i,j)
    xflux(i,j) = xflux(i,j)+fx(i,j)
  end do
end do
do j = js, je+1
  do i = isd, ied
    g_cy(i,j) = g_cry_adv(i,j)+g_cy(i,j)
    cy(i,j) = cy(i,j)+cry_adv(i,j)
  end do
  do i = is, ie
    g_yflux(i,j) = g_fy(i,j)+g_yflux(i,j)
    yflux(i,j) = yflux(i,j)+fy(i,j)
  end do
end do
if ( .not. hydrostatic) then
  call g_fv_tp_2d( w,g_w,crx_adv,g_crx_adv,cry_adv,g_cry_adv,npx,npy,hord_vt,ub,g_ub,gy,g_gy,xfx_adv,g_xfx_adv,yfx_adv,g_yfx_adv,&
&area,ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,fx,g_fx,fy,g_fy, .true. ,taf_rec_npz )
  do j = js, je
    do i = is, ie
      g_w(i,j) = g_delp(i,j)*w(i,j)-g_gy(i,j+1)*rarea(i,j)+g_gy(i,j)*rarea(i,j)-g_ub(i+1,j)*rarea(i,j)+g_ub(i,j)*rarea(i,j)+g_w(i,&
&j)*delp(i,j)
      w(i,j) = w(i,j)*delp(i,j)+(ub(i,j)-ub(i+1,j)+gy(i,j)-gy(i,j+1))*rarea(i,j)
    end do
  end do
endif
call g_fv_tp_2d( pt,g_pt,crx_adv,g_crx_adv,cry_adv,g_cry_adv,npx,npy,hord_tm,ub,g_ub,gy,g_gy,xfx_adv,g_xfx_adv,yfx_adv,g_yfx_adv,&
&area,ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,fx,g_fx,fy,g_fy, .true. ,taf_rec_npz )
do j = js, je
  do i = is, ie
    g_pt(i,j) = g_delp(i,j)*pt(i,j)-g_gy(i,j+1)*rarea(i,j)+g_gy(i,j)*rarea(i,j)+g_pt(i,j)*delp(i,j)-g_ub(i+1,j)*rarea(i,j)+g_ub(i,&
&j)*rarea(i,j)
    pt(i,j) = pt(i,j)*delp(i,j)+(ub(i,j)-ub(i+1,j)+gy(i,j)-gy(i,j+1))*rarea(i,j)
    g_delp(i,j) = g_delp(i,j)-g_fx(i+1,j)*rarea(i,j)+g_fx(i,j)*rarea(i,j)-g_fy(i,j+1)*rarea(i,j)+g_fy(i,j)*rarea(i,j)
    delp(i,j) = delp(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j)
    g_pt(i,j) = (-(g_delp(i,j)*(pt(i,j)/(delp(i,j)*delp(i,j)))))+g_pt(i,j)/delp(i,j)
    pt(i,j) = pt(i,j)/delp(i,j)
  end do
end do
if ( .not. hydrostatic) then
  do j = js, je
    do i = is, ie
      g_w(i,j) = (-(g_delp(i,j)*(w(i,j)/(delp(i,j)*delp(i,j)))))+g_w(i,j)/delp(i,j)
      w(i,j) = w(i,j)/delp(i,j)
    end do
  end do
endif
dt5 = 0.5*dt
dt4 = 0.25*dt
is2 = max(2,is)
ie1 = min(npx-1,ie+1)
js2 = max(2,js)
je1 = min(npy-1,je+1)
if (grid_type .lt. 3) then
  if (js .eq. 1) then
    do i = is, ie+1
      g_vb(i,1) = (g_vt(i-1,1)+g_vt(i,1))*dt5
      vb(i,1) = dt5*(vt(i-1,1)+vt(i,1))
    end do
  endif
  do j = js2, je1
    do i = is2, ie1
      g_vb(i,j) = (-((g_uc(i,j-1)+g_uc(i,j))*dt5*cosa(i,j)*rsina(i,j)))+(g_vc(i-1,j)+g_vc(i,j))*dt5*rsina(i,j)
      vb(i,j) = dt5*(vc(i-1,j)+vc(i,j)-(uc(i,j-1)+uc(i,j))*cosa(i,j))*rsina(i,j)
    end do
    if (is .eq. 1) then
      g_vb(1,j) = (-((g_vt(-1,j)+g_vt(2,j))*dt4))+3*g_vt(1,j)*dt4+3*g_vt(0,j)*dt4
      vb(1,j) = dt4*((-vt(-1,j))+3.*(vt(0,j)+vt(1,j))-vt(2,j))
    endif
    if (ie+1 .eq. npx) then
      g_vb(npx,j) = (-(g_vt(npx-2,j)*dt4))+3*g_vt(npx-1,j)*dt4-g_vt(npx+1,j)*dt4+3*g_vt(npx,j)*dt4
      vb(npx,j) = dt4*((-vt(npx-2,j))+3.*(vt(npx-1,j)+vt(npx,j))-vt(npx+1,j))
    endif
  end do
  if (je+1 .eq. npy) then
    do i = is, ie+1
      g_vb(i,npy) = (g_vt(i-1,npy)+g_vt(i,npy))*dt5
      vb(i,npy) = dt5*(vt(i-1,npy)+vt(i,npy))
    end do
  endif
else
  do j = js, je+1
    do i = is, ie+1
      g_vb(i,j) = (g_vc(i-1,j)+g_vc(i,j))*dt5
      vb(i,j) = dt5*(vc(i-1,j)+vc(i,j))
    end do
  end do
endif
call g_ytp_v( vb,g_vb,u,v,g_v,ub,g_ub,hord_mt )
do j = js, je+1
  do i = is, ie+1
    g_ke_ub(i,j) = 0.5*g_ub(i,j)*vb(i,j)+0.5*g_vb(i,j)*ub(i,j)
    ke_ub(i,j) = 0.5*vb(i,j)*ub(i,j)
  end do
end do
if (grid_type .lt. 3) then
  if (is .eq. 1) then
    do j = js, je+1
      g_ub(1,j) = (g_ut(1,j-1)+g_ut(1,j))*dt5
      ub(1,j) = dt5*(ut(1,j-1)+ut(1,j))
    end do
  endif
  do j = js, je+1
    if (j .eq. 1 .or. j .eq. npy) then
      do i = is2, ie1
        g_ub(i,j) = (-(g_ut(i,j-2)*dt4))+3*g_ut(i,j-1)*dt4-g_ut(i,j+1)*dt4+3*g_ut(i,j)*dt4
        ub(i,j) = dt4*((-ut(i,j-2))+3.*(ut(i,j-1)+ut(i,j))-ut(i,j+1))
      end do
    else
      do i = is2, ie1
        g_ub(i,j) = (g_uc(i,j-1)+g_uc(i,j))*dt5*rsina(i,j)-g_vc(i-1,j)*dt5*cosa(i,j)*rsina(i,j)-g_vc(i,j)*dt5*cosa(i,j)*rsina(i,j)
        ub(i,j) = dt5*(uc(i,j-1)+uc(i,j)-(vc(i-1,j)+vc(i,j))*cosa(i,j))*rsina(i,j)
      end do
    endif
  end do
  if (ie+1 .eq. npx) then
    do j = js, je+1
      g_ub(npx,j) = (g_ut(npx,j-1)+g_ut(npx,j))*dt5
      ub(npx,j) = dt5*(ut(npx,j-1)+ut(npx,j))
    end do
  endif
else
  do j = js, je+1
    do i = is, ie+1
      g_ub(i,j) = (g_uc(i,j-1)+g_uc(i,j))*dt5
      ub(i,j) = dt5*(uc(i,j-1)+uc(i,j))
    end do
  end do
endif
call g_xtp_u( ub,g_ub,u,g_u,v,vb,g_vb,hord_mt )
do j = js, je+1
  do i = is, ie+1
    g_ke_vb(i,j) = 0.5*g_ub(i,j)*vb(i,j)+0.5*g_vb(i,j)*ub(i,j)
    ke_vb(i,j) = 0.5*ub(i,j)*vb(i,j)
  end do
end do
do j = js, je+1
  do i = is, ie+1
    g_ke(i,j) = g_ke_ub(i,j)+g_ke_vb(i,j)
    ke(i,j) = ke_ub(i,j)+ke_vb(i,j)
  end do
end do
if (gnomonic_grid) then
  dt6 = dt/6.
  if (sw_corner) then
    g_ke(1,1) = g_u(1,1)*dt6*(ut(1,1)+ut(1,0))+g_u(0,1)*dt6*(ut(1,1)+vt(1,1))+g_ut(1,1)*dt6*(u(1,1)+u(0,1))+g_ut(1,0)*dt6*u(1,1)+&
&g_v(1,1)*dt6*(vt(1,1)+vt(0,1))+g_vt(1,1)*dt6*(v(1,1)+u(0,1))+g_vt(0,1)*dt6*v(1,1)
    ke(1,1) = dt6*((ut(1,1)+ut(1,0))*u(1,1)+(vt(1,1)+vt(0,1))*v(1,1)+(ut(1,1)+vt(1,1))*u(0,1))
  endif
  if (se_corner) then
    i = npx
    g_ke(i,1) = g_u(i-1,1)*dt6*(ut(i,1)+ut(i,0))+g_u(i,1)*dt6*(ut(i,1)-vt(i-1,1))+g_ut(i,1)*dt6*(u(i-1,1)+u(i,1))+g_ut(i,0)*dt6*&
&u(i-1,1)+g_v(i,1)*dt6*(vt(i,1)+vt(i-1,1))+g_vt(i-1,1)*dt6*(v(i,1)-u(i,1))+g_vt(i,1)*dt6*v(i,1)
    ke(i,1) = dt6*((ut(i,1)+ut(i,0))*u(i-1,1)+(vt(i,1)+vt(i-1,1))*v(i,1)+(ut(i,1)-vt(i-1,1))*u(i,1))
  endif
  if (ne_corner) then
    i = npx
    j = npy
    g_ke(i,j) = g_u(i-1,j)*dt6*(ut(i,j)+ut(i,j-1))+g_u(i,j)*dt6*(ut(i,j-1)+vt(i-1,j))+g_ut(i,j-1)*dt6*(u(i-1,j)+u(i,j))+g_ut(i,j)*&
&dt6*u(i-1,j)+g_v(i,j-1)*dt6*(vt(i,j)+vt(i-1,j))+g_vt(i-1,j)*dt6*(v(i,j-1)+u(i,j))+g_vt(i,j)*dt6*v(i,j-1)
    ke(i,j) = dt6*((ut(i,j)+ut(i,j-1))*u(i-1,j)+(vt(i,j)+vt(i-1,j))*v(i,j-1)+(ut(i,j-1)+vt(i-1,j))*u(i,j))
  endif
  if (nw_corner) then
    j = npy
    g_ke(1,j) = g_u(1,j)*dt6*(ut(1,j)+ut(1,j-1))+g_u(0,j)*dt6*(ut(1,j-1)-vt(1,j))+g_ut(1,j-1)*dt6*(u(1,j)+u(0,j))+g_ut(1,j)*dt6*&
&u(1,j)+g_v(1,j-1)*dt6*(vt(1,j)+vt(0,j))+g_vt(1,j)*dt6*(v(1,j-1)-u(0,j))+g_vt(0,j)*dt6*v(1,j-1)
    ke(1,j) = dt6*((ut(1,j)+ut(1,j-1))*u(1,j)+(vt(1,j)+vt(0,j))*v(1,j-1)+(ut(1,j-1)-vt(1,j))*u(0,j))
  endif
else if (grid_type .lt. 3) then
  call mp_corner_comm( ke,npx,npy )
  call mp_corner_comm( g_ke,npx,npy )
  if (sw_corner) then
    g_ke(1,1) = (g_ke(1,2)+g_ke(2,1)+g_ke(0,1))*r3
    ke(1,1) = r3*(ke(2,1)+ke(1,2)+ke(0,1))
  endif
  if (se_corner) then
    g_ke(npx,1) = (g_ke(npx,2)+g_ke(npx-1,1)+g_ke(npx+1,1))*r3
    ke(npx,1) = r3*(ke(npx+1,1)+ke(npx,2)+ke(npx-1,1))
  endif
  if (ne_corner) then
    g_ke(npx,npy) = (g_ke(npx,npy-1)+g_ke(npx-1,npy)+g_ke(npx+1,npy))*r3
    ke(npx,npy) = r3*(ke(npx+1,npy)+ke(npx,npy-1)+ke(npx-1,npy))
  endif
  if (nw_corner) then
    g_ke(1,npy) = (g_ke(1,npy-1)+g_ke(2,npy)+g_ke(0,npy))*r3
    ke(1,npy) = r3*(ke(2,npy)+ke(1,npy-1)+ke(0,npy))
  endif
endif
damp_divg = dddmp*da_min_c
if (dddm4 .gt. 0.) then
  do j = js-1, je+2
    do i = is-1, ie+2
      g_delpc(i,j) = g_divg_d(i,j)
      delpc(i,j) = divg_d(i,j)
      g_wk(i,j) = g_divg_d(i,j)
      wk(i,j) = divg_d(i,j)
    end do
  end do
  do j = js, je+1
    do i = is-1, ie+1
      g_ptc(i,j) = g_wk(i+1,j)*sina_v(i,j)*dyc(i,j)*rdx(i,j)-g_wk(i,j)*sina_v(i,j)*dyc(i,j)*rdx(i,j)
      ptc(i,j) = sina_v(i,j)*dyc(i,j)*(wk(i+1,j)-wk(i,j))*rdx(i,j)
    end do
  end do
  do j = js-1, je+1
    do i = is, ie+1
      g_vort(i,j) = g_wk(i,j+1)*sina_u(i,j)*dxc(i,j)*rdy(i,j)-g_wk(i,j)*sina_u(i,j)*dxc(i,j)*rdy(i,j)
      vort(i,j) = sina_u(i,j)*dxc(i,j)*(wk(i,j+1)-wk(i,j))*rdy(i,j)
    end do
  end do
  do j = js, je+1
    do i = is, ie+1
      g_wk(i,j) = g_ptc(i-1,j)-g_ptc(i,j)+g_vort(i,j-1)-g_vort(i,j)
      wk(i,j) = vort(i,j-1)-vort(i,j)+ptc(i-1,j)-ptc(i,j)
    end do
  end do
  if (sw_corner) then
    g_wk(1,1) = (-g_vort(1,0))+g_wk(1,1)
    wk(1,1) = wk(1,1)-vort(1,0)
  endif
  if (se_corner) then
    g_wk(npx,1) = (-g_vort(npx,0))+g_wk(npx,1)
    wk(npx,1) = wk(npx,1)-vort(npx,0)
  endif
  if (ne_corner) then
    g_wk(npx,npy) = g_vort(npx,npy)+g_wk(npx,npy)
    wk(npx,npy) = wk(npx,npy)+vort(npx,npy)
  endif
  if (nw_corner) then
    g_wk(1,npy) = g_vort(1,npy)+g_wk(1,npy)
    wk(1,npy) = wk(1,npy)+vort(1,npy)
  endif
  damp4 = (dddm4*da_min_c)**2
  do j = js, je+1
    do i = is, ie+1
      g_ke(i,j) = g_divg_d(i,j)*damp_divg+g_ke(i,j)+g_wk(i,j)*damp4*rarea_c(i,j)
      ke(i,j) = ke(i,j)+damp_divg*divg_d(i,j)+damp4*rarea_c(i,j)*wk(i,j)
    end do
  end do
else
  do j = js, je+1
    if (j .eq. 1 .or. j .eq. npy) then
      do i = is-1, ie+1
        g_ptc(i,j) = g_u(i,j)*dyc(i,j)*sina_v(i,j)
        ptc(i,j) = u(i,j)*dyc(i,j)*sina_v(i,j)
      end do
    else
      do i = is-1, ie+1
        g_ptc(i,j) = g_u(i,j)*dyc(i,j)*sina_v(i,j)-0.5*g_va(i,j-1)*cosa_v(i,j)*dyc(i,j)*sina_v(i,j)-0.5*g_va(i,j)*cosa_v(i,j)*&
&dyc(i,j)*sina_v(i,j)
        ptc(i,j) = (u(i,j)-0.5*(va(i,j-1)+va(i,j))*cosa_v(i,j))*dyc(i,j)*sina_v(i,j)
      end do
    endif
  end do
  do j = js-1, je+1
    do i = is2, ie1
      g_vort(i,j) = (-(0.5*g_ua(i-1,j)*cosa_u(i,j)*dxc(i,j)*sina_u(i,j)+0.5*g_ua(i,j)*cosa_u(i,j)*dxc(i,j)*sina_u(i,j)))+g_v(i,j)*&
&dxc(i,j)*sina_u(i,j)
      vort(i,j) = (v(i,j)-0.5*(ua(i-1,j)+ua(i,j))*cosa_u(i,j))*dxc(i,j)*sina_u(i,j)
    end do
    if (is .eq. 1) then
      g_vort(1,j) = g_v(1,j)*dxc(1,j)*sina_u(1,j)
      vort(1,j) = v(1,j)*dxc(1,j)*sina_u(1,j)
    endif
    if (ie+1 .eq. npx) then
      g_vort(npx,j) = g_v(npx,j)*dxc(npx,j)*sina_u(npx,j)
      vort(npx,j) = v(npx,j)*dxc(npx,j)*sina_u(npx,j)
    endif
  end do
  do j = js, je+1
    do i = is, ie+1
      g_delpc(i,j) = g_ptc(i-1,j)-g_ptc(i,j)+g_vort(i,j-1)-g_vort(i,j)
      delpc(i,j) = vort(i,j-1)-vort(i,j)+ptc(i-1,j)-ptc(i,j)
    end do
  end do
  if (sw_corner) then
    g_delpc(1,1) = g_delpc(1,1)-g_vort(1,0)
    delpc(1,1) = delpc(1,1)-vort(1,0)
  endif
  if (se_corner) then
    g_delpc(npx,1) = g_delpc(npx,1)-g_vort(npx,0)
    delpc(npx,1) = delpc(npx,1)-vort(npx,0)
  endif
  if (ne_corner) then
    g_delpc(npx,npy) = g_delpc(npx,npy)+g_vort(npx,npy)
    delpc(npx,npy) = delpc(npx,npy)+vort(npx,npy)
  endif
  if (nw_corner) then
    g_delpc(1,npy) = g_delpc(1,npy)+g_vort(1,npy)
    delpc(1,npy) = delpc(1,npy)+vort(1,npy)
  endif
  do j = js, je+1
    do i = is, ie+1
      g_delpc(i,j) = g_delpc(i,j)*rarea_c(i,j)
      delpc(i,j) = rarea_c(i,j)*delpc(i,j)
      g_ke(i,j) = g_delpc(i,j)*damp_divg+g_ke(i,j)
      ke(i,j) = ke(i,j)+damp_divg*delpc(i,j)
    end do
  end do
endif
do j = jsd, jed+1
  do i = isd, ied
    g_u(i,j) = g_u(i,j)*dx(i,j)
    u(i,j) = u(i,j)*dx(i,j)
  end do
end do
do j = jsd, jed
  do i = isd, ied+1
    g_v(i,j) = g_v(i,j)*dy(i,j)
    v(i,j) = v(i,j)*dy(i,j)
  end do
end do
do j = jsd, jed
  do i = isd, ied
    g_vort(i,j) = (-(g_u(i,j+1)*rarea(i,j)))+(g_u(i,j)+g_v(i+1,j))*rarea(i,j)-g_v(i,j)*rarea(i,j)
    vort(i,j) = f0(i,j)+rarea(i,j)*(u(i,j)-u(i,j+1)-v(i,j)+v(i+1,j))
  end do
end do
allocate( g_fy_killh(is:ie,js:je+1) )
allocate( g_fx_killh(is:ie+1,js:je) )
g_fx_killh = 0.
g_fy_killh = 0.
call g_fv_tp_2d( vort,g_vort,crx_adv,g_crx_adv,cry_adv,g_cry_adv,npx,npy,hord_vt,fx,g_fx,fy,g_fy,xfx_adv,g_xfx_adv,yfx_adv,&
&g_yfx_adv,area,ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,fx_kill,g_fx_killh,fy_kill,g_fy_killh, .false. ,taf_rec_npz )
deallocate( g_fx_killh )
deallocate( g_fy_killh )
do j = js, je+1
  do i = is, ie
    g_u(i,j) = g_fy(i,j)-g_ke(i+1,j)+g_ke(i,j)+g_u(i,j)
    u(i,j) = u(i,j)+ke(i,j)-ke(i+1,j)+fy(i,j)
  end do
end do
do j = js, je
  do i = is, ie+1
    g_v(i,j) = (-(g_fx(i,j)+g_ke(i,j+1)))+g_ke(i,j)+g_v(i,j)
    v(i,j) = v(i,j)+ke(i,j)-ke(i,j+1)-fx(i,j)
  end do
end do

end subroutine g_d_sw


subroutine g_divergence_corner( u, g_u, v, g_v, ua, g_ua, va, g_va, divg_d, g_divg_d, km )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: km
real, intent(out) :: divg_d(isd:ied+1,jsd:jed+1,km)
real, intent(out) :: g_divg_d(isd:ied+1,jsd:jed+1,km)
real, intent(in) :: g_u(isd:ied,jsd:jed+1,km)
real, intent(in) :: g_ua(isd:ied,jsd:jed,km)
real, intent(in) :: g_v(isd:ied+1,jsd:jed,km)
real, intent(in) :: g_va(isd:ied,jsd:jed,km)
real, intent(in) :: u(isd:ied,jsd:jed+1,km)
real, intent(in) :: ua(isd:ied,jsd:jed,km)
real, intent(in) :: v(isd:ied+1,jsd:jed,km)
real, intent(in) :: va(isd:ied,jsd:jed,km)

!==============================================
! declare local variables
!==============================================
real :: g_uf(is-2:ie+2,js-1:je+2)
real :: g_vf(is-1:ie+2,js-2:je+2)
integer :: i
integer :: ie1
integer :: is2
integer :: j
integer :: k
real :: uf(is-2:ie+2,js-1:je+2)
real :: vf(is-1:ie+2,js-2:je+2)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
g_uf = 0.
uf = 0.
g_vf = 0.
vf = 0.
is2 = max(2,is)
ie1 = min(npx-1,ie+1)
do k = 1, km
  if (grid_type .eq. 4) then
    do j = js-1, je+2
      do i = is-2, ie+2
        g_uf(i,j) = g_u(i,j,k)*dyc(i,j)
        uf(i,j) = u(i,j,k)*dyc(i,j)
      end do
    end do
    do j = js-2, je+2
      do i = is-1, ie+2
        g_vf(i,j) = g_v(i,j,k)*dxc(i,j)
        vf(i,j) = v(i,j,k)*dxc(i,j)
      end do
    end do
    do j = js-1, je+2
      do i = is-1, ie+2
        g_divg_d(i,j,k) = g_uf(i-1,j)*rarea_c(i,j)-g_uf(i,j)*rarea_c(i,j)+g_vf(i,j-1)*rarea_c(i,j)-g_vf(i,j)*rarea_c(i,j)
        divg_d(i,j,k) = rarea_c(i,j)*(vf(i,j-1)-vf(i,j)+uf(i-1,j)-uf(i,j))
      end do
    end do
  else
    do j = js, je+1
      if (j .eq. 1 .or. j .eq. npy) then
        do i = is-1, ie+1
          g_uf(i,j) = g_u(i,j,k)*dyc(i,j)*sina_v(i,j)
          uf(i,j) = u(i,j,k)*dyc(i,j)*sina_v(i,j)
        end do
      else
        do i = is-1, ie+1
          g_uf(i,j) = g_u(i,j,k)*dyc(i,j)*sina_v(i,j)-0.5*g_va(i,j-1,k)*cosa_v(i,j)*dyc(i,j)*sina_v(i,j)-0.5*g_va(i,j,k)*cosa_v(i,&
&j)*dyc(i,j)*sina_v(i,j)
          uf(i,j) = (u(i,j,k)-0.5*(va(i,j-1,k)+va(i,j,k))*cosa_v(i,j))*dyc(i,j)*sina_v(i,j)
        end do
      endif
    end do
    do j = js-1, je+1
      do i = is2, ie1
        g_vf(i,j) = (-(0.5*g_ua(i-1,j,k)*cosa_u(i,j)*dxc(i,j)*sina_u(i,j)+0.5*g_ua(i,j,k)*cosa_u(i,j)*dxc(i,j)*sina_u(i,j)))+g_v(i,&
&j,k)*dxc(i,j)*sina_u(i,j)
        vf(i,j) = (v(i,j,k)-0.5*(ua(i-1,j,k)+ua(i,j,k))*cosa_u(i,j))*dxc(i,j)*sina_u(i,j)
      end do
      if (is .eq. 1) then
        g_vf(1,j) = g_v(1,j,k)*dxc(1,j)*sina_u(1,j)
        vf(1,j) = v(1,j,k)*dxc(1,j)*sina_u(1,j)
      endif
      if (ie+1 .eq. npx) then
        g_vf(npx,j) = g_v(npx,j,k)*dxc(npx,j)*sina_u(npx,j)
        vf(npx,j) = v(npx,j,k)*dxc(npx,j)*sina_u(npx,j)
      endif
    end do
    do j = js, je+1
      do i = is, ie+1
        g_divg_d(i,j,k) = g_uf(i-1,j)-g_uf(i,j)+g_vf(i,j-1)-g_vf(i,j)
        divg_d(i,j,k) = vf(i,j-1)-vf(i,j)+uf(i-1,j)-uf(i,j)
      end do
    end do
    if (sw_corner) then
      g_divg_d(1,1,k) = g_divg_d(1,1,k)-g_vf(1,0)
      divg_d(1,1,k) = divg_d(1,1,k)-vf(1,0)
    endif
    if (se_corner) then
      g_divg_d(npx,1,k) = g_divg_d(npx,1,k)-g_vf(npx,0)
      divg_d(npx,1,k) = divg_d(npx,1,k)-vf(npx,0)
    endif
    if (ne_corner) then
      g_divg_d(npx,npy,k) = g_divg_d(npx,npy,k)+g_vf(npx,npy)
      divg_d(npx,npy,k) = divg_d(npx,npy,k)+vf(npx,npy)
    endif
    if (nw_corner) then
      g_divg_d(1,npy,k) = g_divg_d(1,npy,k)+g_vf(1,npy)
      divg_d(1,npy,k) = divg_d(1,npy,k)+vf(1,npy)
    endif
    do j = js, je+1
      do i = is, ie+1
        g_divg_d(i,j,k) = g_divg_d(i,j,k)*rarea_c(i,j)
        divg_d(i,j,k) = rarea_c(i,j)*divg_d(i,j,k)
      end do
    end do
  endif
end do

end subroutine g_divergence_corner


subroutine g_fill2_4corners( q1, g_q1, q2, g_q2, dir )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: dir
real, intent(inout) :: g_q1(isd:ied,jsd:jed)
real, intent(inout) :: g_q2(isd:ied,jsd:jed)
real, intent(inout) :: q1(isd:ied,jsd:jed)
real, intent(inout) :: q2(isd:ied,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (dir .eq. 1) then
  if (sw_corner) then
    g_q1(-1,0) = g_q1(0,2)
    q1(-1,0) = q1(0,2)
    g_q1(0,0) = g_q1(0,1)
    q1(0,0) = q1(0,1)
    g_q2(-1,0) = g_q2(0,2)
    q2(-1,0) = q2(0,2)
    g_q2(0,0) = g_q2(0,1)
    q2(0,0) = q2(0,1)
  endif
  if (se_corner) then
    g_q1(npx+1,0) = g_q1(npx,2)
    q1(npx+1,0) = q1(npx,2)
    g_q1(npx,0) = g_q1(npx,1)
    q1(npx,0) = q1(npx,1)
    g_q2(npx+1,0) = g_q2(npx,2)
    q2(npx+1,0) = q2(npx,2)
    g_q2(npx,0) = g_q2(npx,1)
    q2(npx,0) = q2(npx,1)
  endif
  if (nw_corner) then
    g_q1(0,npy) = g_q1(0,npy-1)
    q1(0,npy) = q1(0,npy-1)
    g_q1(-1,npy) = g_q1(0,npy-2)
    q1(-1,npy) = q1(0,npy-2)
    g_q2(0,npy) = g_q2(0,npy-1)
    q2(0,npy) = q2(0,npy-1)
    g_q2(-1,npy) = g_q2(0,npy-2)
    q2(-1,npy) = q2(0,npy-2)
  endif
  if (ne_corner) then
    g_q1(npx,npy) = g_q1(npx,npy-1)
    q1(npx,npy) = q1(npx,npy-1)
    g_q1(npx+1,npy) = g_q1(npx,npy-2)
    q1(npx+1,npy) = q1(npx,npy-2)
    g_q2(npx,npy) = g_q2(npx,npy-1)
    q2(npx,npy) = q2(npx,npy-1)
    g_q2(npx+1,npy) = g_q2(npx,npy-2)
    q2(npx+1,npy) = q2(npx,npy-2)
  endif
endif
if (dir .eq. 2) then
  if (sw_corner) then
    g_q1(0,0) = g_q1(1,0)
    q1(0,0) = q1(1,0)
    g_q1(0,-1) = g_q1(2,0)
    q1(0,-1) = q1(2,0)
    g_q2(0,0) = g_q2(1,0)
    q2(0,0) = q2(1,0)
    g_q2(0,-1) = g_q2(2,0)
    q2(0,-1) = q2(2,0)
  endif
  if (se_corner) then
    g_q1(npx,0) = g_q1(npx-1,0)
    q1(npx,0) = q1(npx-1,0)
    g_q1(npx,-1) = g_q1(npx-2,0)
    q1(npx,-1) = q1(npx-2,0)
    g_q2(npx,0) = g_q2(npx-1,0)
    q2(npx,0) = q2(npx-1,0)
    g_q2(npx,-1) = g_q2(npx-2,0)
    q2(npx,-1) = q2(npx-2,0)
  endif
  if (nw_corner) then
    g_q1(0,npy) = g_q1(1,npy)
    q1(0,npy) = q1(1,npy)
    g_q1(0,npy+1) = g_q1(2,npy)
    q1(0,npy+1) = q1(2,npy)
    g_q2(0,npy) = g_q2(1,npy)
    q2(0,npy) = q2(1,npy)
    g_q2(0,npy+1) = g_q2(2,npy)
    q2(0,npy+1) = q2(2,npy)
  endif
  if (ne_corner) then
    g_q1(npx,npy) = g_q1(npx-1,npy)
    q1(npx,npy) = q1(npx-1,npy)
    g_q1(npx,npy+1) = g_q1(npx-2,npy)
    q1(npx,npy+1) = q1(npx-2,npy)
    g_q2(npx,npy) = g_q2(npx-1,npy)
    q2(npx,npy) = q2(npx-1,npy)
    g_q2(npx,npy+1) = g_q2(npx-2,npy)
    q2(npx,npy+1) = q2(npx-2,npy)
  endif
endif

end subroutine g_fill2_4corners


subroutine g_fill_4corners( q, g_q, dir )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: dir
real, intent(inout) :: g_q(isd:ied,jsd:jed)
real, intent(inout) :: q(isd:ied,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (dir .eq. 1) then
  if (sw_corner) then
    g_q(-1,0) = g_q(0,2)
    q(-1,0) = q(0,2)
    g_q(0,0) = g_q(0,1)
    q(0,0) = q(0,1)
  endif
  if (se_corner) then
    g_q(npx+1,0) = g_q(npx,2)
    q(npx+1,0) = q(npx,2)
    g_q(npx,0) = g_q(npx,1)
    q(npx,0) = q(npx,1)
  endif
  if (nw_corner) then
    g_q(0,npy) = g_q(0,npy-1)
    q(0,npy) = q(0,npy-1)
    g_q(-1,npy) = g_q(0,npy-2)
    q(-1,npy) = q(0,npy-2)
  endif
  if (ne_corner) then
    g_q(npx,npy) = g_q(npx,npy-1)
    q(npx,npy) = q(npx,npy-1)
    g_q(npx+1,npy) = g_q(npx,npy-2)
    q(npx+1,npy) = q(npx,npy-2)
  endif
endif
if (dir .eq. 2) then
  if (sw_corner) then
    g_q(0,0) = g_q(1,0)
    q(0,0) = q(1,0)
    g_q(0,-1) = g_q(2,0)
    q(0,-1) = q(2,0)
  endif
  if (se_corner) then
    g_q(npx,0) = g_q(npx-1,0)
    q(npx,0) = q(npx-1,0)
    g_q(npx,-1) = g_q(npx-2,0)
    q(npx,-1) = q(npx-2,0)
  endif
  if (nw_corner) then
    g_q(0,npy) = g_q(1,npy)
    q(0,npy) = q(1,npy)
    g_q(0,npy+1) = g_q(2,npy)
    q(0,npy+1) = q(2,npy)
  endif
  if (ne_corner) then
    g_q(npx,npy) = g_q(npx-1,npy)
    q(npx,npy) = q(npx-1,npy)
    g_q(npx,npy+1) = g_q(npx-2,npy)
    q(npx,npy+1) = q(npx-2,npy)
  endif
endif

end subroutine g_fill_4corners


subroutine g_xtp_u( c, g_c, u, g_u, v, flux, g_flux, iord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_tp_core_mod, only : g_pert_ppm

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r3 = 1./3.
real, parameter :: s11 = 11./14.
real, parameter :: s14 = 4./7.
real, parameter :: s15 = 3./14.

!==============================================
! declare arguments
!==============================================
real, intent(in) :: c(is:ie+1,js:je+1)
real, intent(out) :: flux(is:ie+1,js:je+1)
real, intent(in) :: g_c(is:ie+1,js:je+1)
real, intent(out) :: g_flux(is:ie+1,js:je+1)
real, intent(in) :: g_u(isd:ied,jsd:jed+1)
integer, intent(in) :: iord
real, intent(in) :: u(isd:ied,jsd:jed+1)
real, intent(in) :: v(isd:ied+1,jsd:jed)

!==============================================
! declare local variables
!==============================================
real :: al(is-1:ie+2)
real :: bl(is-1:ie+1)
real :: blh
real :: bli
real :: blj
real :: blk
real :: bll
real :: blm
real :: bln
real :: blo
real :: blp
real :: blq
real :: br(is-1:ie+1)
real :: brh
real :: bri
real :: brj
real :: brk
real :: brl
real :: brm
real :: brn
real :: bro
real :: brp
real :: brq
real :: cfl
real :: dl
real :: dlh
real :: dli
real :: dlj
real :: dlk
real :: dm(is-2:ie+2)
real :: dmh
real :: dmi
real :: dmj
real :: dmk
real :: dml
real :: dmm
real :: dmn
real :: dmo
real :: dmp
real :: dmr
real :: dms
real :: dmu
real :: dmv
real :: dmw
real :: dq(is-3:ie+2)
real :: dr
real :: drh
real :: dri
real :: drj
real :: drk
real :: g_al(is-1:ie+2)
real :: g_bl(is-1:ie+1)
real :: g_blh
real :: g_bli
real :: g_blj
real :: g_blk
real :: g_bll
real :: g_blm
real :: g_bln
real :: g_blo
real :: g_blp
real :: g_blq
real :: g_br(is-1:ie+1)
real :: g_brh
real :: g_bri
real :: g_brj
real :: g_brk
real :: g_brl
real :: g_brm
real :: g_brn
real :: g_bro
real :: g_brp
real :: g_brq
real :: g_cfl
real :: g_dl
real :: g_dlh
real :: g_dli
real :: g_dlj
real :: g_dlk
real :: g_dm(is-2:ie+2)
real :: g_dmh
real :: g_dmi
real :: g_dmj
real :: g_dmk
real :: g_dml
real :: g_dmm
real :: g_dmn
real :: g_dmo
real :: g_dmp
real :: g_dmr
real :: g_dms
real :: g_dmu
real :: g_dmv
real :: g_dmw
real :: g_dq(is-3:ie+2)
real :: g_dr
real :: g_drh
real :: g_dri
real :: g_drj
real :: g_drk
real :: g_lac
real :: g_pmp
real :: g_xt
integer :: help_h
integer :: help_i
integer :: i
integer :: j
real :: lac
real :: pmp
real :: xt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (iord .eq. 1) then
  do j = js, je+1
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = g_u(i-1,j)
        flux(i,j) = u(i-1,j)
      else
        g_flux(i,j) = g_u(i,j)
        flux(i,j) = u(i,j)
      endif
    end do
  end do
else if (iord .le. 4) then
  do j = js, je+1
    do i = is-2, ie+2
      g_xt = (-0.25)*g_u(i-1,j)+0.25*g_u(i+1,j)
      xt = 0.25*(u(i+1,j)-u(i-1,j))
      g_dmj = g_xt*sign(1.,xt)
      dmj = abs(xt)
      g_dmm = g_u(i-1,j)*(0.5+sign(0.5,u(i-1,j)-u(i,j)))+g_u(i,j)*(0.5-sign(0.5,u(i-1,j)-u(i,j)))
      dmm = max(u(i-1,j),u(i,j))
      g_dmr = g_dmm*(0.5+sign(0.5,dmm-u(i+1,j)))+g_u(i+1,j)*(0.5-sign(0.5,dmm-u(i+1,j)))-g_u(i,j)
      dmr = max(dmm,u(i+1,j))-u(i,j)
      g_dms = g_u(i-1,j)*(0.5+sign(0.5,u(i,j)-u(i-1,j)))+g_u(i,j)*(0.5-sign(0.5,u(i,j)-u(i-1,j)))
      dms = min(u(i-1,j),u(i,j))
      g_dmu = (-(g_dms*(0.5+sign(0.5,u(i+1,j)-dms))+g_u(i+1,j)*(0.5-sign(0.5,u(i+1,j)-dms))))+g_u(i,j)
      dmu = u(i,j)-min(dms,u(i+1,j))
      g_dmv = g_dmj*(0.5+sign(0.5,dmr-dmj))+g_dmr*(0.5-sign(0.5,dmr-dmj))
      dmv = min(dmj,dmr)
      g_dmw = g_dmu*(0.5-sign(0.5,dmu-dmv))+g_dmv*(0.5+sign(0.5,dmu-dmv))
      dmw = min(dmv,dmu)
      g_dm(i) = g_dmw*sign(1.,dmw)*sign(1.,xt)
      dm(i) = sign(dmw,xt)
    end do
    if (j .eq. 1 .or. j .eq. npy) then
      if (is .eq. 1) then
        g_dm(1) = 0.
        dm(1) = 0.
      endif
      if (ie+1 .eq. npx) then
        g_dm(ie) = 0.
        dm(ie) = 0.
      endif
    endif
    do i = is-1, ie+2
      g_al(i) = g_dm(i-1)*r3-g_dm(i)*r3+0.5*g_u(i-1,j)+0.5*g_u(i,j)
      al(i) = 0.5*(u(i-1,j)+u(i,j))+r3*(dm(i-1)-dm(i))
    end do
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_xt = 2*g_dm(i-1)
        xt = 2.*dm(i-1)
        g_dlk = g_al(i-1)-g_u(i-1,j)
        dlk = al(i-1)-u(i-1,j)
        g_dlj = g_dlk*(0.5-sign(0.5,abs(dlk)-abs(xt)))*sign(1.,dlk)+g_xt*(0.5+sign(0.5,abs(dlk)-abs(xt)))*sign(1.,xt)
        dlj = min(abs(xt),abs(dlk))
        g_dl = g_dlj*sign(1.,dlj)*sign(1.,xt)
        dl = sign(dlj,xt)
        g_drk = g_al(i)-g_u(i-1,j)
        drk = al(i)-u(i-1,j)
        g_drj = g_drk*(0.5-sign(0.5,abs(drk)-abs(xt)))*sign(1.,drk)+g_xt*(0.5+sign(0.5,abs(drk)-abs(xt)))*sign(1.,xt)
        drj = min(abs(xt),abs(drk))
        g_dr = g_drj*sign(1.,drj)*sign(1.,xt)
        dr = sign(drj,xt)
        g_cfl = g_c(i,j)*rdx(i-1,j)
        cfl = c(i,j)*rdx(i-1,j)
        g_flux(i,j) = g_cfl*((1.-cfl)*(dl-dr)-(dr+cfl*(dl-dr)))+g_dl*(1.-cfl)*cfl+g_dr*(1.-cfl)*(1-cfl)+g_u(i-1,j)
        flux(i,j) = u(i-1,j)+(1.-cfl)*(dr+cfl*(dl-dr))
      else
        g_xt = 2*g_dm(i)
        xt = 2.*dm(i)
        g_dli = g_al(i)-g_u(i,j)
        dli = al(i)-u(i,j)
        g_dlh = g_dli*(0.5-sign(0.5,abs(dli)-abs(xt)))*sign(1.,dli)+g_xt*(0.5+sign(0.5,abs(dli)-abs(xt)))*sign(1.,xt)
        dlh = min(abs(xt),abs(dli))
        g_dl = g_dlh*sign(1.,dlh)*sign(1.,xt)
        dl = sign(dlh,xt)
        g_dri = g_al(i+1)-g_u(i,j)
        dri = al(i+1)-u(i,j)
        g_drh = g_dri*(0.5-sign(0.5,abs(dri)-abs(xt)))*sign(1.,dri)+g_xt*(0.5+sign(0.5,abs(dri)-abs(xt)))*sign(1.,xt)
        drh = min(abs(xt),abs(dri))
        g_dr = g_drh*sign(1.,drh)*sign(1.,xt)
        dr = sign(drh,xt)
        g_cfl = g_c(i,j)*rdx(i,j)
        cfl = c(i,j)*rdx(i,j)
        g_flux(i,j) = (-(g_cfl*((1.+cfl)*(dl-dr)+dl+cfl*(dl-dr))+g_dl*(1.+cfl)*(1+cfl)))+g_dr*(1.+cfl)*cfl+g_u(i,j)
        flux(i,j) = u(i,j)-(1.+cfl)*(dl+cfl*(dl-dr))
      endif
    end do
  end do
else
  do j = js, je+1
    do i = is-2, ie+2
      g_xt = (-0.25)*g_u(i-1,j)+0.25*g_u(i+1,j)
      xt = 0.25*(u(i+1,j)-u(i-1,j))
      g_dmh = g_xt*sign(1.,xt)
      dmh = abs(xt)
      g_dmi = g_u(i-1,j)*(0.5+sign(0.5,u(i-1,j)-u(i,j)))+g_u(i,j)*(0.5-sign(0.5,u(i-1,j)-u(i,j)))
      dmi = max(u(i-1,j),u(i,j))
      g_dmk = g_dmi*(0.5+sign(0.5,dmi-u(i+1,j)))+g_u(i+1,j)*(0.5-sign(0.5,dmi-u(i+1,j)))-g_u(i,j)
      dmk = max(dmi,u(i+1,j))-u(i,j)
      g_dml = g_u(i-1,j)*(0.5+sign(0.5,u(i,j)-u(i-1,j)))+g_u(i,j)*(0.5-sign(0.5,u(i,j)-u(i-1,j)))
      dml = min(u(i-1,j),u(i,j))
      g_dmn = (-(g_dml*(0.5+sign(0.5,u(i+1,j)-dml))+g_u(i+1,j)*(0.5-sign(0.5,u(i+1,j)-dml))))+g_u(i,j)
      dmn = u(i,j)-min(dml,u(i+1,j))
      g_dmo = g_dmh*(0.5+sign(0.5,dmk-dmh))+g_dmk*(0.5-sign(0.5,dmk-dmh))
      dmo = min(dmh,dmk)
      g_dmp = g_dmn*(0.5-sign(0.5,dmn-dmo))+g_dmo*(0.5+sign(0.5,dmn-dmo))
      dmp = min(dmo,dmn)
      g_dm(i) = g_dmp*sign(1.,dmp)*sign(1.,xt)
      dm(i) = sign(dmp,xt)
    end do
    do i = is-3, ie+2
      g_dq(i) = g_u(i+1,j)-g_u(i,j)
      dq(i) = u(i+1,j)-u(i,j)
    end do
    if (grid_type .lt. 3) then
      do i = max(3,is-1), min(npx-2,ie+2)
        g_al(i) = g_dm(i-1)*r3-g_dm(i)*r3+0.5*g_u(i-1,j)+0.5*g_u(i,j)
        al(i) = 0.5*(u(i-1,j)+u(i,j))+r3*(dm(i-1)-dm(i))
      end do
      if (iord .lt. 10) then
        do i = max(3,is-1), min(npx-3,ie+1)
          g_pmp = 2*g_dq(i-1)
          pmp = 2.*dq(i-1)
          g_lac = (-1.5)*g_dq(i-2)+g_pmp
          lac = pmp-1.5*dq(i-2)
          g_brm = g_pmp*(0.5-sign(0.5,0.-pmp))
          brm = max(0.,pmp)
          g_brn = g_brm*(0.5+sign(0.5,brm-lac))+g_lac*(0.5-sign(0.5,brm-lac))
          brn = max(brm,lac)
          g_brp = g_pmp*(0.5-sign(0.5,pmp-0.))
          brp = min(0.,pmp)
          g_brq = g_brp*(0.5+sign(0.5,lac-brp))+g_lac*(0.5-sign(0.5,lac-brp))
          brq = min(brp,lac)
          g_bro = g_al(i+1)*(0.5+sign(0.5,al(i+1)-u(i,j)-brq))+g_brq*(0.5-sign(0.5,al(i+1)-u(i,j)-brq))-g_u(i,j)*(0.5+sign(0.5,&
&al(i+1)-u(i,j)-brq))
          bro = max(al(i+1)-u(i,j),brq)
          g_br(i) = g_brn*(0.5+sign(0.5,bro-brn))+g_bro*(0.5-sign(0.5,bro-brn))
          br(i) = min(brn,bro)
          g_pmp = (-2)*g_dq(i)
          pmp = -(2.*dq(i))
          g_lac = 1.5*g_dq(i+1)+g_pmp
          lac = pmp+1.5*dq(i+1)
          g_blm = g_pmp*(0.5-sign(0.5,0.-pmp))
          blm = max(0.,pmp)
          g_bln = g_blm*(0.5+sign(0.5,blm-lac))+g_lac*(0.5-sign(0.5,blm-lac))
          bln = max(blm,lac)
          g_blp = g_pmp*(0.5-sign(0.5,pmp-0.))
          blp = min(0.,pmp)
          g_blq = g_blp*(0.5+sign(0.5,lac-blp))+g_lac*(0.5-sign(0.5,lac-blp))
          blq = min(blp,lac)
          g_blo = g_al(i)*(0.5+sign(0.5,al(i)-u(i,j)-blq))+g_blq*(0.5-sign(0.5,al(i)-u(i,j)-blq))-g_u(i,j)*(0.5+sign(0.5,al(i)-u(i,&
&j)-blq))
          blo = max(al(i)-u(i,j),blq)
          g_bl(i) = g_bln*(0.5+sign(0.5,blo-bln))+g_blo*(0.5-sign(0.5,blo-bln))
          bl(i) = min(bln,blo)
        end do
      else
        do i = max(3,is-1), min(npx-3,ie+1)
          g_bl(i) = g_al(i)-g_u(i,j)
          bl(i) = al(i)-u(i,j)
          g_br(i) = g_al(i+1)-g_u(i,j)
          br(i) = al(i+1)-u(i,j)
        end do
      endif
      if (is .eq. 1) then
        g_br(2) = g_al(3)-g_u(2,j)
        br(2) = al(3)-u(2,j)
        g_xt = (-(g_dm(2)*s14))+g_u(2,j)*s11+g_u(1,j)*s15
        xt = s15*u(1,j)+s11*u(2,j)-s14*dm(2)
        g_bl(2) = (-g_u(2,j))+g_xt
        bl(2) = xt-u(2,j)
        g_br(1) = (-g_u(1,j))+g_xt
        br(1) = xt-u(1,j)
        if (j .eq. 1 .or. j .eq. npy) then
          g_bl(0) = 0.
          bl(0) = 0.
          g_br(0) = 0.
          br(0) = 0.
          g_bl(1) = 0.
          bl(1) = 0.
          g_br(1) = 0.
          br(1) = 0.
        else
          g_bl(0) = g_dm(-1)*s14-g_dq(-1)*s11
          bl(0) = s14*dm(-1)-s11*dq(-1)
          g_xt = (-((g_u(-1,j)+g_u(2,j))*(0.5*dx(1,j)/(dx(1,j)+dx(2,j)))))+(g_u(1,j)+g_u(0,j))*(0.5*(2.*dx(1,j)+dx(2,j))/(dx(1,j)+&
&dx(2,j)))
          xt = 0.5*((2.*dx(1,j)+dx(2,j))*(u(0,j)+u(1,j))-dx(1,j)*(u(-1,j)+u(2,j)))/(dx(1,j)+dx(2,j))
          g_br(0) = (-g_u(0,j))+g_xt
          br(0) = xt-u(0,j)
          g_bl(1) = (-g_u(1,j))+g_xt
          bl(1) = xt-u(1,j)
        endif
        if (iord .lt. 10) then
          help_h = -1
          call g_pert_ppm( 1,u(2,j),g_u(2,j),bl(2),g_bl(2),br(2),g_br(2),help_h )
        endif
      endif
      if (ie+1 .eq. npx) then
        g_bl(npx-2) = g_al(npx-2)-g_u(npx-2,j)
        bl(npx-2) = al(npx-2)-u(npx-2,j)
        g_xt = g_dm(npx-2)*s14+g_u(npx-2,j)*s11+g_u(npx-1,j)*s15
        xt = s15*u(npx-1,j)+s11*u(npx-2,j)+s14*dm(npx-2)
        g_br(npx-2) = (-g_u(npx-2,j))+g_xt
        br(npx-2) = xt-u(npx-2,j)
        g_bl(npx-1) = (-g_u(npx-1,j))+g_xt
        bl(npx-1) = xt-u(npx-1,j)
        if (j .eq. 1 .or. j .eq. npy) then
          g_bl(npx-1) = 0.
          bl(npx-1) = 0.
          g_br(npx-1) = 0.
          br(npx-1) = 0.
          g_bl(npx) = 0.
          bl(npx) = 0.
          g_br(npx) = 0.
          br(npx) = 0.
        else
          g_br(npx) = (-(g_dm(npx+1)*s14))+g_dq(npx)*s11
          br(npx) = s11*dq(npx)-s14*dm(npx+1)
          g_xt = (-(g_u(npx-2,j)*(0.5*dx(npx-1,j)/(dx(npx-1,j)+dx(npx-2,j)))))+g_u(npx-1,j)*(0.5*(2.*dx(npx-1,j)+dx(npx-2,j))/&
&(dx(npx-1,j)+dx(npx-2,j)))-g_u(npx+1,j)*(0.5*dx(npx-1,j)/(dx(npx-1,j)+dx(npx-2,j)))+g_u(npx,j)*(0.5*(2.*dx(npx-1,j)+&
&dx(npx-2,j))/(dx(npx-1,j)+dx(npx-2,j)))
          xt = 0.5*((2.*dx(npx-1,j)+dx(npx-2,j))*(u(npx-1,j)+u(npx,j))-dx(npx-1,j)*(u(npx-2,j)+u(npx+1,j)))/(dx(npx-1,j)+dx(npx-2,&
&j))
          g_br(npx-1) = (-g_u(npx-1,j))+g_xt
          br(npx-1) = xt-u(npx-1,j)
          g_bl(npx) = (-g_u(npx,j))+g_xt
          bl(npx) = xt-u(npx,j)
        endif
        if (iord .lt. 10) then
          help_i = -1
          call g_pert_ppm( 1,u(npx-2,j),g_u(npx-2,j),bl(npx-2),g_bl(npx-2),br(npx-2),g_br(npx-2),help_i )
        endif
      endif
    else
      do i = is-1, ie+2
        g_al(i) = g_dm(i-1)*r3-g_dm(i)*r3+0.5*g_u(i-1,j)+0.5*g_u(i,j)
        al(i) = 0.5*(u(i-1,j)+u(i,j))+r3*(dm(i-1)-dm(i))
      end do
      do i = is-1, ie+1
        g_pmp = (-2)*g_dq(i)
        pmp = -(2.*dq(i))
        g_lac = 1.5*g_dq(i+1)+g_pmp
        lac = pmp+1.5*dq(i+1)
        g_blh = g_pmp*(0.5-sign(0.5,0.-pmp))
        blh = max(0.,pmp)
        g_bli = g_blh*(0.5+sign(0.5,blh-lac))+g_lac*(0.5-sign(0.5,blh-lac))
        bli = max(blh,lac)
        g_blk = g_pmp*(0.5-sign(0.5,pmp-0.))
        blk = min(0.,pmp)
        g_bll = g_blk*(0.5+sign(0.5,lac-blk))+g_lac*(0.5-sign(0.5,lac-blk))
        bll = min(blk,lac)
        g_blj = g_al(i)*(0.5+sign(0.5,al(i)-u(i,j)-bll))+g_bll*(0.5-sign(0.5,al(i)-u(i,j)-bll))-g_u(i,j)*(0.5+sign(0.5,al(i)-u(i,j)&
&-bll))
        blj = max(al(i)-u(i,j),bll)
        g_bl(i) = g_bli*(0.5+sign(0.5,blj-bli))+g_blj*(0.5-sign(0.5,blj-bli))
        bl(i) = min(bli,blj)
        g_pmp = 2*g_dq(i-1)
        pmp = 2.*dq(i-1)
        g_lac = (-1.5)*g_dq(i-2)+g_pmp
        lac = pmp-1.5*dq(i-2)
        g_brh = g_pmp*(0.5-sign(0.5,0.-pmp))
        brh = max(0.,pmp)
        g_bri = g_brh*(0.5+sign(0.5,brh-lac))+g_lac*(0.5-sign(0.5,brh-lac))
        bri = max(brh,lac)
        g_brk = g_pmp*(0.5-sign(0.5,pmp-0.))
        brk = min(0.,pmp)
        g_brl = g_brk*(0.5+sign(0.5,lac-brk))+g_lac*(0.5-sign(0.5,lac-brk))
        brl = min(brk,lac)
        g_brj = g_al(i+1)*(0.5+sign(0.5,al(i+1)-u(i,j)-brl))+g_brl*(0.5-sign(0.5,al(i+1)-u(i,j)-brl))-g_u(i,j)*(0.5+sign(0.5,al(i+&
&1)-u(i,j)-brl))
        brj = max(al(i+1)-u(i,j),brl)
        g_br(i) = g_bri*(0.5+sign(0.5,brj-bri))+g_brj*(0.5-sign(0.5,brj-bri))
        br(i) = min(bri,brj)
      end do
    endif
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_cfl = g_c(i,j)*rdx(i-1,j)
        cfl = c(i,j)*rdx(i-1,j)
        g_flux(i,j) = (-(g_bl(i-1)*(1.-cfl)*cfl))+g_br(i-1)*(1.-cfl)*(1-cfl)-g_cfl*((1.-cfl)*(bl(i-1)+br(i-1))+br(i-1)-cfl*(bl(i-1)&
&+br(i-1)))+g_u(i-1,j)
        flux(i,j) = u(i-1,j)+(1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i-1)))
      else
        g_cfl = g_c(i,j)*rdx(i,j)
        cfl = c(i,j)*rdx(i,j)
        g_flux(i,j) = g_bl(i)*(1.+cfl)*(1+cfl)+g_br(i)*(1.+cfl)*cfl+g_cfl*((1.+cfl)*(bl(i)+br(i))+bl(i)+cfl*(bl(i)+br(i)))+g_u(i,j)
        flux(i,j) = u(i,j)+(1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
      endif
    end do
  end do
endif

end subroutine g_xtp_u


subroutine g_ytp_v( c, g_c, u, v, g_v, flux, g_flux, jord )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r3 = 1./3.
real, parameter :: s11 = 11./14.
real, parameter :: s14 = 4./7.
real, parameter :: s15 = 3./14.

!==============================================
! declare arguments
!==============================================
real, intent(in) :: c(is:ie+1,js:je+1)
real, intent(out) :: flux(is:ie+1,js:je+1)
real, intent(in) :: g_c(is:ie+1,js:je+1)
real, intent(out) :: g_flux(is:ie+1,js:je+1)
real, intent(in) :: g_v(isd:ied+1,jsd:jed)
integer, intent(in) :: jord
real, intent(in) :: u(isd:ied,jsd:jed+1)
real, intent(in) :: v(isd:ied+1,jsd:jed)

!==============================================
! declare local variables
!==============================================
real :: a6da
real :: al(is:ie+1,js-1:je+2)
real :: bl(is:ie+1,js-1:je+1)
real :: blh
real :: bli
real :: blj
real :: blk
real :: bll
real :: blm
real :: bln
real :: blo
real :: blp
real :: blq
real :: br(is:ie+1,js-1:je+1)
real :: brh
real :: bri
real :: brj
real :: brk
real :: brl
real :: brm
real :: brn
real :: bro
real :: brp
real :: brq
real :: cfl
real :: da1
real :: da2
real :: dl
real :: dlh
real :: dli
real :: dlj
real :: dlk
real :: dm(is:ie+1,js-2:je+2)
real :: dmh
real :: dmi
real :: dmj
real :: dmk
real :: dml
real :: dmm
real :: dmn
real :: dmo
real :: dmp
real :: dmr
real :: dms
real :: dmu
real :: dmv
real :: dmw
real :: dq(is:ie+1,js-3:je+2)
real :: dr
real :: drh
real :: dri
real :: drj
real :: drk
real :: g_a6da
real :: g_al(is:ie+1,js-1:je+2)
real :: g_bl(is:ie+1,js-1:je+1)
real :: g_blh
real :: g_bli
real :: g_blj
real :: g_blk
real :: g_bll
real :: g_blm
real :: g_bln
real :: g_blo
real :: g_blp
real :: g_blq
real :: g_br(is:ie+1,js-1:je+1)
real :: g_brh
real :: g_bri
real :: g_brj
real :: g_brk
real :: g_brl
real :: g_brm
real :: g_brn
real :: g_bro
real :: g_brp
real :: g_brq
real :: g_cfl
real :: g_da1
real :: g_da2
real :: g_dl
real :: g_dlh
real :: g_dli
real :: g_dlj
real :: g_dlk
real :: g_dm(is:ie+1,js-2:je+2)
real :: g_dmh
real :: g_dmi
real :: g_dmj
real :: g_dmk
real :: g_dml
real :: g_dmm
real :: g_dmn
real :: g_dmo
real :: g_dmp
real :: g_dmr
real :: g_dms
real :: g_dmu
real :: g_dmv
real :: g_dmw
real :: g_dq(is:ie+1,js-3:je+2)
real :: g_dr
real :: g_drh
real :: g_dri
real :: g_drj
real :: g_drk
real :: g_lac
real :: g_pmp
real :: g_xt
integer :: i
integer :: j
real :: lac
real :: pmp
real :: xt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (jord .eq. 1) then
  do j = js, je+1
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = g_v(i,j-1)
        flux(i,j) = v(i,j-1)
      else
        g_flux(i,j) = g_v(i,j)
        flux(i,j) = v(i,j)
      endif
    end do
  end do
else if (jord .le. 4) then
  do j = js-2, je+2
    do i = is, ie+1
      g_xt = (-0.25)*g_v(i,j-1)+0.25*g_v(i,j+1)
      xt = 0.25*(v(i,j+1)-v(i,j-1))
      g_dmj = g_xt*sign(1.,xt)
      dmj = abs(xt)
      g_dmm = g_v(i,j-1)*(0.5+sign(0.5,v(i,j-1)-v(i,j)))+g_v(i,j)*(0.5-sign(0.5,v(i,j-1)-v(i,j)))
      dmm = max(v(i,j-1),v(i,j))
      g_dmr = g_dmm*(0.5+sign(0.5,dmm-v(i,j+1)))+g_v(i,j+1)*(0.5-sign(0.5,dmm-v(i,j+1)))-g_v(i,j)
      dmr = max(dmm,v(i,j+1))-v(i,j)
      g_dms = g_v(i,j-1)*(0.5+sign(0.5,v(i,j)-v(i,j-1)))+g_v(i,j)*(0.5-sign(0.5,v(i,j)-v(i,j-1)))
      dms = min(v(i,j-1),v(i,j))
      g_dmu = (-(g_dms*(0.5+sign(0.5,v(i,j+1)-dms))+g_v(i,j+1)*(0.5-sign(0.5,v(i,j+1)-dms))))+g_v(i,j)
      dmu = v(i,j)-min(dms,v(i,j+1))
      g_dmv = g_dmj*(0.5+sign(0.5,dmr-dmj))+g_dmr*(0.5-sign(0.5,dmr-dmj))
      dmv = min(dmj,dmr)
      g_dmw = g_dmu*(0.5-sign(0.5,dmu-dmv))+g_dmv*(0.5+sign(0.5,dmu-dmv))
      dmw = min(dmv,dmu)
      g_dm(i,j) = g_dmw*sign(1.,dmw)*sign(1.,xt)
      dm(i,j) = sign(dmw,xt)
    end do
  end do
  if (is .eq. 1) then
    if (js .eq. 1) then
      g_dm(1,1) = 0.
      dm(1,1) = 0.
    endif
    if (je+1 .eq. npy) then
      g_dm(1,je) = 0.
      dm(1,je) = 0.
    endif
  endif
  if (ie+1 .eq. npx) then
    if (js .eq. 1) then
      g_dm(npx,1) = 0.
      dm(npx,1) = 0.
    endif
    if (je+1 .eq. npy) then
      g_dm(npx,je) = 0.
      dm(npx,je) = 0.
    endif
  endif
  do j = js-1, je+2
    do i = is, ie+1
      g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_v(i,j-1)+0.5*g_v(i,j)
      al(i,j) = 0.5*(v(i,j-1)+v(i,j))+r3*(dm(i,j-1)-dm(i,j))
    end do
  end do
  do j = js, je+1
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_xt = 2*g_dm(i,j-1)
        xt = 2.*dm(i,j-1)
        g_dlk = g_al(i,j-1)-g_v(i,j-1)
        dlk = al(i,j-1)-v(i,j-1)
        g_dlj = g_dlk*(0.5-sign(0.5,abs(dlk)-abs(xt)))*sign(1.,dlk)+g_xt*(0.5+sign(0.5,abs(dlk)-abs(xt)))*sign(1.,xt)
        dlj = min(abs(xt),abs(dlk))
        g_dl = g_dlj*sign(1.,dlj)*sign(1.,xt)
        dl = sign(dlj,xt)
        g_drk = g_al(i,j)-g_v(i,j-1)
        drk = al(i,j)-v(i,j-1)
        g_drj = g_drk*(0.5-sign(0.5,abs(drk)-abs(xt)))*sign(1.,drk)+g_xt*(0.5+sign(0.5,abs(drk)-abs(xt)))*sign(1.,xt)
        drj = min(abs(xt),abs(drk))
        g_dr = g_drj*sign(1.,drj)*sign(1.,xt)
        dr = sign(drj,xt)
        g_cfl = g_c(i,j)*rdy(i,j-1)
        cfl = c(i,j)*rdy(i,j-1)
        g_flux(i,j) = g_cfl*((1.-cfl)*(dl-dr)-(dr+cfl*(dl-dr)))+g_dl*(1.-cfl)*cfl+g_dr*(1.-cfl)*(1-cfl)+g_v(i,j-1)
        flux(i,j) = v(i,j-1)+(1.-cfl)*(dr+cfl*(dl-dr))
      else
        g_xt = 2*g_dm(i,j)
        xt = 2.*dm(i,j)
        g_dli = g_al(i,j)-g_v(i,j)
        dli = al(i,j)-v(i,j)
        g_dlh = g_dli*(0.5-sign(0.5,abs(dli)-abs(xt)))*sign(1.,dli)+g_xt*(0.5+sign(0.5,abs(dli)-abs(xt)))*sign(1.,xt)
        dlh = min(abs(xt),abs(dli))
        g_dl = g_dlh*sign(1.,dlh)*sign(1.,xt)
        dl = sign(dlh,xt)
        g_dri = g_al(i,j+1)-g_v(i,j)
        dri = al(i,j+1)-v(i,j)
        g_drh = g_dri*(0.5-sign(0.5,abs(dri)-abs(xt)))*sign(1.,dri)+g_xt*(0.5+sign(0.5,abs(dri)-abs(xt)))*sign(1.,xt)
        drh = min(abs(xt),abs(dri))
        g_dr = g_drh*sign(1.,drh)*sign(1.,xt)
        dr = sign(drh,xt)
        g_cfl = g_c(i,j)*rdy(i,j)
        cfl = c(i,j)*rdy(i,j)
        g_flux(i,j) = (-(g_cfl*((1.+cfl)*(dl-dr)+dl+cfl*(dl-dr))+g_dl*(1.+cfl)*(1+cfl)))+g_dr*(1.+cfl)*cfl+g_v(i,j)
        flux(i,j) = v(i,j)-(1.+cfl)*(dl+cfl*(dl-dr))
      endif
    end do
  end do
else
  do j = js-2, je+2
    do i = is, ie+1
      g_xt = (-0.25)*g_v(i,j-1)+0.25*g_v(i,j+1)
      xt = 0.25*(v(i,j+1)-v(i,j-1))
      g_dmh = g_xt*sign(1.,xt)
      dmh = abs(xt)
      g_dmi = g_v(i,j-1)*(0.5+sign(0.5,v(i,j-1)-v(i,j)))+g_v(i,j)*(0.5-sign(0.5,v(i,j-1)-v(i,j)))
      dmi = max(v(i,j-1),v(i,j))
      g_dmk = g_dmi*(0.5+sign(0.5,dmi-v(i,j+1)))+g_v(i,j+1)*(0.5-sign(0.5,dmi-v(i,j+1)))-g_v(i,j)
      dmk = max(dmi,v(i,j+1))-v(i,j)
      g_dml = g_v(i,j-1)*(0.5+sign(0.5,v(i,j)-v(i,j-1)))+g_v(i,j)*(0.5-sign(0.5,v(i,j)-v(i,j-1)))
      dml = min(v(i,j-1),v(i,j))
      g_dmn = (-(g_dml*(0.5+sign(0.5,v(i,j+1)-dml))+g_v(i,j+1)*(0.5-sign(0.5,v(i,j+1)-dml))))+g_v(i,j)
      dmn = v(i,j)-min(dml,v(i,j+1))
      g_dmo = g_dmh*(0.5+sign(0.5,dmk-dmh))+g_dmk*(0.5-sign(0.5,dmk-dmh))
      dmo = min(dmh,dmk)
      g_dmp = g_dmn*(0.5-sign(0.5,dmn-dmo))+g_dmo*(0.5+sign(0.5,dmn-dmo))
      dmp = min(dmo,dmn)
      g_dm(i,j) = g_dmp*sign(1.,dmp)*sign(1.,xt)
      dm(i,j) = sign(dmp,xt)
    end do
  end do
  do j = js-3, je+2
    do i = is, ie+1
      g_dq(i,j) = g_v(i,j+1)-g_v(i,j)
      dq(i,j) = v(i,j+1)-v(i,j)
    end do
  end do
  if (grid_type .lt. 3) then
    do j = max(3,js-1), min(npy-2,je+2)
      do i = is, ie+1
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_v(i,j-1)+0.5*g_v(i,j)
        al(i,j) = 0.5*(v(i,j-1)+v(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    if (jord .lt. 10) then
      do j = max(3,js-1), min(npy-3,je+1)
        do i = is, ie+1
          g_pmp = 2*g_dq(i,j-1)
          pmp = 2.*dq(i,j-1)
          g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
          lac = pmp-1.5*dq(i,j-2)
          g_brm = g_pmp*(0.5-sign(0.5,0.-pmp))
          brm = max(0.,pmp)
          g_brn = g_brm*(0.5+sign(0.5,brm-lac))+g_lac*(0.5-sign(0.5,brm-lac))
          brn = max(brm,lac)
          g_brp = g_pmp*(0.5-sign(0.5,pmp-0.))
          brp = min(0.,pmp)
          g_brq = g_brp*(0.5+sign(0.5,lac-brp))+g_lac*(0.5-sign(0.5,lac-brp))
          brq = min(brp,lac)
          g_bro = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-v(i,j)-brq))+g_brq*(0.5-sign(0.5,al(i,j+1)-v(i,j)-brq))-g_v(i,j)*(0.5+&
&sign(0.5,al(i,j+1)-v(i,j)-brq))
          bro = max(al(i,j+1)-v(i,j),brq)
          g_br(i,j) = g_brn*(0.5+sign(0.5,bro-brn))+g_bro*(0.5-sign(0.5,bro-brn))
          br(i,j) = min(brn,bro)
          g_pmp = (-2)*g_dq(i,j)
          pmp = -(2.*dq(i,j))
          g_lac = 1.5*g_dq(i,j+1)+g_pmp
          lac = pmp+1.5*dq(i,j+1)
          g_blm = g_pmp*(0.5-sign(0.5,0.-pmp))
          blm = max(0.,pmp)
          g_bln = g_blm*(0.5+sign(0.5,blm-lac))+g_lac*(0.5-sign(0.5,blm-lac))
          bln = max(blm,lac)
          g_blp = g_pmp*(0.5-sign(0.5,pmp-0.))
          blp = min(0.,pmp)
          g_blq = g_blp*(0.5+sign(0.5,lac-blp))+g_lac*(0.5-sign(0.5,lac-blp))
          blq = min(blp,lac)
          g_blo = g_al(i,j)*(0.5+sign(0.5,al(i,j)-v(i,j)-blq))+g_blq*(0.5-sign(0.5,al(i,j)-v(i,j)-blq))-g_v(i,j)*(0.5+sign(0.5,&
&al(i,j)-v(i,j)-blq))
          blo = max(al(i,j)-v(i,j),blq)
          g_bl(i,j) = g_bln*(0.5+sign(0.5,blo-bln))+g_blo*(0.5-sign(0.5,blo-bln))
          bl(i,j) = min(bln,blo)
        end do
      end do
    else
      do j = max(3,js-1), min(npy-3,je+1)
        do i = is, ie+1
          g_bl(i,j) = g_al(i,j)-g_v(i,j)
          bl(i,j) = al(i,j)-v(i,j)
          g_br(i,j) = g_al(i,j+1)-g_v(i,j)
          br(i,j) = al(i,j+1)-v(i,j)
        end do
      end do
    endif
    if (js .eq. 1) then
      do i = is, ie+1
        g_br(i,2) = g_al(i,3)-g_v(i,2)
        br(i,2) = al(i,3)-v(i,2)
        g_xt = (-(g_dm(i,2)*s14))+g_v(i,2)*s11+g_v(i,1)*s15
        xt = s15*v(i,1)+s11*v(i,2)-s14*dm(i,2)
        g_br(i,1) = (-g_v(i,1))+g_xt
        br(i,1) = xt-v(i,1)
        g_bl(i,2) = (-g_v(i,2))+g_xt
        bl(i,2) = xt-v(i,2)
        g_bl(i,0) = g_dm(i,-1)*s14-g_dq(i,-1)*s11
        bl(i,0) = s14*dm(i,-1)-s11*dq(i,-1)
        g_xt = (-((g_v(i,-1)+g_v(i,2))*(0.5*dy(i,1)/(dy(i,1)+dy(i,2)))))+(g_v(i,1)+g_v(i,0))*(0.5*(2.*dy(i,1)+dy(i,2))/(dy(i,1)+&
&dy(i,2)))
        xt = 0.5*((2.*dy(i,1)+dy(i,2))*(v(i,0)+v(i,1))-dy(i,1)*(v(i,-1)+v(i,2)))/(dy(i,1)+dy(i,2))
        g_bl(i,1) = (-g_v(i,1))+g_xt
        bl(i,1) = xt-v(i,1)
        g_br(i,0) = (-g_v(i,0))+g_xt
        br(i,0) = xt-v(i,0)
      end do
      if (is .eq. 1) then
        g_bl(1,0) = 0.
        bl(1,0) = 0.
        g_br(1,0) = 0.
        br(1,0) = 0.
        g_bl(1,1) = 0.
        bl(1,1) = 0.
        g_br(1,1) = 0.
        br(1,1) = 0.
      endif
      if (ie+1 .eq. npx) then
        g_bl(npx,0) = 0.
        bl(npx,0) = 0.
        g_br(npx,0) = 0.
        br(npx,0) = 0.
        g_bl(npx,1) = 0.
        bl(npx,1) = 0.
        g_br(npx,1) = 0.
        br(npx,1) = 0.
      endif
      if (jord .lt. 10) then
        do i = is, ie+1
          if (bl(i,2)*br(i,2) .lt. 0.) then
            g_da1 = g_bl(i,2)-g_br(i,2)
            da1 = bl(i,2)-br(i,2)
            g_da2 = 2*g_da1*da1
            da2 = da1**2
            g_a6da = 3*g_bl(i,2)*da1+3*g_br(i,2)*da1+3*g_da1*(bl(i,2)+br(i,2))
            a6da = 3.*(bl(i,2)+br(i,2))*da1
            if (a6da .lt. (-da2)) then
              g_br(i,2) = (-2)*g_bl(i,2)
              br(i,2) = -(2.*bl(i,2))
            else if (a6da .gt. da2) then
              g_bl(i,2) = (-2)*g_br(i,2)
              bl(i,2) = -(2.*br(i,2))
            endif
          else
            g_bl(i,2) = 0.
            bl(i,2) = 0.
            g_br(i,2) = 0.
            br(i,2) = 0.
          endif
        end do
      endif
    endif
    if (je+1 .eq. npy) then
      do i = is, ie+1
        g_bl(i,npy-2) = g_al(i,npy-2)-g_v(i,npy-2)
        bl(i,npy-2) = al(i,npy-2)-v(i,npy-2)
        g_xt = g_dm(i,npy-2)*s14+g_v(i,npy-2)*s11+g_v(i,npy-1)*s15
        xt = s15*v(i,npy-1)+s11*v(i,npy-2)+s14*dm(i,npy-2)
        g_br(i,npy-2) = (-g_v(i,npy-2))+g_xt
        br(i,npy-2) = xt-v(i,npy-2)
        g_bl(i,npy-1) = (-g_v(i,npy-1))+g_xt
        bl(i,npy-1) = xt-v(i,npy-1)
        g_br(i,npy) = (-(g_dm(i,npy+1)*s14))+g_dq(i,npy)*s11
        br(i,npy) = s11*dq(i,npy)-s14*dm(i,npy+1)
        g_xt = (-(g_v(i,npy-2)*(0.5*dy(i,npy-1)/(dy(i,npy-1)+dy(i,npy-2)))))+g_v(i,npy-1)*(0.5*(2.*dy(i,npy-1)+dy(i,npy-2))/(dy(i,&
&npy-1)+dy(i,npy-2)))-g_v(i,npy+1)*(0.5*dy(i,npy-1)/(dy(i,npy-1)+dy(i,npy-2)))+g_v(i,npy)*(0.5*(2.*dy(i,npy-1)+dy(i,npy-2))&
&/(dy(i,npy-1)+dy(i,npy-2)))
        xt = 0.5*((2.*dy(i,npy-1)+dy(i,npy-2))*(v(i,npy-1)+v(i,npy))-dy(i,npy-1)*(v(i,npy-2)+v(i,npy+1)))/(dy(i,npy-1)+dy(i,npy-2))
        g_br(i,npy-1) = (-g_v(i,npy-1))+g_xt
        br(i,npy-1) = xt-v(i,npy-1)
        g_bl(i,npy) = (-g_v(i,npy))+g_xt
        bl(i,npy) = xt-v(i,npy)
      end do
      if (is .eq. 1) then
        g_bl(1,npy-1) = 0.
        bl(1,npy-1) = 0.
        g_br(1,npy-1) = 0.
        br(1,npy-1) = 0.
        g_bl(1,npy) = 0.
        bl(1,npy) = 0.
        g_br(1,npy) = 0.
        br(1,npy) = 0.
      endif
      if (ie+1 .eq. npx) then
        g_bl(npx,npy-1) = 0.
        bl(npx,npy-1) = 0.
        g_br(npx,npy-1) = 0.
        br(npx,npy-1) = 0.
        g_bl(npx,npy) = 0.
        bl(npx,npy) = 0.
        g_br(npx,npy) = 0.
        br(npx,npy) = 0.
      endif
      if (jord .lt. 10) then
        do i = is, ie+1
          if (bl(i,npy-2)*br(i,npy-2) .lt. 0.) then
            g_da1 = g_bl(i,npy-2)-g_br(i,npy-2)
            da1 = bl(i,npy-2)-br(i,npy-2)
            g_da2 = 2*g_da1*da1
            da2 = da1**2
            g_a6da = 3*g_bl(i,npy-2)*da1+3*g_br(i,npy-2)*da1+3*g_da1*(bl(i,npy-2)+br(i,npy-2))
            a6da = 3.*(bl(i,npy-2)+br(i,npy-2))*da1
            if (a6da .lt. (-da2)) then
              g_br(i,npy-2) = (-2)*g_bl(i,npy-2)
              br(i,npy-2) = -(2.*bl(i,npy-2))
            else if (a6da .gt. da2) then
              g_bl(i,npy-2) = (-2)*g_br(i,npy-2)
              bl(i,npy-2) = -(2.*br(i,npy-2))
            endif
          else
            g_bl(i,npy-2) = 0.
            bl(i,npy-2) = 0.
            g_br(i,npy-2) = 0.
            br(i,npy-2) = 0.
          endif
        end do
      endif
    endif
  else
    do j = js-1, je+2
      do i = is, ie+1
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_v(i,j-1)+0.5*g_v(i,j)
        al(i,j) = 0.5*(v(i,j-1)+v(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    do j = js-1, je+1
      do i = is, ie+1
        g_pmp = 2*g_dq(i,j-1)
        pmp = 2.*dq(i,j-1)
        g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
        lac = pmp-1.5*dq(i,j-2)
        g_brh = g_pmp*(0.5-sign(0.5,0.-pmp))
        brh = max(0.,pmp)
        g_bri = g_brh*(0.5+sign(0.5,brh-lac))+g_lac*(0.5-sign(0.5,brh-lac))
        bri = max(brh,lac)
        g_brk = g_pmp*(0.5-sign(0.5,pmp-0.))
        brk = min(0.,pmp)
        g_brl = g_brk*(0.5+sign(0.5,lac-brk))+g_lac*(0.5-sign(0.5,lac-brk))
        brl = min(brk,lac)
        g_brj = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-v(i,j)-brl))+g_brl*(0.5-sign(0.5,al(i,j+1)-v(i,j)-brl))-g_v(i,j)*(0.5+sign(0.5,&
&al(i,j+1)-v(i,j)-brl))
        brj = max(al(i,j+1)-v(i,j),brl)
        g_br(i,j) = g_bri*(0.5+sign(0.5,brj-bri))+g_brj*(0.5-sign(0.5,brj-bri))
        br(i,j) = min(bri,brj)
        g_pmp = (-2)*g_dq(i,j)
        pmp = -(2.*dq(i,j))
        g_lac = 1.5*g_dq(i,j+1)+g_pmp
        lac = pmp+1.5*dq(i,j+1)
        g_blh = g_pmp*(0.5-sign(0.5,0.-pmp))
        blh = max(0.,pmp)
        g_bli = g_blh*(0.5+sign(0.5,blh-lac))+g_lac*(0.5-sign(0.5,blh-lac))
        bli = max(blh,lac)
        g_blk = g_pmp*(0.5-sign(0.5,pmp-0.))
        blk = min(0.,pmp)
        g_bll = g_blk*(0.5+sign(0.5,lac-blk))+g_lac*(0.5-sign(0.5,lac-blk))
        bll = min(blk,lac)
        g_blj = g_al(i,j)*(0.5+sign(0.5,al(i,j)-v(i,j)-bll))+g_bll*(0.5-sign(0.5,al(i,j)-v(i,j)-bll))-g_v(i,j)*(0.5+sign(0.5,al(i,&
&j)-v(i,j)-bll))
        blj = max(al(i,j)-v(i,j),bll)
        g_bl(i,j) = g_bli*(0.5+sign(0.5,blj-bli))+g_blj*(0.5-sign(0.5,blj-bli))
        bl(i,j) = min(bli,blj)
      end do
    end do
  endif
  do j = js, je+1
    do i = is, ie+1
      if (c(i,j) .gt. 0.) then
        g_cfl = g_c(i,j)*rdy(i,j-1)
        cfl = c(i,j)*rdy(i,j-1)
        g_flux(i,j) = (-(g_bl(i,j-1)*(1.-cfl)*cfl))+g_br(i,j-1)*(1.-cfl)*(1-cfl)-g_cfl*((1.-cfl)*(bl(i,j-1)+br(i,j-1))+br(i,j-1)-&
&cfl*(bl(i,j-1)+br(i,j-1)))+g_v(i,j-1)
        flux(i,j) = v(i,j-1)+(1.-cfl)*(br(i,j-1)-cfl*(bl(i,j-1)+br(i,j-1)))
      else
        g_cfl = g_c(i,j)*rdy(i,j)
        cfl = c(i,j)*rdy(i,j)
        g_flux(i,j) = g_bl(i,j)*(1.+cfl)*(1+cfl)+g_br(i,j)*(1.+cfl)*cfl+g_cfl*((1.+cfl)*(bl(i,j)+br(i,j))+bl(i,j)+cfl*(bl(i,j)+&
&br(i,j)))+g_v(i,j)
        flux(i,j) = v(i,j)+(1.+cfl)*(bl(i,j)+cfl*(bl(i,j)+br(i,j)))
      endif
    end do
  end do
endif

end subroutine g_ytp_v


end module     g_sw_core_mod


