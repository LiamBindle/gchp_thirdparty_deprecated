!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.24
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_dyn_core_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.24  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains, mpp_update_domains_ad
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use dyn_core_mod

   use fv_mp_mod, only: mp_reduce_sum


!==============================================
! all entries are defined explicitly
!==============================================
implicit none

public g_dyn_core

contains
subroutine g_adv_pe( ua, g_ua, va, g_va, pem, g_pem, om, g_om, npx, npy, npz, ng, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use g_a2b_edge_mod, only : g_a2b_ord2, g_a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: g_om(isd:ied,jsd:jed,npz)
real, intent(in) :: g_pem(is-1:ie+1,1:npz+1,js-1:je+1)
real, intent(in) :: g_ua(isd:ied,jsd:jed,npz)
real, intent(in) :: g_va(isd:ied,jsd:jed,npz)
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: om(isd:ied,jsd:jed,npz)
real, intent(in) :: pem(is-1:ie+1,1:npz+1,js-1:je+1)
integer :: taf_rec
real, intent(in) :: ua(isd:ied,jsd:jed,npz)
real, intent(in) :: va(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: g_grad(3,is:ie,js:je)
real :: g_pb(isd:ied,jsd:jed)
real :: g_pdx(3,is:ie,js:je+1)
real :: g_pdy(3,is:ie+1,js:je)
real :: g_pin(isd:ied,jsd:jed)
real :: g_ut(is:ie,js:je)
real :: g_v3(3,is:ie,js:je)
real :: g_vt(is:ie,js:je)
real :: grad(3,is:ie,js:je)
integer :: i
integer :: j
integer :: k
integer :: n
real :: pb(isd:ied,jsd:jed)
real :: pdx(3,is:ie,js:je+1)
real :: pdy(3,is:ie+1,js:je)
real :: pin(isd:ied,jsd:jed)
real :: ut(is:ie,js:je)
real :: v3(3,is:ie,js:je)
real :: vt(is:ie,js:je)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, npz
  if (k .eq. npz) then
    do j = js, je
      do i = is, ie
        g_ut(i,j) = g_ua(i,j,npz)
        ut(i,j) = ua(i,j,npz)
        g_vt(i,j) = g_va(i,j,npz)
        vt(i,j) = va(i,j,npz)
      end do
    end do
  else
    do j = js, je
      do i = is, ie
        g_ut(i,j) = 0.5*g_ua(i,j,k+1)+0.5*g_ua(i,j,k)
        ut(i,j) = 0.5*(ua(i,j,k)+ua(i,j,k+1))
        g_vt(i,j) = 0.5*g_va(i,j,k+1)+0.5*g_va(i,j,k)
        vt(i,j) = 0.5*(va(i,j,k)+va(i,j,k+1))
      end do
    end do
  endif
  do j = js, je
    do i = is, ie
      do n = 1, 3
        g_v3(n,i,j) = g_ut(i,j)*ec1(n,i,j)+g_vt(i,j)*ec2(n,i,j)
        v3(n,i,j) = ut(i,j)*ec1(n,i,j)+vt(i,j)*ec2(n,i,j)
      end do
    end do
  end do
  do j = js-1, je+1
    do i = is-1, ie+1
      g_pin(i,j) = g_pem(i,k+1,j)
      pin(i,j) = pem(i,k+1,j)
    end do
  end do
  call g_a2b_ord2( pin,g_pin,pb,g_pb,npx,npy,is,ie,js,je,ng )
  do j = js, je+1
    do i = is, ie
      do n = 1, 3
        g_pdx(n,i,j) = (g_pb(i+1,j)+g_pb(i,j))*dx(i,j)*en1(n,i,j)
        pdx(n,i,j) = (pb(i,j)+pb(i+1,j))*dx(i,j)*en1(n,i,j)
      end do
    end do
  end do
  do j = js, je
    do i = is, ie+1
      do n = 1, 3
        g_pdy(n,i,j) = (g_pb(i,j+1)+g_pb(i,j))*dy(i,j)*en2(n,i,j)
        pdy(n,i,j) = (pb(i,j)+pb(i,j+1))*dy(i,j)*en2(n,i,j)
      end do
    end do
  end do
  do j = js, je
    do i = is, ie
      do n = 1, 3
        g_grad(n,i,j) = g_pdx(n,i,j+1)-g_pdx(n,i,j)+g_pdy(n,i+1,j)-g_pdy(n,i,j)
        grad(n,i,j) = pdx(n,i,j+1)-pdx(n,i,j)-pdy(n,i,j)+pdy(n,i+1,j)
      end do
    end do
  end do
  do j = js, je
    do i = is, ie
      g_om(i,j,k) = 0.5*g_grad(3,i,j)*rarea(i,j)*v3(3,i,j)+0.5*g_grad(2,i,j)*rarea(i,j)*v3(2,i,j)+0.5*g_grad(1,i,j)*rarea(i,j)*&
&v3(1,i,j)+g_om(i,j,k)+0.5*g_v3(3,i,j)*rarea(i,j)*grad(3,i,j)+0.5*g_v3(2,i,j)*rarea(i,j)*grad(2,i,j)+0.5*g_v3(1,i,j)*rarea(i,&
&j)*grad(1,i,j)
      om(i,j,k) = om(i,j,k)+0.5*rarea(i,j)*(v3(1,i,j)*grad(1,i,j)+v3(2,i,j)*grad(2,i,j)+v3(3,i,j)*grad(3,i,j))
    end do
  end do
end do

end subroutine g_adv_pe


subroutine g_dyn_core( npx, npy, npz, ng, bdt, n_split, cp, akap, grav, hydrostatic, u, g_u, v, g_v, w, g_w, delz, g_delz, pt, &
&g_pt, delp, g_delp, pe, g_pe, pk, g_pk, phis, omga, g_omga, ptop, pfull, ua, g_ua, va, g_va, uc, g_uc, vc, g_vc, mfx, g_mfx, mfy, &
&g_mfy, cx, g_cx, cy, g_cy, pem, g_pem, delzc, g_delzc, peln, g_peln, uniform_ppm, time_total )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use nh_core_mod, only : riem_solver, riem_solver_c, update_dz_c, update_dz_d
use g_nh_core_mod, only : g_riem_solver, g_riem_solver_c, g_update_dz_c, g_update_dz_d
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use fv_my_mpp, only : mpp_get_boundary_dummy, mpp_update_domains_dummy
use g_fv_my_mpp, only : g_mpp_get_boundary_dgrid, g_mpp_update_domains_cgrid, g_mpp_update_domains_dgrid, &
&g_mpp_update_domains_dummy, g_mpp_update_domains_dummy
use fv_my_mpp, only : mpp_update_domains_cgrid, mpp_update_domains_dgrid
use fv_my_mpp, only : mpp_get_boundary_dgrid
use g_sw_core_mod, only : g_c_sw, g_d_sw, g_divergence_corner
use g_a2b_edge_mod, only : g_a2b_ord2

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: akap
real, intent(in) :: bdt
real, intent(in) :: cp
integer, intent(in) :: npz
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
real, intent(inout) :: delzc(is:ie,js:je,npz)
real, intent(inout) :: g_cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: g_cy(isd:ied,js:je+1,npz)
real, intent(inout) :: g_delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_delz(is:ie,js:je,npz)
real, intent(inout) :: g_delzc(is:ie,js:je,npz)
real, intent(inout) :: g_mfx(is:ie+1,js:je,npz)
real, intent(inout) :: g_mfy(is:ie,js:je+1,npz)
real, intent(inout) :: g_omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: g_peln(is:ie,npz+1,js:je)
real, intent(inout) :: g_pem(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: g_pk(is:ie,js:je,npz+1)
real, intent(inout) :: g_pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: g_ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_uc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: g_va(isd:ied,jsd:jed,npz)
real, intent(inout) :: g_vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: g_w(isd:ied,jsd:jed,npz)
real, intent(in) :: grav
logical, intent(in) :: hydrostatic
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: pem(is-1:ie+1,npz+1,js-1:je+1)
real, intent(in) :: pfull(npz)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(in) :: ptop
real,optional, intent(in) :: time_total
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
logical, intent(in) :: uniform_ppm
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: crx(is:ie+1,jsd:jed,npz)
real :: cry(isd:ied,js:je+1,npz)
real :: d_divg
real :: d_divgi
real :: delpc(isd:ied,jsd:jed,npz)
real :: divg2(is:ie+1,js:je+1)
real :: divg_d(isd:ied+1,jsd:jed+1,npz)
logical :: do_omega
logical :: dord4
real :: dt
real :: dt2
real :: g_crx(is:ie+1,jsd:jed,npz)
real :: g_cry(isd:ied,js:je+1,npz)
real :: g_delpc(isd:ied,jsd:jed,npz)
real :: g_divg2(is:ie+1,js:je+1)
real :: g_divg_d(isd:ied+1,jsd:jed+1,npz)
real :: g_gz(isd:ied,jsd:jed,npz+1)
real, allocatable :: g_pk3h(:,:,:)
real :: g_pkc(isd:ied,jsd:jed,npz+1)
real :: g_ptc(isd:ied,jsd:jed,npz)
real :: g_ut(isd:ied,jsd:jed,npz)
real :: g_vt(isd:ied,jsd:jed,npz)
real :: g_wk(isd:ied,jsd:jed)
real :: g_xfx(is:ie+1,jsd:jed,npz)
real :: g_yfx(isd:ied,js:je+1,npz)
real :: g_zh(isd:ied,jsd:jed,npz)
real :: gz(isd:ied,jsd:jed,npz+1)
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: help_r
integer :: help_s
integer :: help_t
integer :: help_u
integer :: hord_m
integer :: hord_t
integer :: hord_v
integer :: i
integer :: ieb1
integer :: iep1
integer :: ism1
integer :: it
integer :: j
integer :: jeb1
integer :: jep1
integer :: jsm1
integer :: k
logical :: last_step
real :: pk3(isd:ied,jsd:jed,npz+1)
real :: pkc(isd:ied,jsd:jed,npz+1)
real :: ptc(isd:ied,jsd:jed,npz)
real :: ptk
real :: rdt
real :: rgrav
integer :: taf_rec_npz
real :: ut(isd:ied,jsd:jed,npz)
real :: vt(isd:ied,jsd:jed,npz)
real :: wk(isd:ied,jsd:jed)
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)
real :: zh(isd:ied,jsd:jed,npz)

!==============================================
! declare data
!==============================================

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
delpc = 0.
ptc = 0.
ut = 0.
vt = 0.
gz = 0.
pkc = 0.
g_divg_d = 0.
divg_d = 0.
ptk = ptop**akap
if (dddm4 .gt. 0.) then
  dord4 =  .true. 
else
  dord4 =  .false. 
endif
if (npz .gt. 1) then
  call g_mpp_update_domains_dummy( pt,g_pt,is,ie,js,je,isd,ied,jsd,jed,npz )
endif
call g_mpp_update_domains_dummy( delp,g_delp,is,ie,js,je,isd,ied,jsd,jed,npz )
dt = bdt/real(n_split)
dt2 = 0.5*dt
rdt = 1./dt
rgrav = 1./grav
ism1 = is-1
iep1 = ie+1
jsm1 = js-1
jep1 = je+1
do it = 1, n_split
  if ( .not. hydrostatic) then
    do j = js, je
      do i = is, ie
        g_zh(i,j,npz) = -g_delz(i,j,npz)
        zh(i,j,npz) = phis(i,j)*rgrav-delz(i,j,npz)
      end do
      do k = npz-1, 1, -1
        do i = is, ie
          g_zh(i,j,k) = (-g_delz(i,j,k))+g_zh(i,j,k+1)
          zh(i,j,k) = zh(i,j,k+1)-delz(i,j,k)
        end do
      end do
    end do
    call g_mpp_update_domains_dummy( zh,g_zh,is,ie,js,je,isd,ied,jsd,jed,npz )
    call g_mpp_update_domains_dummy( w,g_w,is,ie,js,je,isd,ied,jsd,jed,npz )
  endif
  if (it .eq. n_split) then
    do j = jsm1, jep1
      do i = ism1, iep1
        g_pem(i,1,j) = 0.
        pem(i,1,j) = ptop
      end do
      do k = 1, npz
        do i = ism1, iep1
          g_pem(i,k+1,j) = g_delp(i,j,k)+g_pem(i,k,j)
          pem(i,k+1,j) = pem(i,k,j)+delp(i,j,k)
        end do
      end do
    end do
    do_omega =  .true. 
  else
    do_omega =  .false. 
  endif
  if (it .eq. n_split) then
    last_step =  .true. 
  else
    last_step =  .false. 
  endif
  ieb1 = ie+1
  jeb1 = je+1
  do k = 1, npz
    taf_rec_npz = (it-1)*npz+k
    call g_c_sw( delpc(isd,jsd,k),g_delpc(isd,jsd,k),delp(isd,jsd,k),g_delp(isd,jsd,k),ptc(isd,jsd,k),g_ptc(isd,jsd,k),pt(isd,jsd,&
&k),g_pt(isd,jsd,k),u(isd,jsd,k),g_u(isd,jsd,k),v(isd,jsd,k),g_v(isd,jsd,k),w(isd,jsd,k),g_w(isd,jsd,k),uc(isd,jsd,k),g_uc(isd,&
&jsd,k),vc(isd,jsd,k),g_vc(isd,jsd,k),ua(isd,jsd,k),g_ua(isd,jsd,k),va(isd,jsd,k),g_va(isd,jsd,k),omga(isd,jsd,k),g_omga(isd,&
&jsd,k),ut(isd,jsd,k),g_ut(isd,jsd,k),vt(isd,jsd,k),g_vt(isd,jsd,k),dt2,hydrostatic,dord4,taf_rec_npz )
  end do
  if (hydrostatic) then
    call g_geopk( ptop,pe,g_pe,peln,g_peln,delpc,g_delpc,pkc,g_pkc,gz,g_gz,phis,ptc,g_ptc,npz,akap, .false. , .false. , .true.  )
  else
    call g_update_dz_c( is,ie,js,je,npz,ng,area,zh,ut,vt,delz,delzc,gz,g_gz )
    call g_riem_solver_c( dt2,is,ie,js,je,npz,ng,akap,cp,ptop,phis,omga,g_omga,delzc,ptc,g_ptc,delpc,g_delpc,gz,pkc,1 )
    help_h = npz+1
    call g_mpp_update_domains_dummy( pkc,g_pkc,is,ie,js,je,isd,ied,jsd,jed,help_h )
    help_i = npz+1
    call g_mpp_update_domains_dummy( gz,g_gz,is,ie,js,je,isd,ied,jsd,jed,help_i )
  endif
  ieb1 = ie+1
  jeb1 = je+1
  do k = 1, npz
    if (hydrostatic) then
      do j = jsm1, jeb1
        do i = ism1, ieb1
          g_wk(i,j) = g_pkc(i,j,k+1)-g_pkc(i,j,k)
          wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
        end do
      end do
    else
      do j = jsd, jed
        do i = isd, ied
          g_wk(i,j) = g_delpc(i,j,k)
          wk(i,j) = delpc(i,j,k)
          g_delpc(i,j,k) = g_delp(i,j,k)
          delpc(i,j,k) = delp(i,j,k)
        end do
      end do
    endif
    do j = js, je
      do i = is, ieb1
        g_uc(i,j,k) = g_gz(i-1,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))-g_gz(i,j,k+1)*dt2*rdxc(i,j)/&
&(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k))+g_gz(i-1,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k)&
&)-g_gz(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))+g_pkc(i-1,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+&
&wk(i,j))*(gz(i-1,j,k)-gz(i,j,k+1))+g_pkc(i,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))-g_pkc(i-1,j,&
&k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))-g_pkc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k)&
&-gz(i,j,k+1))+g_uc(i,j,k)-g_wk(i-1,j)*dt2*rdxc(i,j)/((wk(i-1,j)+wk(i,j))*(wk(i-1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))-g_wk(i,j)*dt2*rdxc(i,j)/((wk(i-1,j)+&
&wk(i,j))*(wk(i-1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,&
&k+1)-pkc(i,j,k)))
        uc(i,j,k) = uc(i,j,k)+dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)&
&-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
      end do
    end do
    do j = js, jeb1
      do i = is, ie
        g_vc(i,j,k) = g_gz(i,j-1,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))+g_gz(i,j-1,k)*dt2*rdyc(i,j)/&
&(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k))-g_gz(i,j,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k)&
&)-g_gz(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))+g_pkc(i,j-1,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+&
&wk(i,j))*(gz(i,j-1,k)-gz(i,j,k+1))-g_pkc(i,j-1,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))+g_pkc(i,j,k+&
&1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))-g_pkc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k)&
&-gz(i,j,k+1))+g_vc(i,j,k)-g_wk(i,j-1)*dt2*rdyc(i,j)/((wk(i,j-1)+wk(i,j))*(wk(i,j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))-g_wk(i,j)*dt2*rdyc(i,j)/((wk(i,j-1)+&
&wk(i,j))*(wk(i,j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,&
&k+1)-pkc(i,j,k)))
        vc(i,j,k) = vc(i,j,k)+dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)&
&-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      end do
    end do
  end do
  help_j = jed+1
  help_k = ied+1
  call g_mpp_update_domains_cgrid( vc,g_vc,uc,g_uc,is,ie,js,je,isd,ied,jsd,help_j,npz,is,ie,js,je,isd,help_k,jsd,jed,npz )
  if (dord4) then
    call g_divergence_corner( u,g_u,v,g_v,ua,g_ua,va,g_va,divg_d,g_divg_d,npz )
    if (grid_type .ne. 4) then
      call g_mpp_update_domains_dummy( divg_d,g_divg_d,is,ie,js,je,isd,ied,jsd,jed,npz )
    endif
  endif
  do k = 1, npz
    hord_m = hord_mt
    hord_t = hord_tm
    hord_v = hord_vt
    if (n_sponge .eq. (-1) .or. npz .eq. 1) then
      d_divg = dddmp
    else
      if (k .le. n_sponge .and. npz .gt. 16) then
        hord_v = 1
        hord_t = 1
        d_divg = min(0.24,6.*dddmp)
        d_divg = max(0.02,d_divg)
      else if (k .eq. n_sponge+1 .and. npz .gt. 16) then
        d_divg = min(0.24,4.*dddmp)
        d_divg = max(0.01,d_divg)
      else
        d_divgi = 0.1*log(pfull(k)/pfull(npz))
        d_divg = min(0.24,dddmp*(1.-3.*tanh(d_divgi)))
      endif
    endif
    if (d_ext .gt. 0.) then
      call g_a2b_ord2( delp(isd,jsd,k),g_delp(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .false.  )
    endif
    taf_rec_npz = (it-1)*npz+k
         call timing_on('tlm_dsw')
    call g_d_sw( vt(isd,jsd,k),g_vt(isd,jsd,k),delp(isd,jsd,k),g_delp(isd,jsd,k),ptc(isd,jsd,k),g_ptc(isd,jsd,k),pt(isd,jsd,k),&
&g_pt(isd,jsd,k),u(isd,jsd,k),g_u(isd,jsd,k),v(isd,jsd,k),g_v(isd,jsd,k),w(isd,jsd,k),g_w(isd,jsd,k),uc(isd,jsd,k),g_uc(isd,&
&jsd,k),vc(isd,jsd,k),g_vc(isd,jsd,k),ua(isd,jsd,k),g_ua(isd,jsd,k),va(isd,jsd,k),g_va(isd,jsd,k),divg_d(isd,jsd,k),&
&g_divg_d(isd,jsd,k),mfx(is,js,k),g_mfx(is,js,k),mfy(is,js,k),g_mfy(is,js,k),cx(is,jsd,k),g_cx(is,jsd,k),cy(isd,js,k),g_cy(isd,&
&js,k),crx(is,jsd,k),g_crx(is,jsd,k),cry(isd,js,k),g_cry(isd,js,k),xfx(is,jsd,k),g_xfx(is,jsd,k),yfx(isd,js,k),g_yfx(isd,js,k),&
&dt,hord_m,hord_v,hord_t,d_divg,dddm4,hydrostatic,uniform_ppm,taf_rec_npz )
         call timing_off('tlm_dsw')
    if (d_ext .gt. 0.) then
      do j = js, jep1
        do i = is, iep1
          g_ptc(i,j,k) = g_wk(i,j)
          ptc(i,j,k) = wk(i,j)
        end do
      end do
    endif
  end do
  if (d_ext .gt. 0.) then
    d_divg = d_ext*da_min_c
    do j = js, jep1
      do i = is, iep1
        g_wk(i,j) = g_ptc(i,j,1)
        wk(i,j) = ptc(i,j,1)
        g_divg2(i,j) = g_vt(i,j,1)*wk(i,j)+g_wk(i,j)*vt(i,j,1)
        divg2(i,j) = wk(i,j)*vt(i,j,1)
      end do
      do k = 2, npz
        do i = is, iep1
          g_wk(i,j) = g_ptc(i,j,k)+g_wk(i,j)
          wk(i,j) = wk(i,j)+ptc(i,j,k)
          g_divg2(i,j) = g_divg2(i,j)+g_ptc(i,j,k)*vt(i,j,k)+g_vt(i,j,k)*ptc(i,j,k)
          divg2(i,j) = divg2(i,j)+ptc(i,j,k)*vt(i,j,k)
        end do
      end do
      do i = is, iep1
        g_divg2(i,j) = g_divg2(i,j)*(d_divg/wk(i,j))-g_wk(i,j)*(d_divg*divg2(i,j)/(wk(i,j)*wk(i,j)))
        divg2(i,j) = d_divg*divg2(i,j)/wk(i,j)
      end do
    end do
  else
    g_divg2 = 0.
    divg2 = 0.
  endif
  call g_mpp_update_domains_dummy( pt,g_pt,is,ie,js,je,isd,ied,jsd,jed,npz )
  call g_mpp_update_domains_dummy( delp,g_delp,is,ie,js,je,isd,ied,jsd,jed,npz )
  if (hydrostatic) then
    call g_geopk( ptop,pe,g_pe,peln,g_peln,delp,g_delp,pkc,g_pkc,gz,g_gz,phis,pt,g_pt,npz,akap,last_step, .false. , .false.  )
  else
    call g_update_dz_d( hord_tm,is,ie,js,je,npz,ng,npx,npy,area,zh,g_zh,crx,g_crx,cry,g_cry,xfx,g_xfx,yfx,g_yfx,delz,delzc,delpc,&
&g_delpc,n_sponge )
    call g_riem_solver( dt,is,ie,js,je,npz,ng,akap,cp,ptop,phis,peln,g_peln,w,g_w,delz,pt,g_pt,delp,g_delp,gz,g_gz,pkc,g_pkc,pk,&
&g_pk,pe,g_pe,last_step,m_grad_p )
    if (a2b_ord .eq. 4) then
      help_n = npz+1
      call g_mpp_update_domains_dummy( pkc,g_pkc,is,ie,js,je,isd,ied,jsd,jed,help_n )
      help_o = npz+1
      call g_mpp_update_domains_dummy( gz,g_gz,is,ie,js,je,isd,ied,jsd,jed,help_o )
    else
      help_p = npz+1
      call g_mpp_update_domains_dummy( pkc,g_pkc,is,ie,js,je,isd,ied,jsd,jed,help_p )
      help_q = npz+1
      call g_mpp_update_domains_dummy( gz,g_gz,is,ie,js,je,isd,ied,jsd,jed,help_q )
    endif
  endif
  if (last_step .and. hydrostatic) then
    do k = 1, npz+1
      do j = js, je
        do i = is, ie
          g_pk(i,j,k) = g_pkc(i,j,k)
          pk(i,j,k) = pkc(i,j,k)
        end do
      end do
    end do
  endif
  if (do_omega) then
    do k = 1, npz
      do j = js, je
        do i = is, ie
          g_omga(i,j,k) = g_pe(i,k+1,j)*rdt-g_pem(i,k+1,j)*rdt
          omga(i,j,k) = (pe(i,k+1,j)-pem(i,k+1,j))*rdt
        end do
      end do
    end do
    call g_adv_pe( ua,g_ua,va,g_va,pem,g_pem,omga,g_omga,npx,npy,npz,ng,it )
  endif
  if (( .not. hydrostatic) .and. m_grad_p .eq. 0) then
    allocate( g_pk3h(isd:ied,jsd:jed,1:npz+1) )
    g_pk3h = 0.
    call g_two_grad_p( u,g_u,v,g_v,pkc,g_pkc,gz,g_gz,delp,g_delp,pk3,g_pk3h,divg2,g_divg2,dt,ng,npx,npy,npz,ptk,it )
    deallocate( g_pk3h )
  else
    call g_one_grad_p( u,g_u,v,g_v,pkc,g_pkc,gz,g_gz,divg2,g_divg2,delp,g_delp,dt,ng,npx,npy,npz,ptop,ptk,hydrostatic,it )
  endif
  help_r = jed+1
  help_s = ied+1
  call g_mpp_update_domains_dgrid( u,g_u,v,g_v,is,ie,js,je,isd,ied,jsd,help_r,npz,is,ie,js,je,isd,help_s,jsd,jed,npz )
  if (last_step .and. grid_type .lt. 4) then
    help_t = jed+1
    help_u = ied+1
    call g_mpp_get_boundary_dgrid( u,g_u,v,g_v,is,ie,js,je,isd,ied,jsd,help_t,npz,is,ie,js,je,isd,help_u,jsd,jed,npz,npx,npy,npz,&
&is,ie,js,je )
  endif
end do

end subroutine g_dyn_core


subroutine g_geopk( ptop, pe, g_pe, peln, g_peln, delp, g_delp, pk, g_pk, gz, g_gz, hs, pt, g_pt, km, akap, last_call, dp_check, &
&cg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use g_a2b_edge_mod, only : g_a2b_ord2, g_a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: akap
logical, intent(in) :: cg
integer, intent(in) :: km
real, intent(inout) :: delp(isd:ied,jsd:jed,km)
logical, intent(in) :: dp_check
real, intent(inout) :: g_delp(isd:ied,jsd:jed,km)
real, intent(out) :: g_gz(isd:ied,jsd:jed,km+1)
real, intent(out) :: g_pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(out) :: g_peln(is:ie,km+1,js:je)
real, intent(out) :: g_pk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: g_pt(isd:ied,jsd:jed,km)
real, intent(out) :: gz(isd:ied,jsd:jed,km+1)
real, intent(in) :: hs(isd:ied,jsd:jed)
logical, intent(in) :: last_call
real, intent(out) :: pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(out) :: peln(is:ie,km+1,js:je)
real, intent(out) :: pk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,km)
real, intent(in) :: ptop

!==============================================
! declare local variables
!==============================================
real :: g_logp(is-2:ie+2)
real :: g_p1d(is-2:ie+2)
integer :: i
integer :: ifirst
integer :: ilast
integer :: j
integer :: jfirst
integer :: jlast
integer :: k
real :: logp(is-2:ie+2)
real :: p1d(is-2:ie+2)
real :: ptk

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
ptk = ptop**akap
ifirst = is-1
jfirst = js-1
ilast = ie+1
jlast = je+1
if (( .not. cg) .and. a2b_ord .eq. 4) then
  ifirst = is-2
  ilast = ie+2
  jfirst = js-2
  jlast = je+2
endif
do j = jfirst, jlast
  do i = ifirst, ilast
    g_p1d(i) = 0.
    p1d(i) = ptop
    g_pk(i,j,1) = 0.
    pk(i,j,1) = ptk
    g_gz(i,j,km+1) = 0.
    gz(i,j,km+1) = hs(i,j)
  end do
  if (last_call .and. j .gt. js-2 .and. j .lt. je+2) then
    do i = max(ifirst,is-1), min(ilast,ie+1)
      g_pe(i,1,j) = 0.
      pe(i,1,j) = ptop
    end do
  endif
  do k = 2, km+1
    do i = ifirst, ilast
      g_p1d(i) = g_delp(i,j,k-1)+g_p1d(i)
      p1d(i) = p1d(i)+delp(i,j,k-1)
      g_logp(i) = g_p1d(i)*(1./p1d(i))
      logp(i) = log(p1d(i))
      g_pk(i,j,k) = g_logp(i)*akap*exp(akap*logp(i))
      pk(i,j,k) = exp(akap*logp(i))
    end do
    if (last_call .and. j .gt. js-2 .and. j .lt. je+2) then
      do i = max(ifirst,is-1), min(ilast,ie+1)
        g_pe(i,k,j) = g_p1d(i)
        pe(i,k,j) = p1d(i)
      end do
      if (j .ge. js .and. j .le. je) then
        do i = is, ie
          g_peln(i,k,j) = g_logp(i)
          peln(i,k,j) = logp(i)
        end do
      endif
    endif
  end do
  do k = km, 1, -1
    do i = ifirst, ilast
      g_gz(i,j,k) = g_gz(i,j,k+1)+g_pk(i,j,k+1)*pt(i,j,k)-g_pk(i,j,k)*pt(i,j,k)+g_pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
      gz(i,j,k) = gz(i,j,k+1)+pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
    end do
  end do
end do

end subroutine g_geopk


subroutine g_one_grad_p( u, g_u, v, g_v, pkc, g_pkc, gz, g_gz, divg2, g_divg2, delp, g_delp, dt, ng, npx, npy, npz, ptop, ptk, &
&hydrostatic, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use g_a2b_edge_mod, only : g_a2b_ord2, g_a2b_ord4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(in) :: divg2(is:ie+1,js:je+1)
real, intent(in) :: dt
real, intent(inout) :: g_delp(isd:ied,jsd:jed,npz)
real, intent(in) :: g_divg2(is:ie+1,js:je+1)
real, intent(inout) :: g_gz(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: g_pkc(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
logical, intent(in) :: hydrostatic
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
real, intent(in) :: ptk
real, intent(in) :: ptop
integer :: taf_rec
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: g_wk(isd:ied,jsd:jed)
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: top_value
real :: wk(isd:ied,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
iep1 = ie+1
jep1 = je+1
if (hydrostatic) then
  top_value = ptk
else
  top_value = ptop
endif
do j = js, jep1
  do i = is, iep1
    g_pkc(i,j,1) = 0.
    pkc(i,j,1) = top_value
  end do
end do
do k = 2, npz+1
  if (a2b_ord .eq. 4) then
    call g_a2b_ord4( pkc(isd,jsd,k),g_pkc(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call g_a2b_ord2( pkc(isd,jsd,k),g_pkc(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz+1
  if (a2b_ord .eq. 4) then
    call g_a2b_ord4( gz(isd,jsd,k),g_gz(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call g_a2b_ord2( gz(isd,jsd,k),g_gz(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz
  if (hydrostatic) then
    do j = js, jep1
      do i = is, iep1
        g_wk(i,j) = g_pkc(i,j,k+1)-g_pkc(i,j,k)
        wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
      end do
    end do
  else
    if (a2b_ord .eq. 4) then
      call g_a2b_ord4( delp(isd,jsd,k),g_delp(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng )
    else
      call g_a2b_ord2( delp(isd,jsd,k),g_delp(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng )
    endif
  endif
  do j = js, jep1
    do i = is, ie
      g_u(i,j,k) = (-(g_divg2(i+1,j)*rdx(i,j)))+g_divg2(i,j)*rdx(i,j)-g_gz(i+1,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i,j,k+1)&
&-pkc(i+1,j,k))+g_gz(i,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))-g_gz(i+1,j,k)*rdx(i,j)*dt/(wk(i,j)+&
&wk(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))+g_gz(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))+g_pkc(i+1,j,&
&k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_pkc(i,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-&
&gz(i+1,j,k+1))-g_pkc(i+1,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))-g_pkc(i,j,k)*rdx(i,j)*dt/(wk(i,j)+&
&wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_u(i,j,k)*rdx(i,j)-g_wk(i+1,j)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*&
&((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))-g_wk(i,j)*&
&rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-&
&gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      u(i,j,k) = rdx(i,j)*(divg2(i,j)-divg2(i+1,j)+u(i,j,k)+dt/(wk(i,j)+wk(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-&
&pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k))))
    end do
  end do
  do j = js, je
    do i = is, iep1
      g_v(i,j,k) = (-(g_divg2(i,j+1)*rdy(i,j)))+g_divg2(i,j)*rdy(i,j)-g_gz(i,j+1,k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j,k+1)&
&-pkc(i,j+1,k))-g_gz(i,j+1,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))+g_gz(i,j,k+1)*rdy(i,j)*dt/(wk(i,j)+&
&wk(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))+g_gz(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))+g_pkc(i,j+1,&
&k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))-g_pkc(i,j+1,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-&
&gz(i,j+1,k+1))+g_pkc(i,j,k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))-g_pkc(i,j,k)*rdy(i,j)*dt/(wk(i,j)+&
&wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))+g_v(i,j,k)*rdy(i,j)-g_wk(i,j+1)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*&
&((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))-g_wk(i,j)*&
&rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-&
&gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      v(i,j,k) = rdy(i,j)*(divg2(i,j)-divg2(i,j+1)+v(i,j,k)+dt/(wk(i,j)+wk(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-&
&pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))))
    end do
  end do
end do

end subroutine g_one_grad_p


subroutine g_two_grad_p( u, g_u, v, g_v, pkc, g_pkc, gz, g_gz, delp, g_delp, pk3, g_pk3, divg2, g_divg2, dt, ng, npx, npy, npz, &
&ptk, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use g_a2b_edge_mod, only : g_a2b_ord2, g_a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(in) :: divg2(is:ie+1,js:je+1)
real, intent(in) :: dt
real, intent(inout) :: g_delp(isd:ied,jsd:jed,npz)
real, intent(in) :: g_divg2(is:ie+1,js:je+1)
real, intent(inout) :: g_gz(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: g_pk3(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: g_pkc(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: g_u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: g_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pk3(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
real, intent(in) :: ptk
integer :: taf_rec
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: g_wk(is:ie+1,js:je+1)
real :: g_wk1(isd:ied,jsd:jed)
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: wk(is:ie+1,js:je+1)
real :: wk1(isd:ied,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
iep1 = ie+1
jep1 = je+1
do j = js, jep1
  do i = is, iep1
    g_pkc(i,j,1) = 0.
    pkc(i,j,1) = 0.
    g_pk3(i,j,1) = 0.
    pk3(i,j,1) = ptk
  end do
end do
do k = 1, npz+1
  if (k .ne. 1) then
    if (a2b_ord .eq. 4) then
      call g_a2b_ord4( pkc(isd,jsd,k),g_pkc(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
      call g_a2b_ord4( pk3(isd,jsd,k),g_pk3(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
    else
      call g_a2b_ord2( pkc(isd,jsd,k),g_pkc(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
      call g_a2b_ord2( pk3(isd,jsd,k),g_pk3(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
    endif
  endif
  if (a2b_ord .eq. 4) then
    call g_a2b_ord4( gz(isd,jsd,k),g_gz(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call g_a2b_ord2( gz(isd,jsd,k),g_gz(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz
  if (a2b_ord .eq. 4) then
    call g_a2b_ord4( delp(isd,jsd,k),g_delp(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng )
  else
    call g_a2b_ord2( delp(isd,jsd,k),g_delp(isd,jsd,k),wk1,g_wk1,npx,npy,is,ie,js,je,ng )
  endif
  do j = js, jep1
    do i = is, iep1
      g_wk(i,j) = g_pk3(i,j,k+1)-g_pk3(i,j,k)
      wk(i,j) = pk3(i,j,k+1)-pk3(i,j,k)
    end do
  end do
  do j = js, jep1
    do i = is, ie
      g_u(i,j,k) = (-(g_gz(i+1,j,k+1)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))))+g_gz(i,j,k+1)*dt/(wk1(i,j)+wk1(i+1,j))&
&*(pkc(i+1,j,k+1)-pkc(i,j,k))-g_gz(i+1,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))+g_gz(i,j,k)*dt/(wk1(i,j)+&
&wk1(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))+g_pkc(i+1,j,k+1)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_pkc(i,j,k+1)*&
&dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))-g_pkc(i+1,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))-&
&g_pkc(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_u(i,j,k)-g_wk1(i+1,j)*dt/((wk1(i,j)+wk1(i+1,j))*(wk1(i,j)+&
&wk1(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))-&
&g_wk1(i,j)*dt/((wk1(i,j)+wk1(i+1,j))*(wk1(i,j)+wk1(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,&
&k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      u(i,j,k) = u(i,j,k)+dt/(wk1(i,j)+wk1(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))&
&*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      g_u(i,j,k) = (-(g_divg2(i+1,j)*rdx(i,j)))+g_divg2(i,j)*rdx(i,j)-g_gz(i+1,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i,j,k+1)&
&-pk3(i+1,j,k))+g_gz(i,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i+1,j,k+1)-pk3(i,j,k))-g_gz(i+1,j,k)*rdx(i,j)*dt/(wk(i,j)+&
&wk(i+1,j))*(pk3(i+1,j,k+1)-pk3(i,j,k))+g_gz(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i,j,k+1)-pk3(i+1,j,k))+g_pk3(i+1,j,&
&k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_pk3(i,j,k+1)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-&
&gz(i+1,j,k+1))-g_pk3(i+1,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))-g_pk3(i,j,k)*rdx(i,j)*dt/(wk(i,j)+&
&wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))+g_u(i,j,k)*rdx(i,j)-g_wk(i+1,j)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*&
&((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+1,j,k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k)))-g_wk(i,j)*&
&rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+1,j,k+1)-pk3(i,j,k))+(gz(i,j,k)-&
&gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k)))
      u(i,j,k) = rdx(i,j)*(divg2(i,j)-divg2(i+1,j)+u(i,j,k)+dt/(wk(i,j)+wk(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+1,j,k+1)-&
&pk3(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k))))
    end do
  end do
  do j = js, je
    do i = is, iep1
      g_v(i,j,k) = (-(g_gz(i,j+1,k+1)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))+g_gz(i,j+1,k)*dt/(wk1(i,j)+wk1(i,j+1))*&
&(pkc(i,j+1,k+1)-pkc(i,j,k))))+g_gz(i,j,k+1)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))+g_gz(i,j,k)*dt/(wk1(i,j)+&
&wk1(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))+g_pkc(i,j+1,k+1)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))-g_pkc(i,j+1,k)*&
&dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))+g_pkc(i,j,k+1)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))-&
&g_pkc(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))+g_v(i,j,k)-g_wk1(i,j+1)*dt/((wk1(i,j)+wk1(i,j+1))*(wk1(i,j)+&
&wk1(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))-&
&g_wk1(i,j)*dt/((wk1(i,j)+wk1(i,j+1))*(wk1(i,j)+wk1(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,&
&k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      v(i,j,k) = v(i,j,k)+dt/(wk1(i,j)+wk1(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))&
&*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      g_v(i,j,k) = (-(g_divg2(i,j+1)*rdy(i,j)))+g_divg2(i,j)*rdy(i,j)-g_gz(i,j+1,k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j,k+1)&
&-pk3(i,j+1,k))-g_gz(i,j+1,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j+1,k+1)-pk3(i,j,k))+g_gz(i,j,k+1)*rdy(i,j)*dt/(wk(i,j)+&
&wk(i,j+1))*(pk3(i,j+1,k+1)-pk3(i,j,k))+g_gz(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j,k+1)-pk3(i,j+1,k))+g_pk3(i,j+1,&
&k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))-g_pk3(i,j+1,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-&
&gz(i,j+1,k+1))+g_pk3(i,j,k+1)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))-g_pk3(i,j,k)*rdy(i,j)*dt/(wk(i,j)+&
&wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))+g_v(i,j,k)*rdy(i,j)-g_wk(i,j+1)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*&
&((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,j+1,k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k)))-g_wk(i,j)*&
&rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,j+1,k+1)-pk3(i,j,k))+(gz(i,j,k)-&
&gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k)))
      v(i,j,k) = rdy(i,j)*(divg2(i,j)-divg2(i,j+1)+v(i,j,k)+dt/(wk(i,j)+wk(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,j+1,k+1)-&
&pk3(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k))))
    end do
  end do
end do

end subroutine g_two_grad_p


end module     g_dyn_core_mod


