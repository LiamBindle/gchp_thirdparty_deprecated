!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.28
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_tp_core_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.30  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use pre_direct_new
use fv_mp_mod, only : ie,ied,is,isd,je,jed,js,jsd,ng
use fv_grid_utils_mod, only : cx1,cx2,cy1,cy2,ne_corner,nw_corner,se_corner,sw_corner
use fv_grid_tools_mod, only : dxa,dya,grid_type
use tp_core_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine g_copy_corners( q, g_q, npx, npy, dir )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: dir
real, intent(inout) :: g_q(isd:ied,jsd:jed)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: j

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (dir .eq. 1) then
  if (sw_corner) then
    do j = 1-ng, 0
      do i = 1-ng, 0
        g_q(i,j) = g_q(j,1-i)
        q(i,j) = q(j,1-i)
      end do
    end do
  endif
  if (se_corner) then
    do j = 1-ng, 0
      do i = npx, npx+ng-1
        g_q(i,j) = g_q(npy-j,1+i-npx)
        q(i,j) = q(npy-j,1+i-npx)
      end do
    end do
  endif
  if (ne_corner) then
    do j = npy, npy+ng-1
      do i = npx, npx+ng-1
        g_q(i,j) = g_q(j,2*npx-1-i)
        q(i,j) = q(j,2*npx-1-i)
      end do
    end do
  endif
  if (nw_corner) then
    do j = npy, npy+ng-1
      do i = 1-ng, 0
        g_q(i,j) = g_q(npy-j,i-1+npx)
        q(i,j) = q(npy-j,i-1+npx)
      end do
    end do
  endif
else if (dir .eq. 2) then
  if (sw_corner) then
    do j = 1-ng, 0
      do i = 1-ng, 0
        g_q(i,j) = g_q(1-j,i)
        q(i,j) = q(1-j,i)
      end do
    end do
  endif
  if (se_corner) then
    do j = 1-ng, 0
      do i = npx, npx+ng-1
        g_q(i,j) = g_q(npy+j-1,npx-i)
        q(i,j) = q(npy+j-1,npx-i)
      end do
    end do
  endif
  if (ne_corner) then
    do j = npy, npy+ng-1
      do i = npx, npx+ng-1
        g_q(i,j) = g_q(2*npy-1-j,i)
        q(i,j) = q(2*npy-1-j,i)
      end do
    end do
  endif
  if (nw_corner) then
    do j = npy, npy+ng-1
      do i = 1-ng, 0
        g_q(i,j) = g_q(1+j-npx,npy-i)
        q(i,j) = q(1+j-npx,npy-i)
      end do
    end do
  endif
endif

end subroutine g_copy_corners


subroutine g_fv_tp_2d( q, g_q, crx, g_crx, cry, g_cry, npx, npy, hord, fx, g_fx, fy, g_fy, xfx, g_xfx, yfx, g_yfx, area, ra_x, &
&g_ra_x, ra_y, g_ra_y, uni_ppm, mfx, g_mfx, mfy, g_mfy, taf_tp_core, fv_tp_2d_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: area(isd:ied,jsd:jed)
real, intent(inout) :: crx(is:ie+1,jsd:jed)
real, intent(inout) :: cry(isd:ied,js:je+1)
integer :: fv_tp_2d_rec
real, intent(out) :: fx(is:ie+1,js:je)
real, intent(out) :: fy(is:ie,js:je+1)
real, intent(inout) :: g_crx(is:ie+1,jsd:jed)
real, intent(inout) :: g_cry(isd:ied,js:je+1)
real, intent(out) :: g_fx(is:ie+1,js:je)
real, intent(out) :: g_fy(is:ie,js:je+1)
real, intent(inout) :: g_mfx(is:ie+1,js:je)
real, intent(inout) :: g_mfy(is:ie,js:je+1)
real, intent(inout) :: g_q(isd:ied,jsd:jed)
real, intent(in) :: g_ra_x(is:ie,jsd:jed)
real, intent(in) :: g_ra_y(isd:ied,js:je)
real, intent(inout) :: g_xfx(is:ie+1,jsd:jed)
real, intent(inout) :: g_yfx(isd:ied,js:je+1)
integer, intent(in) :: hord
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed)
real, intent(in) :: ra_x(is:ie,jsd:jed)
real, intent(in) :: ra_y(isd:ied,js:je)
logical :: taf_tp_core
logical, intent(in) :: uni_ppm
real, intent(inout) :: xfx(is:ie+1,jsd:jed)
real, intent(inout) :: yfx(isd:ied,js:je+1)

!==============================================
! declare local variables
!==============================================
real :: fx1(is:ie+1)
real :: fx2(is:ie+1,jsd:jed)
real :: fy2(isd:ied,js:je+1)
real :: fyy(isd:ied,js:je+1)
real :: g_fx1(is:ie+1)
real :: g_fx2(is:ie+1,jsd:jed)
real :: g_fy2(isd:ied,js:je+1)
real :: g_fyy(isd:ied,js:je+1)
real :: g_q_i(isd:ied,js:je)
real :: g_q_j(is:ie,jsd:jed)
integer :: i
integer :: j
real :: q_i(isd:ied,js:je)
real :: q_j(is:ie,jsd:jed)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call g_copy_corners( q,g_q,npx,npy,2 )
call g_ytp( fy2,g_fy2,q,g_q,cry,g_cry,hord,isd,ied,js,je,npx,npy,uni_ppm )
do j = js, je+1
  do i = isd, ied
    g_fyy(i,j) = g_fy2(i,j)*yfx(i,j)+g_yfx(i,j)*fy2(i,j)
    fyy(i,j) = yfx(i,j)*fy2(i,j)
  end do
end do
do j = js, je
  do i = isd, ied
    g_q_i(i,j) = (-(g_fyy(i,j+1)/ra_y(i,j)))+g_fyy(i,j)/ra_y(i,j)+g_q(i,j)*(area(i,j)/ra_y(i,j))-g_ra_y(i,j)*((q(i,j)*area(i,j)+&
&fyy(i,j)-fyy(i,j+1))/(ra_y(i,j)*ra_y(i,j)))
    q_i(i,j) = (q(i,j)*area(i,j)+fyy(i,j)-fyy(i,j+1))/ra_y(i,j)
  end do
end do
call g_xtp( fx,g_fx,q_i,g_q_i,crx(is,js),g_crx(is,js),hord,is,ie,js,je,npx,npy,uni_ppm )
call g_copy_corners( q,g_q,npx,npy,1 )
call g_xtp( fx2,g_fx2,q,g_q,crx,g_crx,hord,is,ie,jsd,jed,npx,npy,uni_ppm )
do j = jsd, jed
  do i = is, ie+1
    g_fx1(i) = g_fx2(i,j)*xfx(i,j)+g_xfx(i,j)*fx2(i,j)
    fx1(i) = xfx(i,j)*fx2(i,j)
  end do
  do i = is, ie
    g_q_j(i,j) = (-(g_fx1(i+1)/ra_x(i,j)))+g_fx1(i)/ra_x(i,j)+g_q(i,j)*(area(i,j)/ra_x(i,j))-g_ra_x(i,j)*((q(i,j)*area(i,j)+fx1(i)-&
&fx1(i+1))/(ra_x(i,j)*ra_x(i,j)))
    q_j(i,j) = (q(i,j)*area(i,j)+fx1(i)-fx1(i+1))/ra_x(i,j)
  end do
end do
call g_ytp( fy,g_fy,q_j,g_q_j,cry,g_cry,hord,is,ie,js,je,npx,npy,uni_ppm )
if (taf_tp_core .eq. ( .true. )) then
  do j = js, je
    do i = is, ie+1
      g_fx(i,j) = 0.5*g_fx(i,j)*mfx(i,j)+0.5*g_fx2(i,j)*mfx(i,j)+0.5*g_mfx(i,j)*(fx(i,j)+fx2(i,j))
      fx(i,j) = 0.5*(fx(i,j)+fx2(i,j))*mfx(i,j)
    end do
  end do
  do j = js, je+1
    do i = is, ie
      g_fy(i,j) = 0.5*g_fy(i,j)*mfy(i,j)+0.5*g_fy2(i,j)*mfy(i,j)+0.5*g_mfy(i,j)*(fy(i,j)+fy2(i,j))
      fy(i,j) = 0.5*(fy(i,j)+fy2(i,j))*mfy(i,j)
    end do
  end do
else
  do j = js, je
    do i = is, ie+1
      g_fx(i,j) = 0.5*g_fx(i,j)*xfx(i,j)+0.5*g_fx2(i,j)*xfx(i,j)+0.5*g_xfx(i,j)*(fx(i,j)+fx2(i,j))
      fx(i,j) = 0.5*(fx(i,j)+fx2(i,j))*xfx(i,j)
    end do
  end do
  do j = js, je+1
    do i = is, ie
      g_fy(i,j) = 0.5*g_fy(i,j)*yfx(i,j)+0.5*g_fy2(i,j)*yfx(i,j)+0.5*g_yfx(i,j)*(fy(i,j)+fy2(i,j))
      fy(i,j) = 0.5*(fy(i,j)+fy2(i,j))*yfx(i,j)
    end do
  end do
endif

end subroutine g_fv_tp_2d


subroutine g_fxppm( c, g_c, q, g_q, flux, g_flux, iord, ifirst, ilast, jfirst, jlast, npx, npy, uniform_ppm )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: b1 = 1./30.
real, parameter :: b2 = -(13./60.)
real, parameter :: b3 = -(13./60.)
real, parameter :: b4 = 0.45
real, parameter :: b5 = -0.05
real, parameter :: r3 = 1./3.
real, parameter :: s11 = 11./14.
real, parameter :: s14 = 4./7.
real, parameter :: s15 = 3./14.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real, intent(in) :: c(ifirst:ilast+1,jfirst:jlast)
real, intent(out) :: flux(ifirst:ilast+1,jfirst:jlast)
real, intent(in) :: g_c(ifirst:ilast+1,jfirst:jlast)
real, intent(out) :: g_flux(ifirst:ilast+1,jfirst:jlast)
real, intent(in) :: g_q(ifirst-ng:ilast+ng,jfirst:jlast)
integer, intent(in) :: iord
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(in) :: q(ifirst-ng:ilast+ng,jfirst:jlast)
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: al(ifirst-1:ilast+2)
real :: bl(ifirst-1:ilast+1)
real :: bl0
real :: bl1
real :: bl2
real :: bl3
real :: bl4
real :: bl5
real :: bl6
real :: bl7
real :: bl8
real :: bl9
real :: blaa
real :: blab
real :: blac
real :: blad
real :: blae
real :: blh
real :: bli
real :: blj
real :: blk
real :: bll
real :: blm
real :: bln
real :: blo
real :: blp
real :: blq
real :: blr
real :: bls
real :: blt
real :: blu
real :: blv
real :: blw
real :: blx
real :: bly
real :: blz
real :: br(ifirst-1:ilast+1)
real :: br0
real :: br1
real :: br2
real :: br3
real :: br4
real :: br5
real :: br6
real :: br7
real :: br8
real :: br9
real :: braa
real :: brab
real :: brac
real :: brad
real :: brae
real :: brh
real :: bri
real :: brj
real :: brk
real :: brl
real :: brm
real :: brn
real :: bro
real :: brp
real :: brq
real :: brr
real :: brs
real :: brt
real :: bru
real :: brv
real :: brw
real :: brx
real :: bry
real :: brz
real :: c1
real :: dl
real :: dlh
real :: dli
real :: dlj
real :: dlk
real :: dll
real :: dm1(ifirst-2:ilast+2)
real :: dm10
real :: dm11
real :: dm12
real :: dm13
real :: dm14
real :: dm15
real :: dm16
real :: dm17
real :: dm18
real :: dm19
real :: dm1aa
real :: dm1ab
real :: dm1ac
real :: dm1ad
real :: dm1ae
real :: dm1af
real :: dm1ag
real :: dm1ah
real :: dm1ai
real :: dm1aj
real :: dm1ak
real :: dm1am
real :: dm1an
real :: dm1ap
real :: dm1aq
real :: dm1ar
real :: dm1h
real :: dm1i
real :: dm1j
real :: dm1k
real :: dm1l
real :: dm1m
real :: dm1n
real :: dm1o
real :: dm1p
real :: dm1q
real :: dm1r
real :: dm1s
real :: dm1t
real :: dm1u
real :: dm1v
real :: dm1w
real :: dm1x
real :: dm1y
real :: dm1z
real :: dq(ifirst-3:ilast+2)
real :: dr
real :: drh
real :: dri
real :: drj
real :: drk
real :: drl
real :: g_al(ifirst-1:ilast+2)
real :: g_bl(ifirst-1:ilast+1)
real :: g_bl0
real :: g_bl1
real :: g_bl2
real :: g_bl3
real :: g_bl4
real :: g_bl5
real :: g_bl6
real :: g_bl7
real :: g_bl8
real :: g_bl9
real :: g_blaa
real :: g_blab
real :: g_blac
real :: g_blad
real :: g_blae
real :: g_bli
real :: g_blj
real :: g_blk
real :: g_bll
real :: g_blm
real :: g_bln
real :: g_blp
real :: g_blq
real :: g_blr
real :: g_bls
real :: g_blt
real :: g_blu
real :: g_blv
real :: g_blw
real :: g_blx
real :: g_bly
real :: g_blz
real :: g_br(ifirst-1:ilast+1)
real :: g_br0
real :: g_br1
real :: g_br2
real :: g_br3
real :: g_br4
real :: g_br5
real :: g_br6
real :: g_br7
real :: g_br8
real :: g_br9
real :: g_braa
real :: g_brab
real :: g_brac
real :: g_brad
real :: g_brae
real :: g_brh
real :: g_bri
real :: g_brj
real :: g_brk
real :: g_brl
real :: g_brm
real :: g_brn
real :: g_bro
real :: g_brp
real :: g_brq
real :: g_brr
real :: g_brs
real :: g_brt
real :: g_bru
real :: g_brv
real :: g_brw
real :: g_brx
real :: g_bry
real :: g_brz
real :: g_c1
real :: g_dl
real :: g_dlh
real :: g_dli
real :: g_dlj
real :: g_dlk
real :: g_dm1(ifirst-2:ilast+2)
real :: g_dm10
real :: g_dm11
real :: g_dm12
real :: g_dm13
real :: g_dm14
real :: g_dm15
real :: g_dm16
real :: g_dm17
real :: g_dm18
real :: g_dm19
real :: g_dm1aa
real :: g_dm1ab
real :: g_dm1ac
real :: g_dm1ad
real :: g_dm1ae
real :: g_dm1af
real :: g_dm1ag
real :: g_dm1ah
real :: g_dm1ai
real :: g_dm1aj
real :: g_dm1ak
real :: g_dm1am
real :: g_dm1an
real :: g_dm1ap
real :: g_dm1aq
real :: g_dm1ar
real :: g_dm1h
real :: g_dm1i
real :: g_dm1j
real :: g_dm1k
real :: g_dm1l
real :: g_dm1m
real :: g_dm1n
real :: g_dm1o
real :: g_dm1p
real :: g_dm1q
real :: g_dm1r
real :: g_dm1s
real :: g_dm1t
real :: g_dm1u
real :: g_dm1v
real :: g_dm1w
real :: g_dm1x
real :: g_dm1y
real :: g_dm1z
real :: g_dq(ifirst-3:ilast+2)
real :: g_dr
real :: g_drh
real :: g_dri
real :: g_drj
real :: g_drk
real :: g_drl
real :: g_lac
real :: g_pmp
real :: g_qe
real :: g_xt
integer :: help_h
integer :: help_i
integer :: i
integer :: ie3
integer :: is3
integer :: it
integer :: j
real :: lac
real :: pmp
real :: qe
real :: xt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (iord .le. 4) then
  do j = jfirst, jlast
    if (uniform_ppm) then
      do i = ifirst-2, ilast+2
        g_xt = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
        xt = 0.25*(q(i+1,j)-q(i-1,j))
        g_dm1t = g_xt*sign(1.,xt)
        dm1t = abs(xt)
        g_dm1u = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
        dm1u = max(q(i-1,j),q(i,j))
        g_dm1w = g_dm1u*(0.5+sign(0.5,dm1u-q(i+1,j)))+g_q(i+1,j)*(0.5-sign(0.5,dm1u-q(i+1,j)))-g_q(i,j)
        dm1w = max(dm1u,q(i+1,j))-q(i,j)
        g_dm1x = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
        dm1x = min(q(i-1,j),q(i,j))
        g_dm1z = (-(g_dm1x*(0.5+sign(0.5,q(i+1,j)-dm1x))+g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-dm1x))))+g_q(i,j)
        dm1z = q(i,j)-min(dm1x,q(i+1,j))
        g_dm10 = g_dm1t*(0.5+sign(0.5,dm1w-dm1t))+g_dm1w*(0.5-sign(0.5,dm1w-dm1t))
        dm10 = min(dm1t,dm1w)
        g_dm11 = g_dm10*(0.5+sign(0.5,dm1z-dm10))+g_dm1z*(0.5-sign(0.5,dm1z-dm10))
        dm11 = min(dm10,dm1z)
        g_dm1(i) = g_dm11*sign(1.,dm11)*sign(1.,xt)
        dm1(i) = sign(dm11,xt)
      end do
    else
      do i = ifirst-3, ilast+2
        g_dq(i) = g_q(i+1,j)-g_q(i,j)
        dq(i) = q(i+1,j)-q(i,j)
      end do
      do i = ifirst-2, ilast+2
        g_xt = g_dq(i-1)*cx1(i,j)+g_dq(i)*cx2(i,j)
        xt = cx1(i,j)*dq(i-1)+cx2(i,j)*dq(i)
        g_dm1j = g_xt*sign(1.,xt)
        dm1j = abs(xt)
        g_dm1m = g_dq(i-1)*sign(1.,dq(i-1))
        dm1m = abs(dq(i-1))
        g_dm1q = g_dq(i)*sign(1.,dq(i))
        dm1q = abs(dq(i))
        g_dm1r = g_dm1j*(0.5+sign(0.5,dm1m-dm1j))+g_dm1m*(0.5-sign(0.5,dm1m-dm1j))
        dm1r = min(dm1j,dm1m)
        g_dm1s = g_dm1q*(0.5-sign(0.5,dm1q-dm1r))+g_dm1r*(0.5+sign(0.5,dm1q-dm1r))
        dm1s = min(dm1r,dm1q)
        g_dm1(i) = g_dm1s*sign(1.,dm1s)*sign(1.,xt)
        dm1(i) = sign(dm1s,xt)
      end do
    endif
    do i = ifirst-1, ilast+2
      g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
      al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
    end do
    do i = ifirst, ilast+1
      if (c(i,j) .gt. 0.) then
        g_xt = 2*g_dm1(i-1)
        xt = 2.*dm1(i-1)
        g_dlk = g_al(i-1)-g_q(i-1,j)
        dlk = al(i-1)-q(i-1,j)
        g_dlj = g_dlk*(0.5-sign(0.5,abs(dlk)-abs(xt)))*sign(1.,dlk)+g_xt*(0.5+sign(0.5,abs(dlk)-abs(xt)))*sign(1.,xt)
        dlj = min(abs(xt),abs(dlk))
        g_dl = g_dlj*sign(1.,dlj)*sign(1.,xt)
        dl = sign(dlj,xt)
        g_drk = g_al(i)-g_q(i-1,j)
        drk = al(i)-q(i-1,j)
        g_drj = g_drk*(0.5-sign(0.5,abs(drk)-abs(xt)))*sign(1.,drk)+g_xt*(0.5+sign(0.5,abs(drk)-abs(xt)))*sign(1.,xt)
        drj = min(abs(xt),abs(drk))
        g_dr = g_drj*sign(1.,drj)*sign(1.,xt)
        dr = sign(drj,xt)
        g_flux(i,j) = g_c(i,j)*((1.-c(i,j))*(dl-dr)-(c(i,j)*(dl-dr)+dr))+g_dl*(1.-c(i,j))*c(i,j)+g_dr*(1.-c(i,j))*(1-c(i,j))+g_q(i-&
&1,j)
        flux(i,j) = q(i-1,j)+(1.-c(i,j))*(c(i,j)*(dl-dr)+dr)
      else
        g_xt = 2*g_dm1(i)
        xt = 2.*dm1(i)
        g_dli = g_al(i)-g_q(i,j)
        dli = al(i)-q(i,j)
        g_dlh = g_dli*(0.5-sign(0.5,abs(dli)-abs(xt)))*sign(1.,dli)+g_xt*(0.5+sign(0.5,abs(dli)-abs(xt)))*sign(1.,xt)
        dlh = min(abs(xt),abs(dli))
        g_dl = g_dlh*sign(1.,dlh)*sign(1.,xt)
        dl = sign(dlh,xt)
        g_dri = g_al(i+1)-g_q(i,j)
        dri = al(i+1)-q(i,j)
        g_drh = g_dri*(0.5-sign(0.5,abs(dri)-abs(xt)))*sign(1.,dri)+g_xt*(0.5+sign(0.5,abs(dri)-abs(xt)))*sign(1.,xt)
        drh = min(abs(xt),abs(dri))
        g_dr = g_drh*sign(1.,drh)*sign(1.,xt)
        dr = sign(drh,xt)
        g_flux(i,j) = (-(g_c(i,j)*((1.+2*c(i,j))*(dl-dr)+dl)+g_dl*(1.+c(i,j))*(1+c(i,j))))+g_dr*(1.+c(i,j))*c(i,j)+g_q(i,j)
        flux(i,j) = q(i,j)-(1.+c(i,j))*(c(i,j)*(dl-dr)+dl)
      endif
    end do
  end do
else if (iord .eq. 5) then
  do j = jfirst, jlast
    do i = ifirst-3, ilast+2
      g_dq(i) = g_q(i+1,j)-g_q(i,j)
      dq(i) = q(i+1,j)-q(i,j)
    end do
    if (uniform_ppm) then
      do i = ifirst-2, ilast+2
        g_xt = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
        xt = 0.25*(q(i+1,j)-q(i-1,j))
        g_dm1aj = g_xt*sign(1.,xt)
        dm1aj = abs(xt)
        g_dm1ak = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
        dm1ak = max(q(i-1,j),q(i,j))
        g_dm1am = g_dm1ak*(0.5+sign(0.5,dm1ak-q(i+1,j)))+g_q(i+1,j)*(0.5-sign(0.5,dm1ak-q(i+1,j)))-g_q(i,j)
        dm1am = max(dm1ak,q(i+1,j))-q(i,j)
        g_dm1an = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
        dm1an = min(q(i-1,j),q(i,j))
        g_dm1ap = (-(g_dm1an*(0.5+sign(0.5,q(i+1,j)-dm1an))+g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-dm1an))))+g_q(i,j)
        dm1ap = q(i,j)-min(dm1an,q(i+1,j))
        g_dm1aq = g_dm1aj*(0.5+sign(0.5,dm1am-dm1aj))+g_dm1am*(0.5-sign(0.5,dm1am-dm1aj))
        dm1aq = min(dm1aj,dm1am)
        g_dm1ar = g_dm1ap*(0.5-sign(0.5,dm1ap-dm1aq))+g_dm1aq*(0.5+sign(0.5,dm1ap-dm1aq))
        dm1ar = min(dm1aq,dm1ap)
        g_dm1(i) = g_dm1ar*sign(1.,dm1ar)*sign(1.,xt)
        dm1(i) = sign(dm1ar,xt)
      end do
    else
      do i = ifirst-2, ilast+2
        g_xt = g_dq(i-1)*cx1(i,j)+g_dq(i)*cx2(i,j)
        xt = cx1(i,j)*dq(i-1)+cx2(i,j)*dq(i)
        g_dm19 = g_xt*sign(1.,xt)
        dm19 = abs(xt)
        g_dm1ac = g_dq(i-1)*sign(1.,dq(i-1))
        dm1ac = abs(dq(i-1))
        g_dm1ag = g_dq(i)*sign(1.,dq(i))
        dm1ag = abs(dq(i))
        g_dm1ah = g_dm19*(0.5+sign(0.5,dm1ac-dm19))+g_dm1ac*(0.5-sign(0.5,dm1ac-dm19))
        dm1ah = min(dm19,dm1ac)
        g_dm1ai = g_dm1ag*(0.5-sign(0.5,dm1ag-dm1ah))+g_dm1ah*(0.5+sign(0.5,dm1ag-dm1ah))
        dm1ai = min(dm1ah,dm1ag)
        g_dm1(i) = g_dm1ai*sign(1.,dm1ai)*sign(1.,xt)
        dm1(i) = sign(dm1ai,xt)
      end do
    endif
    do i = ifirst-1, ilast+2
      g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
      al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
    end do
    do i = ifirst-1, ilast+1
      g_pmp = (-2)*g_dq(i)
      pmp = -(2.*dq(i))
      g_lac = 1.5*g_dq(i+1)+g_pmp
      lac = pmp+1.5*dq(i+1)
      g_blaa = g_pmp*(0.5-sign(0.5,0.-pmp))
      blaa = max(0.,pmp)
      g_blab = g_blaa*(0.5+sign(0.5,blaa-lac))+g_lac*(0.5-sign(0.5,blaa-lac))
      blab = max(blaa,lac)
      g_blad = g_pmp*(0.5-sign(0.5,pmp-0.))
      blad = min(0.,pmp)
      g_blae = g_blad*(0.5+sign(0.5,lac-blad))+g_lac*(0.5-sign(0.5,lac-blad))
      blae = min(blad,lac)
      g_blac = g_al(i)*(0.5+sign(0.5,al(i)-q(i,j)-blae))+g_blae*(0.5-sign(0.5,al(i)-q(i,j)-blae))-g_q(i,j)*(0.5+sign(0.5,al(i)-q(i,&
&j)-blae))
      blac = max(al(i)-q(i,j),blae)
      g_bl(i) = g_blab*(0.5+sign(0.5,blac-blab))+g_blac*(0.5-sign(0.5,blac-blab))
      bl(i) = min(blab,blac)
      g_pmp = 2*g_dq(i-1)
      pmp = 2.*dq(i-1)
      g_lac = (-1.5)*g_dq(i-2)+g_pmp
      lac = pmp-1.5*dq(i-2)
      g_braa = g_pmp*(0.5-sign(0.5,0.-pmp))
      braa = max(0.,pmp)
      g_brab = g_braa*(0.5+sign(0.5,braa-lac))+g_lac*(0.5-sign(0.5,braa-lac))
      brab = max(braa,lac)
      g_brad = g_pmp*(0.5-sign(0.5,pmp-0.))
      brad = min(0.,pmp)
      g_brae = g_brad*(0.5+sign(0.5,lac-brad))+g_lac*(0.5-sign(0.5,lac-brad))
      brae = min(brad,lac)
      g_brac = g_al(i+1)*(0.5+sign(0.5,al(i+1)-q(i,j)-brae))+g_brae*(0.5-sign(0.5,al(i+1)-q(i,j)-brae))-g_q(i,j)*(0.5+sign(0.5,&
&al(i+1)-q(i,j)-brae))
      brac = max(al(i+1)-q(i,j),brae)
      g_br(i) = g_brab*(0.5+sign(0.5,brac-brab))+g_brac*(0.5-sign(0.5,brac-brab))
      br(i) = min(brab,brac)
    end do
    do i = ifirst, ilast+1
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i-1)*(1.-c(i,j))*c(i,j)))+g_br(i-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i-1)+br(i-1))+&
&br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))+g_q(i-1,j)
        flux(i,j) = q(i-1,j)+(1.-c(i,j))*(br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))
      else
        g_flux(i,j) = g_bl(i)*(1.+c(i,j))*(1+c(i,j))+g_br(i)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i)+br(i))+bl(i)+c(i,j)*&
&(bl(i)+br(i)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i)+c(i,j)*(bl(i)+br(i)))
      endif
    end do
  end do
else if (iord .eq. 6 .or. iord .eq. 7) then
  do j = jfirst, jlast
    do i = ifirst-1, ilast+1
      g_xt = g_q(i,j)*b3
      xt = b3*q(i,j)
      g_bl(i) = g_q(i-2,j)*b5+g_q(i-1,j)*b4+g_q(i+2,j)*b1+g_q(i+1,j)*b2+g_xt
      bl(i) = b5*q(i-2,j)+b4*q(i-1,j)+xt+b2*q(i+1,j)+b1*q(i+2,j)
      g_br(i) = g_q(i-2,j)*b1+g_q(i-1,j)*b2+g_q(i+2,j)*b5+g_q(i+1,j)*b4+g_xt
      br(i) = b1*q(i-2,j)+b2*q(i-1,j)+xt+b4*q(i+1,j)+b5*q(i+2,j)
    end do
    if (iord .eq. 7) then
      do i = ifirst-2, ilast+3
        g_dq(i) = (-g_q(i-1,j))+g_q(i,j)
        dq(i) = q(i,j)-q(i-1,j)
      end do
      do i = ifirst-1, ilast+1
        dll = min(abs(bl(i)),abs(dq(i)))
        g_dl = -((g_bl(i)*(0.5+sign(0.5,abs(dq(i))-abs(bl(i))))*sign(1.,bl(i))+g_dq(i)*(0.5-sign(0.5,abs(dq(i))-abs(bl(i))))*&
&sign(1.,dq(i)))*sign(1.,dll)*sign(1.,dq(i)))
        dl = -sign(dll,dq(i))
        g_pmp = (-2)*g_dq(i+1)
        pmp = -(2.*dq(i+1))
        g_lac = 1.5*g_dq(i+2)+g_pmp
        lac = pmp+1.5*dq(i+2)
        g_bl5 = g_pmp*(0.5-sign(0.5,0.-pmp))
        bl5 = max(0.,pmp)
        g_bl6 = g_bl5*(0.5+sign(0.5,bl5-lac))+g_lac*(0.5-sign(0.5,bl5-lac))
        bl6 = max(bl5,lac)
        g_bl8 = g_pmp*(0.5-sign(0.5,pmp-0.))
        bl8 = min(0.,pmp)
        g_bl9 = g_bl8*(0.5+sign(0.5,lac-bl8))+g_lac*(0.5-sign(0.5,lac-bl8))
        bl9 = min(bl8,lac)
        g_bl7 = g_bl9*(0.5-sign(0.5,dl-bl9))+g_dl*(0.5+sign(0.5,dl-bl9))
        bl7 = max(dl,bl9)
        g_bl(i) = g_bl6*(0.5+sign(0.5,bl7-bl6))+g_bl7*(0.5-sign(0.5,bl7-bl6))
        bl(i) = min(bl6,bl7)
        g_drl = g_br(i)*(0.5+sign(0.5,abs(dq(i+1))-abs(br(i))))*sign(1.,br(i))+g_dq(i+1)*(0.5-sign(0.5,abs(dq(i+1))-abs(br(i))))*&
&sign(1.,dq(i+1))
        drl = min(abs(br(i)),abs(dq(i+1)))
        g_dr = g_drl*sign(1.,drl)*sign(1.,dq(i+1))
        dr = sign(drl,dq(i+1))
        g_pmp = 2*g_dq(i)
        pmp = 2.*dq(i)
        g_lac = (-1.5)*g_dq(i-1)+g_pmp
        lac = pmp-1.5*dq(i-1)
        g_br5 = g_pmp*(0.5-sign(0.5,0.-pmp))
        br5 = max(0.,pmp)
        g_br6 = g_br5*(0.5+sign(0.5,br5-lac))+g_lac*(0.5-sign(0.5,br5-lac))
        br6 = max(br5,lac)
        g_br8 = g_pmp*(0.5-sign(0.5,pmp-0.))
        br8 = min(0.,pmp)
        g_br9 = g_br8*(0.5+sign(0.5,lac-br8))+g_lac*(0.5-sign(0.5,lac-br8))
        br9 = min(br8,lac)
        g_br7 = g_br9*(0.5-sign(0.5,dr-br9))+g_dr*(0.5+sign(0.5,dr-br9))
        br7 = max(dr,br9)
        g_br(i) = g_br6*(0.5+sign(0.5,br7-br6))+g_br7*(0.5-sign(0.5,br7-br6))
        br(i) = min(br6,br7)
      end do
    endif
    do i = ifirst, ilast+1
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i-1)*(1.-c(i,j))*c(i,j)))+g_br(i-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i-1)+br(i-1))+&
&br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))+g_q(i-1,j)
        flux(i,j) = q(i-1,j)+(1.-c(i,j))*(br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))
      else
        g_flux(i,j) = g_bl(i)*(1.+c(i,j))*(1+c(i,j))+g_br(i)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i)+br(i))+bl(i)+c(i,j)*&
&(bl(i)+br(i)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i)+c(i,j)*(bl(i)+br(i)))
      endif
    end do
  end do
else if (iord .le. 10) then
  is3 = max(3,is-1)
  ie3 = min(npx-3,ie+1)
  do j = jfirst, jlast
    if (grid_type .lt. 3) then
      do i = is-3, ie+2
        g_dq(i) = g_q(i+1,j)-g_q(i,j)
        dq(i) = q(i+1,j)-q(i,j)
      end do
      do i = is-2, ie+2
        g_xt = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
        xt = 0.25*(q(i+1,j)-q(i-1,j))
        g_dm12 = g_xt*sign(1.,xt)
        dm12 = abs(xt)
        g_dm15 = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
        dm15 = max(q(i-1,j),q(i,j))
        g_dm1aa = g_dm15*(0.5+sign(0.5,dm15-q(i+1,j)))+g_q(i+1,j)*(0.5-sign(0.5,dm15-q(i+1,j)))-g_q(i,j)
        dm1aa = max(dm15,q(i+1,j))-q(i,j)
        g_dm1ab = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
        dm1ab = min(q(i-1,j),q(i,j))
        g_dm1ad = (-(g_dm1ab*(0.5+sign(0.5,q(i+1,j)-dm1ab))+g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-dm1ab))))+g_q(i,j)
        dm1ad = q(i,j)-min(dm1ab,q(i+1,j))
        g_dm1ae = g_dm12*(0.5+sign(0.5,dm1aa-dm12))+g_dm1aa*(0.5-sign(0.5,dm1aa-dm12))
        dm1ae = min(dm12,dm1aa)
        g_dm1af = g_dm1ad*(0.5-sign(0.5,dm1ad-dm1ae))+g_dm1ae*(0.5+sign(0.5,dm1ad-dm1ae))
        dm1af = min(dm1ae,dm1ad)
        g_dm1(i) = g_dm1af*sign(1.,dm1af)*sign(1.,xt)
        dm1(i) = sign(dm1af,xt)
      end do
      do i = is3, min(npx-2,ie+2)
        g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
        al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
      end do
      do i = is3, ie3
        g_pmp = (-2)*g_dq(i)
        pmp = -(2.*dq(i))
        g_lac = 1.5*g_dq(i+1)+g_pmp
        lac = pmp+1.5*dq(i+1)
        g_bl0 = g_pmp*(0.5-sign(0.5,0.-pmp))
        bl0 = max(0.,pmp)
        g_bl1 = g_bl0*(0.5+sign(0.5,bl0-lac))+g_lac*(0.5-sign(0.5,bl0-lac))
        bl1 = max(bl0,lac)
        g_bl3 = g_pmp*(0.5-sign(0.5,pmp-0.))
        bl3 = min(0.,pmp)
        g_bl4 = g_bl3*(0.5+sign(0.5,lac-bl3))+g_lac*(0.5-sign(0.5,lac-bl3))
        bl4 = min(bl3,lac)
        g_bl2 = g_al(i)*(0.5+sign(0.5,al(i)-q(i,j)-bl4))+g_bl4*(0.5-sign(0.5,al(i)-q(i,j)-bl4))-g_q(i,j)*(0.5+sign(0.5,al(i)-q(i,j)&
&-bl4))
        bl2 = max(al(i)-q(i,j),bl4)
        g_bl(i) = g_bl1*(0.5+sign(0.5,bl2-bl1))+g_bl2*(0.5-sign(0.5,bl2-bl1))
        bl(i) = min(bl1,bl2)
        g_pmp = 2*g_dq(i-1)
        pmp = 2.*dq(i-1)
        g_lac = (-1.5)*g_dq(i-2)+g_pmp
        lac = pmp-1.5*dq(i-2)
        g_br0 = g_pmp*(0.5-sign(0.5,0.-pmp))
        br0 = max(0.,pmp)
        g_br1 = g_br0*(0.5+sign(0.5,br0-lac))+g_lac*(0.5-sign(0.5,br0-lac))
        br1 = max(br0,lac)
        g_br3 = g_pmp*(0.5-sign(0.5,pmp-0.))
        br3 = min(0.,pmp)
        g_br4 = g_br3*(0.5+sign(0.5,lac-br3))+g_lac*(0.5-sign(0.5,lac-br3))
        br4 = min(br3,lac)
        g_br2 = g_al(i+1)*(0.5+sign(0.5,al(i+1)-q(i,j)-br4))+g_br4*(0.5-sign(0.5,al(i+1)-q(i,j)-br4))-g_q(i,j)*(0.5+sign(0.5,al(i+&
&1)-q(i,j)-br4))
        br2 = max(al(i+1)-q(i,j),br4)
        g_br(i) = g_br1*(0.5+sign(0.5,br2-br1))+g_br2*(0.5-sign(0.5,br2-br1))
        br(i) = min(br1,br2)
      end do
      if (is .eq. 1) then
        g_br(2) = g_al(3)-g_q(2,j)
        br(2) = al(3)-q(2,j)
        g_xt = (-((g_q(-1,j)+g_q(2,j))*(0.5*dxa(1,j)/(dxa(1,j)+dxa(2,j)))))+(g_q(1,j)+g_q(0,j))*(0.5*(2.*dxa(1,j)+dxa(2,j))/(dxa(1,&
&j)+dxa(2,j)))
        xt = 0.5*((2.*dxa(1,j)+dxa(2,j))*(q(0,j)+q(1,j))-dxa(1,j)*(q(-1,j)+q(2,j)))/(dxa(1,j)+dxa(2,j))
        g_bl(1) = (-g_q(1,j))+g_xt
        bl(1) = xt-q(1,j)
        g_br(0) = (-g_q(0,j))+g_xt
        br(0) = xt-q(0,j)
        g_xt = g_dm1(-1)*s14-g_dq(-1)*s11+g_q(0,j)
        xt = s14*dm1(-1)-s11*dq(-1)+q(0,j)
        g_bl(0) = (-g_q(0,j))+g_xt
        bl(0) = xt-q(0,j)
        g_xt = (-(g_dm1(2)*s14))+g_q(2,j)*s11+g_q(1,j)*s15
        xt = s15*q(1,j)+s11*q(2,j)-s14*dm1(2)
        g_br(1) = (-g_q(1,j))+g_xt
        br(1) = xt-q(1,j)
        g_bl(2) = (-g_q(2,j))+g_xt
        bl(2) = xt-q(2,j)
        if (iord .eq. 9) then
          call g_pert_ppm( 3,q(0:2,j),g_q(0:2,j),bl(0:2),g_bl(0:2),br(0:2),g_br(0:2),1 )
        endif
      endif
      if (ie+1 .eq. npx) then
        g_bl(npx-2) = g_al(npx-2)-g_q(npx-2,j)
        bl(npx-2) = al(npx-2)-q(npx-2,j)
        g_xt = (-(g_q(npx-2,j)*(0.5*dxa(npx-1,j)/(dxa(npx-1,j)+dxa(npx-2,j)))))+g_q(npx-1,j)*(0.5*(2.*dxa(npx-1,j)+dxa(npx-2,j))/&
&(dxa(npx-1,j)+dxa(npx-2,j)))-g_q(npx+1,j)*(0.5*dxa(npx-1,j)/(dxa(npx-1,j)+dxa(npx-2,j)))+g_q(npx,j)*(0.5*(2.*dxa(npx-1,j)+&
&dxa(npx-2,j))/(dxa(npx-1,j)+dxa(npx-2,j)))
        xt = 0.5*((2.*dxa(npx-1,j)+dxa(npx-2,j))*(q(npx-1,j)+q(npx,j))-dxa(npx-1,j)*(q(npx-2,j)+q(npx+1,j)))/(dxa(npx-1,j)+dxa(npx-&
&2,j))
        g_br(npx-1) = (-g_q(npx-1,j))+g_xt
        br(npx-1) = xt-q(npx-1,j)
        g_bl(npx) = (-g_q(npx,j))+g_xt
        bl(npx) = xt-q(npx,j)
        g_xt = (-(g_dm1(npx+1)*s14))+g_dq(npx)*s11+g_q(npx,j)
        xt = s11*dq(npx)-s14*dm1(npx+1)+q(npx,j)
        g_br(npx) = (-g_q(npx,j))+g_xt
        br(npx) = xt-q(npx,j)
        g_xt = g_dm1(npx-2)*s14+g_q(npx-2,j)*s11+g_q(npx-1,j)*s15
        xt = s15*q(npx-1,j)+s11*q(npx-2,j)+s14*dm1(npx-2)
        g_br(npx-2) = (-g_q(npx-2,j))+g_xt
        br(npx-2) = xt-q(npx-2,j)
        g_bl(npx-1) = (-g_q(npx-1,j))+g_xt
        bl(npx-1) = xt-q(npx-1,j)
        if (iord .eq. 9) then
          call g_pert_ppm( 3,q(npx-2:npx,j),g_q(npx-2:npx,j),bl(npx-2:npx),g_bl(npx-2:npx),br(npx-2:npx),g_br(npx-2:npx),1 )
        endif
      endif
    else
      do i = ifirst-2, ilast+2
        g_xt = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
        xt = 0.25*(q(i+1,j)-q(i-1,j))
        g_dm1v = g_xt*sign(1.,xt)
        dm1v = abs(xt)
        g_dm1y = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
        dm1y = max(q(i-1,j),q(i,j))
        g_dm13 = g_dm1y*(0.5+sign(0.5,dm1y-q(i+1,j)))+g_q(i+1,j)*(0.5-sign(0.5,dm1y-q(i+1,j)))-g_q(i,j)
        dm13 = max(dm1y,q(i+1,j))-q(i,j)
        g_dm14 = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
        dm14 = min(q(i-1,j),q(i,j))
        g_dm16 = (-(g_dm14*(0.5+sign(0.5,q(i+1,j)-dm14))+g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-dm14))))+g_q(i,j)
        dm16 = q(i,j)-min(dm14,q(i+1,j))
        g_dm17 = g_dm13*(0.5-sign(0.5,dm13-dm1v))+g_dm1v*(0.5+sign(0.5,dm13-dm1v))
        dm17 = min(dm1v,dm13)
        g_dm18 = g_dm16*(0.5-sign(0.5,dm16-dm17))+g_dm17*(0.5+sign(0.5,dm16-dm17))
        dm18 = min(dm17,dm16)
        g_dm1(i) = g_dm18*sign(1.,dm18)*sign(1.,xt)
        dm1(i) = sign(dm18,xt)
      end do
      do i = ifirst-1, ilast+2
        g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
        al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
      end do
      do i = ifirst-3, ilast+2
        g_dq(i) = g_q(i+1,j)-g_q(i,j)
        dq(i) = q(i+1,j)-q(i,j)
      end do
      do i = ifirst-1, ilast+1
        g_pmp = (-2)*g_dq(i)
        pmp = -(2.*dq(i))
        g_lac = 1.5*g_dq(i+1)+g_pmp
        lac = pmp+1.5*dq(i+1)
        g_blv = g_pmp*(0.5-sign(0.5,0.-pmp))
        blv = max(0.,pmp)
        g_blw = g_blv*(0.5+sign(0.5,blv-lac))+g_lac*(0.5-sign(0.5,blv-lac))
        blw = max(blv,lac)
        g_bly = g_pmp*(0.5-sign(0.5,pmp-0.))
        bly = min(0.,pmp)
        g_blz = g_bly*(0.5+sign(0.5,lac-bly))+g_lac*(0.5-sign(0.5,lac-bly))
        blz = min(bly,lac)
        g_blx = g_al(i)*(0.5+sign(0.5,al(i)-q(i,j)-blz))+g_blz*(0.5-sign(0.5,al(i)-q(i,j)-blz))-g_q(i,j)*(0.5+sign(0.5,al(i)-q(i,j)&
&-blz))
        blx = max(al(i)-q(i,j),blz)
        g_bl(i) = g_blw*(0.5+sign(0.5,blx-blw))+g_blx*(0.5-sign(0.5,blx-blw))
        bl(i) = min(blw,blx)
        g_pmp = 2*g_dq(i-1)
        pmp = 2.*dq(i-1)
        g_lac = (-1.5)*g_dq(i-2)+g_pmp
        lac = pmp-1.5*dq(i-2)
        g_brv = g_pmp*(0.5-sign(0.5,0.-pmp))
        brv = max(0.,pmp)
        g_brw = g_brv*(0.5+sign(0.5,brv-lac))+g_lac*(0.5-sign(0.5,brv-lac))
        brw = max(brv,lac)
        g_bry = g_pmp*(0.5-sign(0.5,pmp-0.))
        bry = min(0.,pmp)
        g_brz = g_bry*(0.5+sign(0.5,lac-bry))+g_lac*(0.5-sign(0.5,lac-bry))
        brz = min(bry,lac)
        g_brx = g_al(i+1)*(0.5+sign(0.5,al(i+1)-q(i,j)-brz))+g_brz*(0.5-sign(0.5,al(i+1)-q(i,j)-brz))-g_q(i,j)*(0.5+sign(0.5,al(i+&
&1)-q(i,j)-brz))
        brx = max(al(i+1)-q(i,j),brz)
        g_br(i) = g_brw*(0.5+sign(0.5,brx-brw))+g_brx*(0.5-sign(0.5,brx-brw))
        br(i) = min(brw,brx)
      end do
    endif
    do i = ifirst, ilast+1
      if (intel_opt_kim) then
        g_c1 = g_c(i,j)
        c1 = c(i,j)
        if (c1 .gt. 0.) then
          it = i-1
          g_qe = g_br(i-1)
          qe = br(i-1)
        else
          it = i
          g_qe = g_bl(i)
          qe = bl(i)
        endif
        g_c1 = -(g_c1*sign(1.,c1))
        c1 = -abs(c1)
        g_flux(i,j) = (g_bl(it)+g_br(it))*(1.+c1)*c1+g_c1*((1.+c1)*(bl(it)+br(it))+qe+c1*(bl(it)+br(it)))+g_q(it,j)+g_qe*(1+c1)
        flux(i,j) = q(it,j)+(1.+c1)*(qe+c1*(bl(it)+br(it)))
      else
        if (c(i,j) .gt. 0.) then
          g_flux(i,j) = (-(g_bl(i-1)*(1.-c(i,j))*c(i,j)))+g_br(i-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i-1)+br(i-1))+&
&br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))+g_q(i-1,j)
          flux(i,j) = q(i-1,j)+(1.-c(i,j))*(br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))
        else
          g_flux(i,j) = g_bl(i)*(1.+c(i,j))*(1+c(i,j))+g_br(i)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i)+br(i))+bl(i)+c(i,j)*&
&(bl(i)+br(i)))+g_q(i,j)
          flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i)+c(i,j)*(bl(i)+br(i)))
        endif
      endif
    end do
  end do
else
  do j = jfirst, jlast
    do i = is-2, ie+2
      g_xt = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
      xt = 0.25*(q(i+1,j)-q(i-1,j))
      g_dm1h = g_xt*sign(1.,xt)
      dm1h = abs(xt)
      g_dm1i = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
      dm1i = max(q(i-1,j),q(i,j))
      g_dm1k = g_dm1i*(0.5+sign(0.5,dm1i-q(i+1,j)))+g_q(i+1,j)*(0.5-sign(0.5,dm1i-q(i+1,j)))-g_q(i,j)
      dm1k = max(dm1i,q(i+1,j))-q(i,j)
      g_dm1l = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
      dm1l = min(q(i-1,j),q(i,j))
      g_dm1n = (-(g_dm1l*(0.5+sign(0.5,q(i+1,j)-dm1l))+g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-dm1l))))+g_q(i,j)
      dm1n = q(i,j)-min(dm1l,q(i+1,j))
      g_dm1o = g_dm1h*(0.5+sign(0.5,dm1k-dm1h))+g_dm1k*(0.5-sign(0.5,dm1k-dm1h))
      dm1o = min(dm1h,dm1k)
      g_dm1p = g_dm1n*(0.5-sign(0.5,dm1n-dm1o))+g_dm1o*(0.5+sign(0.5,dm1n-dm1o))
      dm1p = min(dm1o,dm1n)
      g_dm1(i) = g_dm1p*sign(1.,dm1p)*sign(1.,xt)
      dm1(i) = sign(dm1p,xt)
    end do
    if (grid_type .lt. 3) then
      is3 = max(3,is-1)
      ie3 = min(npx-3,ie+1)
      do i = is3, min(npx-2,ie+2)
        g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
        al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
      end do
      if (iord .eq. 11) then
        do i = is3, ie3
          g_xt = 2*g_dm1(i)
          xt = 2.*dm1(i)
          g_blp = g_al(i)-g_q(i,j)
          blp = al(i)-q(i,j)
          blo = min(abs(xt),abs(blp))
          g_bl(i) = -((g_blp*(0.5-sign(0.5,abs(blp)-abs(xt)))*sign(1.,blp)+g_xt*(0.5+sign(0.5,abs(blp)-abs(xt)))*sign(1.,xt))*&
&sign(1.,blo)*sign(1.,xt))
          bl(i) = -sign(blo,xt)
          g_brp = g_al(i+1)-g_q(i,j)
          brp = al(i+1)-q(i,j)
          g_bro = g_brp*(0.5-sign(0.5,abs(brp)-abs(xt)))*sign(1.,brp)+g_xt*(0.5+sign(0.5,abs(brp)-abs(xt)))*sign(1.,xt)
          bro = min(abs(xt),abs(brp))
          g_br(i) = g_bro*sign(1.,bro)*sign(1.,xt)
          br(i) = sign(bro,xt)
        end do
      else if (iord .eq. 12) then
        do i = is-3, ie+2
          g_dq(i) = g_q(i+1,j)-g_q(i,j)
          dq(i) = q(i+1,j)-q(i,j)
        end do
        do i = is3, ie3
          g_pmp = (-2)*g_dq(i)
          pmp = -(2.*dq(i))
          g_lac = 1.5*g_dq(i+1)+g_pmp
          lac = pmp+1.5*dq(i+1)
          g_blq = g_pmp*(0.5-sign(0.5,0.-pmp))
          blq = max(0.,pmp)
          g_blr = g_blq*(0.5+sign(0.5,blq-lac))+g_lac*(0.5-sign(0.5,blq-lac))
          blr = max(blq,lac)
          g_blt = g_pmp*(0.5-sign(0.5,pmp-0.))
          blt = min(0.,pmp)
          g_blu = g_blt*(0.5+sign(0.5,lac-blt))+g_lac*(0.5-sign(0.5,lac-blt))
          blu = min(blt,lac)
          g_bls = g_al(i)*(0.5+sign(0.5,al(i)-q(i,j)-blu))+g_blu*(0.5-sign(0.5,al(i)-q(i,j)-blu))-g_q(i,j)*(0.5+sign(0.5,al(i)-q(i,&
&j)-blu))
          bls = max(al(i)-q(i,j),blu)
          g_bl(i) = g_blr*(0.5+sign(0.5,bls-blr))+g_bls*(0.5-sign(0.5,bls-blr))
          bl(i) = min(blr,bls)
          g_pmp = 2*g_dq(i-1)
          pmp = 2.*dq(i-1)
          g_lac = (-1.5)*g_dq(i-2)+g_pmp
          lac = pmp-1.5*dq(i-2)
          g_brq = g_pmp*(0.5-sign(0.5,0.-pmp))
          brq = max(0.,pmp)
          g_brr = g_brq*(0.5+sign(0.5,brq-lac))+g_lac*(0.5-sign(0.5,brq-lac))
          brr = max(brq,lac)
          g_brt = g_pmp*(0.5-sign(0.5,pmp-0.))
          brt = min(0.,pmp)
          g_bru = g_brt*(0.5+sign(0.5,lac-brt))+g_lac*(0.5-sign(0.5,lac-brt))
          bru = min(brt,lac)
          g_brs = g_al(i+1)*(0.5+sign(0.5,al(i+1)-q(i,j)-bru))+g_bru*(0.5-sign(0.5,al(i+1)-q(i,j)-bru))-g_q(i,j)*(0.5+sign(0.5,&
&al(i+1)-q(i,j)-bru))
          brs = max(al(i+1)-q(i,j),bru)
          g_br(i) = g_brr*(0.5+sign(0.5,brs-brr))+g_brs*(0.5-sign(0.5,brs-brr))
          br(i) = min(brr,brs)
        end do
      else
        do i = is3, ie3
          g_bl(i) = g_al(i)-g_q(i,j)
          bl(i) = al(i)-q(i,j)
          g_br(i) = g_al(i+1)-g_q(i,j)
          br(i) = al(i+1)-q(i,j)
        end do
      endif
      if (iord .ne. 11) then
        help_h = ie3-is3+1
        call g_pert_ppm( help_h,q(is3:is3+ie3-is3,j),g_q(is3:is3+ie3-is3,j),bl(is3:is3+ie3-is3),g_bl(is3:is3+ie3-is3),br(is3:is3+&
&ie3-is3),g_br(is3:is3+ie3-is3),0 )
      endif
      if (is .eq. 1) then
        g_br(2) = g_al(3)-g_q(2,j)
        br(2) = al(3)-q(2,j)
        g_xt = (-((g_q(-1,j)+g_q(2,j))*(0.5*dxa(1,j)/(dxa(1,j)+dxa(2,j)))))+(g_q(1,j)+g_q(0,j))*(0.5*(2.*dxa(1,j)+dxa(2,j))/(dxa(1,&
&j)+dxa(2,j)))
        xt = 0.5*((2.*dxa(1,j)+dxa(2,j))*(q(0,j)+q(1,j))-dxa(1,j)*(q(-1,j)+q(2,j)))/(dxa(1,j)+dxa(2,j))
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_bl(1) = (-g_q(1,j))+g_xt
        bl(1) = xt-q(1,j)
        g_br(0) = (-g_q(0,j))+g_xt
        br(0) = xt-q(0,j)
        g_xt = 0.57142857*g_dm1(-1)+0.78571429*g_q(-1,j)+0.21428571*g_q(0,j)
        xt = 4./7.*dm1(-1)+11./14.*q(-1,j)+3./14.*q(0,j)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_bl(0) = (-g_q(0,j))+g_xt
        bl(0) = xt-q(0,j)
        g_xt = (-0.57142857)*g_dm1(2)+0.78571429*g_q(2,j)+0.21428571*g_q(1,j)
        xt = 3./14.*q(1,j)+11./14.*q(2,j)-4./7.*dm1(2)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(1) = (-g_q(1,j))+g_xt
        br(1) = xt-q(1,j)
        g_bl(2) = (-g_q(2,j))+g_xt
        bl(2) = xt-q(2,j)
        call g_pert_ppm( 3,q(0:2,j),g_q(0:2,j),bl(0:2),g_bl(0:2),br(0:2),g_br(0:2),1 )
      endif
      if (ie+1 .eq. npx) then
        g_bl(npx-2) = g_al(npx-2)-g_q(npx-2,j)
        bl(npx-2) = al(npx-2)-q(npx-2,j)
        g_xt = (-(g_q(npx-2,j)*(0.5*dxa(npx-1,j)/(dxa(npx-1,j)+dxa(npx-2,j)))))+g_q(npx-1,j)*(0.5*(2.*dxa(npx-1,j)+dxa(npx-2,j))/&
&(dxa(npx-1,j)+dxa(npx-2,j)))-g_q(npx+1,j)*(0.5*dxa(npx-1,j)/(dxa(npx-1,j)+dxa(npx-2,j)))+g_q(npx,j)*(0.5*(2.*dxa(npx-1,j)+&
&dxa(npx-2,j))/(dxa(npx-1,j)+dxa(npx-2,j)))
        xt = 0.5*((2.*dxa(npx-1,j)+dxa(npx-2,j))*(q(npx-1,j)+q(npx,j))-dxa(npx-1,j)*(q(npx-2,j)+q(npx+1,j)))/(dxa(npx-1,j)+dxa(npx-&
&2,j))
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(npx-1) = (-g_q(npx-1,j))+g_xt
        br(npx-1) = xt-q(npx-1,j)
        g_bl(npx) = (-g_q(npx,j))+g_xt
        bl(npx) = xt-q(npx,j)
        g_xt = (-0.57142857)*g_dm1(npx+1)+0.78571429*g_q(npx+1,j)+0.21428571*g_q(npx,j)
        xt = 11./14.*q(npx+1,j)+3./14.*q(npx,j)-4./7.*dm1(npx+1)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(npx) = (-g_q(npx,j))+g_xt
        br(npx) = xt-q(npx,j)
        g_xt = 0.57142857*g_dm1(npx-2)+0.78571429*g_q(npx-2,j)+0.21428571*g_q(npx-1,j)
        xt = 3./14.*q(npx-1,j)+11./14.*q(npx-2,j)+4./7.*dm1(npx-2)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(npx-2) = (-g_q(npx-2,j))+g_xt
        br(npx-2) = xt-q(npx-2,j)
        g_bl(npx-1) = (-g_q(npx-1,j))+g_xt
        bl(npx-1) = xt-q(npx-1,j)
        call g_pert_ppm( 3,q(npx-2:npx,j),g_q(npx-2:npx,j),bl(npx-2:npx),g_bl(npx-2:npx),br(npx-2:npx),g_br(npx-2:npx),1 )
      endif
    else
      do i = ifirst-1, ilast+2
        g_al(i) = g_dm1(i-1)*r3-g_dm1(i)*r3+0.5*g_q(i-1,j)+0.5*g_q(i,j)
        al(i) = 0.5*(q(i-1,j)+q(i,j))+r3*(dm1(i-1)-dm1(i))
      end do
      if (iord .eq. 11) then
        do i = ifirst-1, ilast+1
          g_xt = 2*g_dm1(i)
          xt = 2.*dm1(i)
          g_bli = g_al(i)-g_q(i,j)
          bli = al(i)-q(i,j)
          blh = min(abs(xt),abs(bli))
          g_bl(i) = -((g_bli*(0.5-sign(0.5,abs(bli)-abs(xt)))*sign(1.,bli)+g_xt*(0.5+sign(0.5,abs(bli)-abs(xt)))*sign(1.,xt))*&
&sign(1.,blh)*sign(1.,xt))
          bl(i) = -sign(blh,xt)
          g_bri = g_al(i+1)-g_q(i,j)
          bri = al(i+1)-q(i,j)
          g_brh = g_bri*(0.5-sign(0.5,abs(bri)-abs(xt)))*sign(1.,bri)+g_xt*(0.5+sign(0.5,abs(bri)-abs(xt)))*sign(1.,xt)
          brh = min(abs(xt),abs(bri))
          g_br(i) = g_brh*sign(1.,brh)*sign(1.,xt)
          br(i) = sign(brh,xt)
        end do
      else if (iord .eq. 12) then
        do i = ifirst-3, ilast+2
          g_dq(i) = g_q(i+1,j)-g_q(i,j)
          dq(i) = q(i+1,j)-q(i,j)
        end do
        do i = ifirst-1, ilast+1
          g_pmp = (-2)*g_dq(i)
          pmp = -(2.*dq(i))
          g_lac = 1.5*g_dq(i+1)+g_pmp
          lac = pmp+1.5*dq(i+1)
          g_blj = g_pmp*(0.5-sign(0.5,0.-pmp))
          blj = max(0.,pmp)
          g_blk = g_blj*(0.5+sign(0.5,blj-lac))+g_lac*(0.5-sign(0.5,blj-lac))
          blk = max(blj,lac)
          g_blm = g_pmp*(0.5-sign(0.5,pmp-0.))
          blm = min(0.,pmp)
          g_bln = g_blm*(0.5+sign(0.5,lac-blm))+g_lac*(0.5-sign(0.5,lac-blm))
          bln = min(blm,lac)
          g_bll = g_al(i)*(0.5+sign(0.5,al(i)-q(i,j)-bln))+g_bln*(0.5-sign(0.5,al(i)-q(i,j)-bln))-g_q(i,j)*(0.5+sign(0.5,al(i)-q(i,&
&j)-bln))
          bll = max(al(i)-q(i,j),bln)
          g_bl(i) = g_blk*(0.5+sign(0.5,bll-blk))+g_bll*(0.5-sign(0.5,bll-blk))
          bl(i) = min(blk,bll)
          g_pmp = 2*g_dq(i-1)
          pmp = 2.*dq(i-1)
          g_lac = (-1.5)*g_dq(i-2)+g_pmp
          lac = pmp-1.5*dq(i-2)
          g_brj = g_pmp*(0.5-sign(0.5,0.-pmp))
          brj = max(0.,pmp)
          g_brk = g_brj*(0.5+sign(0.5,brj-lac))+g_lac*(0.5-sign(0.5,brj-lac))
          brk = max(brj,lac)
          g_brm = g_pmp*(0.5-sign(0.5,pmp-0.))
          brm = min(0.,pmp)
          g_brn = g_brm*(0.5+sign(0.5,lac-brm))+g_lac*(0.5-sign(0.5,lac-brm))
          brn = min(brm,lac)
          g_brl = g_al(i+1)*(0.5+sign(0.5,al(i+1)-q(i,j)-brn))+g_brn*(0.5-sign(0.5,al(i+1)-q(i,j)-brn))-g_q(i,j)*(0.5+sign(0.5,&
&al(i+1)-q(i,j)-brn))
          brl = max(al(i+1)-q(i,j),brn)
          g_br(i) = g_brk*(0.5+sign(0.5,brl-brk))+g_brl*(0.5-sign(0.5,brl-brk))
          br(i) = min(brk,brl)
        end do
      else
        do i = is-1, ie+1
          g_bl(i) = g_al(i)-g_q(i,j)
          bl(i) = al(i)-q(i,j)
          g_br(i) = g_al(i+1)-g_q(i,j)
          br(i) = al(i+1)-q(i,j)
        end do
      endif
      if (iord .ne. 11) then
        help_i = ie-is+3
        call g_pert_ppm( help_i,q(is-1:ie+1,j),g_q(is-1:ie+1,j),bl(is-1:ie+1),g_bl(is-1:ie+1),br(is-1:ie+1),g_br(is-1:ie+1),0 )
      endif
    endif
    do i = ifirst, ilast+1
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i-1)*(1.-c(i,j))*c(i,j)))+g_br(i-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i-1)+br(i-1))+&
&br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))+g_q(i-1,j)
        flux(i,j) = q(i-1,j)+(1.-c(i,j))*(br(i-1)-c(i,j)*(bl(i-1)+br(i-1)))
      else
        g_flux(i,j) = g_bl(i)*(1.+c(i,j))*(1+c(i,j))+g_br(i)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i)+br(i))+bl(i)+c(i,j)*&
&(bl(i)+br(i)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i)+c(i,j)*(bl(i)+br(i)))
      endif
    end do
  end do
endif

end subroutine g_fxppm


subroutine g_fyppm( c, g_c, q, g_q, flux, g_flux, jord, ifirst, ilast, jfirst, jlast, npx, npy, uniform_ppm, dm, g_dm )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: b1 = 1./30.
real, parameter :: b2 = -(13./60.)
real, parameter :: b3 = -(13./60.)
real, parameter :: b4 = 0.45
real, parameter :: b5 = -0.05
real, parameter :: r3 = 1./3.
real, parameter :: s11 = 11./14.
real, parameter :: s14 = 4./7.
real, parameter :: s15 = 3./14.

!==============================================
! declare arguments
!==============================================
real, intent(in) :: c(isd:ied,js:je+1)
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real, intent(out) :: dm(ifirst:ilast,jfirst-ng:jlast+ng)
real, intent(out) :: flux(ifirst:ilast,jfirst:jlast+1)
real, intent(in) :: g_c(isd:ied,js:je+1)
real, intent(out) :: g_dm(ifirst:ilast,jfirst-ng:jlast+ng)
real, intent(out) :: g_flux(ifirst:ilast,jfirst:jlast+1)
real, intent(in) :: g_q(ifirst:ilast,jfirst-ng:jlast+ng)
integer, intent(in) :: jord
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(in) :: q(ifirst:ilast,jfirst-ng:jlast+ng)
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: al(ifirst:ilast,jfirst-1:jlast+2)
real :: bl(ifirst:ilast,jfirst-1:jlast+1)
real :: bl0
real :: bl1
real :: bl2
real :: bl3
real :: bl4
real :: bl5
real :: bl6
real :: bl7
real :: bl8
real :: bl9
real :: blaa
real :: blab
real :: blac
real :: blad
real :: blae
real :: blh
real :: bli
real :: blj
real :: blk
real :: bll
real :: blm
real :: bln
real :: blo
real :: blp
real :: blq
real :: blr
real :: bls
real :: blt
real :: blu
real :: blv
real :: blw
real :: blx
real :: bly
real :: blz
real :: br(ifirst:ilast,jfirst-1:jlast+1)
real :: br0
real :: br1
real :: br2
real :: br3
real :: br4
real :: br5
real :: br6
real :: br7
real :: br8
real :: br9
real :: braa
real :: brab
real :: brac
real :: brad
real :: brae
real :: brh
real :: bri
real :: brj
real :: brk
real :: brl
real :: brm
real :: brn
real :: bro
real :: brp
real :: brq
real :: brr
real :: brs
real :: brt
real :: bru
real :: brv
real :: brw
real :: brx
real :: bry
real :: brz
real :: c1
real :: dl
real :: dlh
real :: dli
real :: dlj
real :: dlk
real :: dll
real :: dm0
real :: dm1
real :: dm2
real :: dm3
real :: dm4
real :: dm5
real :: dm6
real :: dm7
real :: dm8
real :: dm9
real :: dmaa
real :: dmab
real :: dmac
real :: dmad
real :: dmaf
real :: dmag
real :: dmai
real :: dmaj
real :: dmak
real :: dmh
real :: dmi
real :: dmj
real :: dmk
real :: dml
real :: dmm
real :: dmn
real :: dmo
real :: dmp
real :: dmq
real :: dmr
real :: dms
real :: dmt
real :: dmu
real :: dmv
real :: dmw
real :: dmx
real :: dmy
real :: dmz
real :: dq(ifirst:ilast,jfirst-3:jlast+2)
real :: dr
real :: drh
real :: dri
real :: drj
real :: drk
real :: drl
real :: g_al(ifirst:ilast,jfirst-1:jlast+2)
real :: g_bl(ifirst:ilast,jfirst-1:jlast+1)
real :: g_bl0
real :: g_bl1
real :: g_bl2
real :: g_bl3
real :: g_bl4
real :: g_bl5
real :: g_bl6
real :: g_bl7
real :: g_bl8
real :: g_bl9
real :: g_blaa
real :: g_blab
real :: g_blac
real :: g_blad
real :: g_blae
real :: g_bli
real :: g_blj
real :: g_blk
real :: g_bll
real :: g_blm
real :: g_bln
real :: g_blp
real :: g_blq
real :: g_blr
real :: g_bls
real :: g_blt
real :: g_blu
real :: g_blv
real :: g_blw
real :: g_blx
real :: g_bly
real :: g_blz
real :: g_br(ifirst:ilast,jfirst-1:jlast+1)
real :: g_br0
real :: g_br1
real :: g_br2
real :: g_br3
real :: g_br4
real :: g_br5
real :: g_br6
real :: g_br7
real :: g_br8
real :: g_br9
real :: g_braa
real :: g_brab
real :: g_brac
real :: g_brad
real :: g_brae
real :: g_brh
real :: g_bri
real :: g_brj
real :: g_brk
real :: g_brl
real :: g_brm
real :: g_brn
real :: g_bro
real :: g_brp
real :: g_brq
real :: g_brr
real :: g_brs
real :: g_brt
real :: g_bru
real :: g_brv
real :: g_brw
real :: g_brx
real :: g_bry
real :: g_brz
real :: g_c1
real :: g_dl
real :: g_dlh
real :: g_dli
real :: g_dlj
real :: g_dlk
real :: g_dm0
real :: g_dm1
real :: g_dm2
real :: g_dm3
real :: g_dm4
real :: g_dm5
real :: g_dm6
real :: g_dm7
real :: g_dm8
real :: g_dm9
real :: g_dmaa
real :: g_dmab
real :: g_dmac
real :: g_dmad
real :: g_dmaf
real :: g_dmag
real :: g_dmai
real :: g_dmaj
real :: g_dmak
real :: g_dmh
real :: g_dmi
real :: g_dmj
real :: g_dmk
real :: g_dml
real :: g_dmm
real :: g_dmn
real :: g_dmo
real :: g_dmp
real :: g_dmq
real :: g_dmr
real :: g_dms
real :: g_dmt
real :: g_dmu
real :: g_dmv
real :: g_dmw
real :: g_dmx
real :: g_dmy
real :: g_dmz
real :: g_dq(ifirst:ilast,jfirst-3:jlast+2)
real :: g_dr
real :: g_drh
real :: g_dri
real :: g_drj
real :: g_drk
real :: g_drl
real :: g_lac
real :: g_pmp
real :: g_qe
real :: g_xt
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_l
integer :: help_m
integer :: i
integer :: j
integer :: je3
integer :: js3
integer :: jt
real :: lac
real :: pmp
real :: qe
real :: xt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (jord .le. 4) then
  if (uniform_ppm) then
    do j = jfirst-2, jlast+2
      do i = ifirst, ilast
        g_xt = (-0.25)*g_q(i,j-1)+0.25*g_q(i,j+1)
        xt = 0.25*(q(i,j+1)-q(i,j-1))
        g_dmt = g_xt*sign(1.,xt)
        dmt = abs(xt)
        g_dmu = g_q(i,j-1)*(0.5+sign(0.5,q(i,j-1)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j-1)-q(i,j)))
        dmu = max(q(i,j-1),q(i,j))
        g_dmw = g_dmu*(0.5+sign(0.5,dmu-q(i,j+1)))+g_q(i,j+1)*(0.5-sign(0.5,dmu-q(i,j+1)))-g_q(i,j)
        dmw = max(dmu,q(i,j+1))-q(i,j)
        g_dmx = g_q(i,j-1)*(0.5+sign(0.5,q(i,j)-q(i,j-1)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i,j-1)))
        dmx = min(q(i,j-1),q(i,j))
        g_dmz = (-(g_dmx*(0.5+sign(0.5,q(i,j+1)-dmx))+g_q(i,j+1)*(0.5-sign(0.5,q(i,j+1)-dmx))))+g_q(i,j)
        dmz = q(i,j)-min(dmx,q(i,j+1))
        g_dm0 = g_dmt*(0.5+sign(0.5,dmw-dmt))+g_dmw*(0.5-sign(0.5,dmw-dmt))
        dm0 = min(dmt,dmw)
        g_dm1 = g_dm0*(0.5+sign(0.5,dmz-dm0))+g_dmz*(0.5-sign(0.5,dmz-dm0))
        dm1 = min(dm0,dmz)
        g_dm(i,j) = g_dm1*sign(1.,dm1)*sign(1.,xt)
        dm(i,j) = sign(dm1,xt)
      end do
    end do
  else
    do j = jfirst-3, jlast+2
      do i = ifirst, ilast
        g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
        dq(i,j) = q(i,j+1)-q(i,j)
      end do
    end do
    do j = jfirst-2, jlast+2
      do i = ifirst, ilast
        g_xt = g_dq(i,j-1)*cy1(i,j)+g_dq(i,j)*cy2(i,j)
        xt = cy1(i,j)*dq(i,j-1)+cy2(i,j)*dq(i,j)
        g_dmj = g_xt*sign(1.,xt)
        dmj = abs(xt)
        g_dmm = g_dq(i,j-1)*sign(1.,dq(i,j-1))
        dmm = abs(dq(i,j-1))
        g_dmq = g_dq(i,j)*sign(1.,dq(i,j))
        dmq = abs(dq(i,j))
        g_dmr = g_dmj*(0.5+sign(0.5,dmm-dmj))+g_dmm*(0.5-sign(0.5,dmm-dmj))
        dmr = min(dmj,dmm)
        g_dms = g_dmq*(0.5-sign(0.5,dmq-dmr))+g_dmr*(0.5+sign(0.5,dmq-dmr))
        dms = min(dmr,dmq)
        g_dm(i,j) = g_dms*sign(1.,dms)*sign(1.,xt)
        dm(i,j) = sign(dms,xt)
      end do
    end do
  endif
  do j = jfirst-1, jlast+2
    do i = ifirst, ilast
      g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
      al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
    end do
  end do
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      if (c(i,j) .gt. 0.) then
        g_xt = 2*g_dm(i,j-1)
        xt = 2.*dm(i,j-1)
        g_dlk = g_al(i,j-1)-g_q(i,j-1)
        dlk = al(i,j-1)-q(i,j-1)
        g_dlj = g_dlk*(0.5-sign(0.5,abs(dlk)-abs(xt)))*sign(1.,dlk)+g_xt*(0.5+sign(0.5,abs(dlk)-abs(xt)))*sign(1.,xt)
        dlj = min(abs(xt),abs(dlk))
        g_dl = g_dlj*sign(1.,dlj)*sign(1.,xt)
        dl = sign(dlj,xt)
        g_drk = g_al(i,j)-g_q(i,j-1)
        drk = al(i,j)-q(i,j-1)
        g_drj = g_drk*(0.5-sign(0.5,abs(drk)-abs(xt)))*sign(1.,drk)+g_xt*(0.5+sign(0.5,abs(drk)-abs(xt)))*sign(1.,xt)
        drj = min(abs(xt),abs(drk))
        g_dr = g_drj*sign(1.,drj)*sign(1.,xt)
        dr = sign(drj,xt)
        g_flux(i,j) = g_c(i,j)*((1.-c(i,j))*(dl-dr)-(c(i,j)*(dl-dr)+dr))+g_dl*(1.-c(i,j))*c(i,j)+g_dr*(1.-c(i,j))*(1-c(i,j))+g_q(i,&
&j-1)
        flux(i,j) = q(i,j-1)+(1.-c(i,j))*(c(i,j)*(dl-dr)+dr)
      else
        g_xt = 2*g_dm(i,j)
        xt = 2.*dm(i,j)
        g_dli = g_al(i,j)-g_q(i,j)
        dli = al(i,j)-q(i,j)
        g_dlh = g_dli*(0.5-sign(0.5,abs(dli)-abs(xt)))*sign(1.,dli)+g_xt*(0.5+sign(0.5,abs(dli)-abs(xt)))*sign(1.,xt)
        dlh = min(abs(xt),abs(dli))
        g_dl = g_dlh*sign(1.,dlh)*sign(1.,xt)
        dl = sign(dlh,xt)
        g_dri = g_al(i,j+1)-g_q(i,j)
        dri = al(i,j+1)-q(i,j)
        g_drh = g_dri*(0.5-sign(0.5,abs(dri)-abs(xt)))*sign(1.,dri)+g_xt*(0.5+sign(0.5,abs(dri)-abs(xt)))*sign(1.,xt)
        drh = min(abs(xt),abs(dri))
        g_dr = g_drh*sign(1.,drh)*sign(1.,xt)
        dr = sign(drh,xt)
        g_flux(i,j) = (-(g_c(i,j)*((1.+2*c(i,j))*(dl-dr)+dl)+g_dl*(1.+c(i,j))*(1+c(i,j))))+g_dr*(1.+c(i,j))*c(i,j)+g_q(i,j)
        flux(i,j) = q(i,j)-(1.+c(i,j))*(c(i,j)*(dl-dr)+dl)
      endif
    end do
  end do
else if (jord .eq. 5) then
  do j = jfirst-3, jlast+2
    do i = ifirst, ilast
      g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
      dq(i,j) = q(i,j+1)-q(i,j)
    end do
  end do
  if (uniform_ppm) then
    do j = jfirst-2, jlast+2
      do i = ifirst, ilast
        g_xt = (-0.25)*g_q(i,j-1)+0.25*g_q(i,j+1)
        xt = 0.25*(q(i,j+1)-q(i,j-1))
        g_dmac = g_xt*sign(1.,xt)
        dmac = abs(xt)
        g_dmad = g_q(i,j-1)*(0.5+sign(0.5,q(i,j-1)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j-1)-q(i,j)))
        dmad = max(q(i,j-1),q(i,j))
        g_dmaf = g_dmad*(0.5+sign(0.5,dmad-q(i,j+1)))+g_q(i,j+1)*(0.5-sign(0.5,dmad-q(i,j+1)))-g_q(i,j)
        dmaf = max(dmad,q(i,j+1))-q(i,j)
        g_dmag = g_q(i,j-1)*(0.5+sign(0.5,q(i,j)-q(i,j-1)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i,j-1)))
        dmag = min(q(i,j-1),q(i,j))
        g_dmai = (-(g_dmag*(0.5+sign(0.5,q(i,j+1)-dmag))+g_q(i,j+1)*(0.5-sign(0.5,q(i,j+1)-dmag))))+g_q(i,j)
        dmai = q(i,j)-min(dmag,q(i,j+1))
        g_dmaj = g_dmac*(0.5+sign(0.5,dmaf-dmac))+g_dmaf*(0.5-sign(0.5,dmaf-dmac))
        dmaj = min(dmac,dmaf)
        g_dmak = g_dmai*(0.5-sign(0.5,dmai-dmaj))+g_dmaj*(0.5+sign(0.5,dmai-dmaj))
        dmak = min(dmaj,dmai)
        g_dm(i,j) = g_dmak*sign(1.,dmak)*sign(1.,xt)
        dm(i,j) = sign(dmak,xt)
      end do
    end do
  else
    do j = jfirst-2, jlast+2
      do i = ifirst, ilast
        g_xt = g_dq(i,j-1)*cy1(i,j)+g_dq(i,j)*cy2(i,j)
        xt = cy1(i,j)*dq(i,j-1)+cy2(i,j)*dq(i,j)
        g_dm2 = g_xt*sign(1.,xt)
        dm2 = abs(xt)
        g_dm5 = g_dq(i,j-1)*sign(1.,dq(i,j-1))
        dm5 = abs(dq(i,j-1))
        g_dm9 = g_dq(i,j)*sign(1.,dq(i,j))
        dm9 = abs(dq(i,j))
        g_dmaa = g_dm2*(0.5+sign(0.5,dm5-dm2))+g_dm5*(0.5-sign(0.5,dm5-dm2))
        dmaa = min(dm2,dm5)
        g_dmab = g_dm9*(0.5-sign(0.5,dm9-dmaa))+g_dmaa*(0.5+sign(0.5,dm9-dmaa))
        dmab = min(dmaa,dm9)
        g_dm(i,j) = g_dmab*sign(1.,dmab)*sign(1.,xt)
        dm(i,j) = sign(dmab,xt)
      end do
    end do
  endif
  do j = jfirst-1, jlast+2
    do i = ifirst, ilast
      g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
      al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
    end do
  end do
  do j = jfirst-1, jlast+1
    do i = ifirst, ilast
      g_pmp = (-2)*g_dq(i,j)
      pmp = -(2.*dq(i,j))
      g_lac = 1.5*g_dq(i,j+1)+g_pmp
      lac = pmp+1.5*dq(i,j+1)
      g_blaa = g_pmp*(0.5-sign(0.5,0.-pmp))
      blaa = max(0.,pmp)
      g_blab = g_blaa*(0.5+sign(0.5,blaa-lac))+g_lac*(0.5-sign(0.5,blaa-lac))
      blab = max(blaa,lac)
      g_blad = g_pmp*(0.5-sign(0.5,pmp-0.))
      blad = min(0.,pmp)
      g_blae = g_blad*(0.5+sign(0.5,lac-blad))+g_lac*(0.5-sign(0.5,lac-blad))
      blae = min(blad,lac)
      g_blac = g_al(i,j)*(0.5+sign(0.5,al(i,j)-q(i,j)-blae))+g_blae*(0.5-sign(0.5,al(i,j)-q(i,j)-blae))-g_q(i,j)*(0.5+sign(0.5,&
&al(i,j)-q(i,j)-blae))
      blac = max(al(i,j)-q(i,j),blae)
      g_bl(i,j) = g_blab*(0.5+sign(0.5,blac-blab))+g_blac*(0.5-sign(0.5,blac-blab))
      bl(i,j) = min(blab,blac)
      g_pmp = 2*g_dq(i,j-1)
      pmp = 2.*dq(i,j-1)
      g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
      lac = pmp-1.5*dq(i,j-2)
      g_braa = g_pmp*(0.5-sign(0.5,0.-pmp))
      braa = max(0.,pmp)
      g_brab = g_braa*(0.5+sign(0.5,braa-lac))+g_lac*(0.5-sign(0.5,braa-lac))
      brab = max(braa,lac)
      g_brad = g_pmp*(0.5-sign(0.5,pmp-0.))
      brad = min(0.,pmp)
      g_brae = g_brad*(0.5+sign(0.5,lac-brad))+g_lac*(0.5-sign(0.5,lac-brad))
      brae = min(brad,lac)
      g_brac = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-q(i,j)-brae))+g_brae*(0.5-sign(0.5,al(i,j+1)-q(i,j)-brae))-g_q(i,j)*(0.5+&
&sign(0.5,al(i,j+1)-q(i,j)-brae))
      brac = max(al(i,j+1)-q(i,j),brae)
      g_br(i,j) = g_brab*(0.5+sign(0.5,brac-brab))+g_brac*(0.5-sign(0.5,brac-brab))
      br(i,j) = min(brab,brac)
    end do
  end do
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i,j-1)*(1.-c(i,j))*c(i,j)))+g_br(i,j-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i,j-1)+br(i,&
&j-1))+br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))+g_q(i,j-1)
        flux(i,j) = q(i,j-1)+(1.-c(i,j))*(br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))
      else
        g_flux(i,j) = g_bl(i,j)*(1.+c(i,j))*(1+c(i,j))+g_br(i,j)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i,j)+br(i,j))+bl(i,j)&
&+c(i,j)*(bl(i,j)+br(i,j)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i,j)+c(i,j)*(bl(i,j)+br(i,j)))
      endif
    end do
  end do
else if (jord .eq. 6 .or. jord .eq. 7) then
  do j = jfirst-1, jlast+1
    do i = ifirst, ilast
      g_xt = g_q(i,j)*b3
      xt = b3*q(i,j)
      g_bl(i,j) = g_q(i,j-2)*b5+g_q(i,j-1)*b4+g_q(i,j+2)*b1+g_q(i,j+1)*b2+g_xt
      bl(i,j) = b5*q(i,j-2)+b4*q(i,j-1)+xt+b2*q(i,j+1)+b1*q(i,j+2)
      g_br(i,j) = g_q(i,j-2)*b1+g_q(i,j-1)*b2+g_q(i,j+2)*b5+g_q(i,j+1)*b4+g_xt
      br(i,j) = b1*q(i,j-2)+b2*q(i,j-1)+xt+b4*q(i,j+1)+b5*q(i,j+2)
    end do
  end do
  if (jord .eq. 7) then
    do j = jfirst-2, jlast+3
      do i = ifirst, ilast
        g_dq(i,j) = (-g_q(i,j-1))+g_q(i,j)
        dq(i,j) = q(i,j)-q(i,j-1)
      end do
    end do
    do j = jfirst-1, jlast+1
      do i = ifirst, ilast
        dll = min(abs(bl(i,j)),abs(dq(i,j)))
        g_dl = -((g_bl(i,j)*(0.5+sign(0.5,abs(dq(i,j))-abs(bl(i,j))))*sign(1.,bl(i,j))+g_dq(i,j)*(0.5-sign(0.5,abs(dq(i,j))-&
&abs(bl(i,j))))*sign(1.,dq(i,j)))*sign(1.,dll)*sign(1.,dq(i,j)))
        dl = -sign(dll,dq(i,j))
        g_pmp = (-2)*g_dq(i,j+1)
        pmp = -(2.*dq(i,j+1))
        g_lac = 1.5*g_dq(i,j+2)+g_pmp
        lac = pmp+1.5*dq(i,j+2)
        g_bl5 = g_pmp*(0.5-sign(0.5,0.-pmp))
        bl5 = max(0.,pmp)
        g_bl6 = g_bl5*(0.5+sign(0.5,bl5-lac))+g_lac*(0.5-sign(0.5,bl5-lac))
        bl6 = max(bl5,lac)
        g_bl8 = g_pmp*(0.5-sign(0.5,pmp-0.))
        bl8 = min(0.,pmp)
        g_bl9 = g_bl8*(0.5+sign(0.5,lac-bl8))+g_lac*(0.5-sign(0.5,lac-bl8))
        bl9 = min(bl8,lac)
        g_bl7 = g_bl9*(0.5-sign(0.5,dl-bl9))+g_dl*(0.5+sign(0.5,dl-bl9))
        bl7 = max(dl,bl9)
        g_bl(i,j) = g_bl6*(0.5+sign(0.5,bl7-bl6))+g_bl7*(0.5-sign(0.5,bl7-bl6))
        bl(i,j) = min(bl6,bl7)
        g_drl = g_br(i,j)*(0.5+sign(0.5,abs(dq(i,j+1))-abs(br(i,j))))*sign(1.,br(i,j))+g_dq(i,j+1)*(0.5-sign(0.5,abs(dq(i,j+1))-&
&abs(br(i,j))))*sign(1.,dq(i,j+1))
        drl = min(abs(br(i,j)),abs(dq(i,j+1)))
        g_dr = g_drl*sign(1.,drl)*sign(1.,dq(i,j+1))
        dr = sign(drl,dq(i,j+1))
        g_pmp = 2*g_dq(i,j)
        pmp = 2.*dq(i,j)
        g_lac = (-1.5)*g_dq(i,j-1)+g_pmp
        lac = pmp-1.5*dq(i,j-1)
        g_br5 = g_pmp*(0.5-sign(0.5,0.-pmp))
        br5 = max(0.,pmp)
        g_br6 = g_br5*(0.5+sign(0.5,br5-lac))+g_lac*(0.5-sign(0.5,br5-lac))
        br6 = max(br5,lac)
        g_br8 = g_pmp*(0.5-sign(0.5,pmp-0.))
        br8 = min(0.,pmp)
        g_br9 = g_br8*(0.5+sign(0.5,lac-br8))+g_lac*(0.5-sign(0.5,lac-br8))
        br9 = min(br8,lac)
        g_br7 = g_br9*(0.5-sign(0.5,dr-br9))+g_dr*(0.5+sign(0.5,dr-br9))
        br7 = max(dr,br9)
        g_br(i,j) = g_br6*(0.5+sign(0.5,br7-br6))+g_br7*(0.5-sign(0.5,br7-br6))
        br(i,j) = min(br6,br7)
      end do
    end do
  endif
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i,j-1)*(1.-c(i,j))*c(i,j)))+g_br(i,j-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i,j-1)+br(i,&
&j-1))+br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))+g_q(i,j-1)
        flux(i,j) = q(i,j-1)+(1.-c(i,j))*(br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))
      else
        g_flux(i,j) = g_bl(i,j)*(1.+c(i,j))*(1+c(i,j))+g_br(i,j)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i,j)+br(i,j))+bl(i,j)&
&+c(i,j)*(bl(i,j)+br(i,j)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i,j)+c(i,j)*(bl(i,j)+br(i,j)))
      endif
    end do
  end do
else if (jord .le. 10) then
  do j = js-2, je+2
    do i = ifirst, ilast
      g_xt = (-0.25)*g_q(i,j-1)+0.25*g_q(i,j+1)
      xt = 0.25*(q(i,j+1)-q(i,j-1))
      g_dmv = g_xt*sign(1.,xt)
      dmv = abs(xt)
      g_dmy = g_q(i,j-1)*(0.5+sign(0.5,q(i,j-1)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j-1)-q(i,j)))
      dmy = max(q(i,j-1),q(i,j))
      g_dm3 = g_dmy*(0.5+sign(0.5,dmy-q(i,j+1)))+g_q(i,j+1)*(0.5-sign(0.5,dmy-q(i,j+1)))-g_q(i,j)
      dm3 = max(dmy,q(i,j+1))-q(i,j)
      g_dm4 = g_q(i,j-1)*(0.5+sign(0.5,q(i,j)-q(i,j-1)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i,j-1)))
      dm4 = min(q(i,j-1),q(i,j))
      g_dm6 = (-(g_dm4*(0.5+sign(0.5,q(i,j+1)-dm4))+g_q(i,j+1)*(0.5-sign(0.5,q(i,j+1)-dm4))))+g_q(i,j)
      dm6 = q(i,j)-min(dm4,q(i,j+1))
      g_dm7 = g_dm3*(0.5-sign(0.5,dm3-dmv))+g_dmv*(0.5+sign(0.5,dm3-dmv))
      dm7 = min(dmv,dm3)
      g_dm8 = g_dm6*(0.5-sign(0.5,dm6-dm7))+g_dm7*(0.5+sign(0.5,dm6-dm7))
      dm8 = min(dm7,dm6)
      g_dm(i,j) = g_dm8*sign(1.,dm8)*sign(1.,xt)
      dm(i,j) = sign(dm8,xt)
    end do
  end do
  if (grid_type .lt. 3) then
    do j = max(3,js-1), min(npy-2,je+2)
      do i = ifirst, ilast
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
        al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    do j = js-3, je+2
      do i = ifirst, ilast
        g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
        dq(i,j) = q(i,j+1)-q(i,j)
      end do
    end do
    do j = max(3,js-1), min(npy-3,je+1)
      do i = ifirst, ilast
        g_pmp = (-2)*g_dq(i,j)
        pmp = -(2.*dq(i,j))
        g_lac = 1.5*g_dq(i,j+1)+g_pmp
        lac = pmp+1.5*dq(i,j+1)
        g_bl0 = g_pmp*(0.5-sign(0.5,0.-pmp))
        bl0 = max(0.,pmp)
        g_bl1 = g_bl0*(0.5+sign(0.5,bl0-lac))+g_lac*(0.5-sign(0.5,bl0-lac))
        bl1 = max(bl0,lac)
        g_bl3 = g_pmp*(0.5-sign(0.5,pmp-0.))
        bl3 = min(0.,pmp)
        g_bl4 = g_bl3*(0.5+sign(0.5,lac-bl3))+g_lac*(0.5-sign(0.5,lac-bl3))
        bl4 = min(bl3,lac)
        g_bl2 = g_al(i,j)*(0.5+sign(0.5,al(i,j)-q(i,j)-bl4))+g_bl4*(0.5-sign(0.5,al(i,j)-q(i,j)-bl4))-g_q(i,j)*(0.5+sign(0.5,al(i,&
&j)-q(i,j)-bl4))
        bl2 = max(al(i,j)-q(i,j),bl4)
        g_bl(i,j) = g_bl1*(0.5+sign(0.5,bl2-bl1))+g_bl2*(0.5-sign(0.5,bl2-bl1))
        bl(i,j) = min(bl1,bl2)
        g_pmp = 2*g_dq(i,j-1)
        pmp = 2.*dq(i,j-1)
        g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
        lac = pmp-1.5*dq(i,j-2)
        g_br0 = g_pmp*(0.5-sign(0.5,0.-pmp))
        br0 = max(0.,pmp)
        g_br1 = g_br0*(0.5+sign(0.5,br0-lac))+g_lac*(0.5-sign(0.5,br0-lac))
        br1 = max(br0,lac)
        g_br3 = g_pmp*(0.5-sign(0.5,pmp-0.))
        br3 = min(0.,pmp)
        g_br4 = g_br3*(0.5+sign(0.5,lac-br3))+g_lac*(0.5-sign(0.5,lac-br3))
        br4 = min(br3,lac)
        g_br2 = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-q(i,j)-br4))+g_br4*(0.5-sign(0.5,al(i,j+1)-q(i,j)-br4))-g_q(i,j)*(0.5+sign(0.5,&
&al(i,j+1)-q(i,j)-br4))
        br2 = max(al(i,j+1)-q(i,j),br4)
        g_br(i,j) = g_br1*(0.5+sign(0.5,br2-br1))+g_br2*(0.5-sign(0.5,br2-br1))
        br(i,j) = min(br1,br2)
      end do
    end do
    if (js .eq. 1) then
      do i = ifirst, ilast
        g_br(i,2) = g_al(i,3)-g_q(i,2)
        br(i,2) = al(i,3)-q(i,2)
        g_xt = (-((g_q(i,-1)+g_q(i,2))*(0.5*dya(i,1)/(dya(i,1)+dya(i,2)))))+(g_q(i,1)+g_q(i,0))*(0.5*(2.*dya(i,1)+dya(i,2))/(dya(i,&
&1)+dya(i,2)))
        xt = 0.5*((2.*dya(i,1)+dya(i,2))*(q(i,0)+q(i,1))-dya(i,1)*(q(i,-1)+q(i,2)))/(dya(i,1)+dya(i,2))
        g_bl(i,1) = (-g_q(i,1))+g_xt
        bl(i,1) = xt-q(i,1)
        g_br(i,0) = (-g_q(i,0))+g_xt
        br(i,0) = xt-q(i,0)
        g_xt = g_dm(i,-1)*s14-g_dq(i,-1)*s11+g_q(i,0)
        xt = s14*dm(i,-1)-s11*dq(i,-1)+q(i,0)
        g_bl(i,0) = (-g_q(i,0))+g_xt
        bl(i,0) = xt-q(i,0)
        g_xt = (-(g_dm(i,2)*s14))+g_q(i,2)*s11+g_q(i,1)*s15
        xt = s15*q(i,1)+s11*q(i,2)-s14*dm(i,2)
        g_br(i,1) = (-g_q(i,1))+g_xt
        br(i,1) = xt-q(i,1)
        g_bl(i,2) = (-g_q(i,2))+g_xt
        bl(i,2) = xt-q(i,2)
      end do
      if (jord .eq. 9) then
        do j = 0, 2
          help_h = ilast-ifirst+1
          call g_pert_ppm( help_h,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),1 )
        end do
      endif
    endif
    if (je+1 .eq. npy) then
      do i = ifirst, ilast
        g_bl(i,npy-2) = g_al(i,npy-2)-g_q(i,npy-2)
        bl(i,npy-2) = al(i,npy-2)-q(i,npy-2)
        g_xt = (-(g_q(i,npy-2)*(0.5*dya(i,npy-1)/(dya(i,npy-1)+dya(i,npy-2)))))+g_q(i,npy-1)*(0.5*(2.*dya(i,npy-1)+dya(i,npy-2))/&
&(dya(i,npy-1)+dya(i,npy-2)))-g_q(i,npy+1)*(0.5*dya(i,npy-1)/(dya(i,npy-1)+dya(i,npy-2)))+g_q(i,npy)*(0.5*(2.*dya(i,npy-1)+&
&dya(i,npy-2))/(dya(i,npy-1)+dya(i,npy-2)))
        xt = 0.5*((2.*dya(i,npy-1)+dya(i,npy-2))*(q(i,npy-1)+q(i,npy))-dya(i,npy-1)*(q(i,npy-2)+q(i,npy+1)))/(dya(i,npy-1)+dya(i,&
&npy-2))
        g_br(i,npy-1) = (-g_q(i,npy-1))+g_xt
        br(i,npy-1) = xt-q(i,npy-1)
        g_bl(i,npy) = (-g_q(i,npy))+g_xt
        bl(i,npy) = xt-q(i,npy)
        g_xt = (-(g_dm(i,npy+1)*s14))+g_dq(i,npy)*s11+g_q(i,npy)
        xt = s11*dq(i,npy)-s14*dm(i,npy+1)+q(i,npy)
        g_br(i,npy) = (-g_q(i,npy))+g_xt
        br(i,npy) = xt-q(i,npy)
        g_xt = g_dm(i,npy-2)*s14+g_q(i,npy-2)*s11+g_q(i,npy-1)*s15
        xt = s15*q(i,npy-1)+s11*q(i,npy-2)+s14*dm(i,npy-2)
        g_br(i,npy-2) = (-g_q(i,npy-2))+g_xt
        br(i,npy-2) = xt-q(i,npy-2)
        g_bl(i,npy-1) = (-g_q(i,npy-1))+g_xt
        bl(i,npy-1) = xt-q(i,npy-1)
      end do
      if (jord .eq. 9) then
        do j = npy-2, npy
          help_i = ilast-ifirst+1
          call g_pert_ppm( help_i,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),1 )
        end do
      endif
    endif
  else
    do j = jfirst-1, jlast+2
      do i = ifirst, ilast
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
        al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    do j = jfirst-3, jlast+2
      do i = ifirst, ilast
        g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
        dq(i,j) = q(i,j+1)-q(i,j)
      end do
    end do
    do j = jfirst-1, jlast+1
      do i = ifirst, ilast
        g_pmp = (-2)*g_dq(i,j)
        pmp = -(2.*dq(i,j))
        g_lac = 1.5*g_dq(i,j+1)+g_pmp
        lac = pmp+1.5*dq(i,j+1)
        g_blv = g_pmp*(0.5-sign(0.5,0.-pmp))
        blv = max(0.,pmp)
        g_blw = g_blv*(0.5+sign(0.5,blv-lac))+g_lac*(0.5-sign(0.5,blv-lac))
        blw = max(blv,lac)
        g_bly = g_pmp*(0.5-sign(0.5,pmp-0.))
        bly = min(0.,pmp)
        g_blz = g_bly*(0.5+sign(0.5,lac-bly))+g_lac*(0.5-sign(0.5,lac-bly))
        blz = min(bly,lac)
        g_blx = g_al(i,j)*(0.5+sign(0.5,al(i,j)-q(i,j)-blz))+g_blz*(0.5-sign(0.5,al(i,j)-q(i,j)-blz))-g_q(i,j)*(0.5+sign(0.5,al(i,&
&j)-q(i,j)-blz))
        blx = max(al(i,j)-q(i,j),blz)
        g_bl(i,j) = g_blw*(0.5+sign(0.5,blx-blw))+g_blx*(0.5-sign(0.5,blx-blw))
        bl(i,j) = min(blw,blx)
        g_pmp = 2*g_dq(i,j-1)
        pmp = 2.*dq(i,j-1)
        g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
        lac = pmp-1.5*dq(i,j-2)
        g_brv = g_pmp*(0.5-sign(0.5,0.-pmp))
        brv = max(0.,pmp)
        g_brw = g_brv*(0.5+sign(0.5,brv-lac))+g_lac*(0.5-sign(0.5,brv-lac))
        brw = max(brv,lac)
        g_bry = g_pmp*(0.5-sign(0.5,pmp-0.))
        bry = min(0.,pmp)
        g_brz = g_bry*(0.5+sign(0.5,lac-bry))+g_lac*(0.5-sign(0.5,lac-bry))
        brz = min(bry,lac)
        g_brx = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-q(i,j)-brz))+g_brz*(0.5-sign(0.5,al(i,j+1)-q(i,j)-brz))-g_q(i,j)*(0.5+sign(0.5,&
&al(i,j+1)-q(i,j)-brz))
        brx = max(al(i,j+1)-q(i,j),brz)
        g_br(i,j) = g_brw*(0.5+sign(0.5,brx-brw))+g_brx*(0.5-sign(0.5,brx-brw))
        br(i,j) = min(brw,brx)
      end do
    end do
  endif
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      if (intel_opt_kim) then
        g_c1 = g_c(i,j)
        c1 = c(i,j)
        if (c1 .gt. 0.) then
          jt = j-1
          g_qe = g_br(i,j-1)
          qe = br(i,j-1)
        else
          jt = j
          g_qe = g_bl(i,j)
          qe = bl(i,j)
        endif
        g_c1 = -(g_c1*sign(1.,c1))
        c1 = -abs(c1)
        g_flux(i,j) = (g_bl(i,jt)+g_br(i,jt))*(1.+c1)*c1+g_c1*((1.+c1)*(bl(i,jt)+br(i,jt))+qe+c1*(bl(i,jt)+br(i,jt)))+g_q(i,jt)+&
&g_qe*(1+c1)
        flux(i,j) = q(i,jt)+(1.+c1)*(qe+c1*(bl(i,jt)+br(i,jt)))
      else
        if (c(i,j) .gt. 0.) then
          g_flux(i,j) = (-(g_bl(i,j-1)*(1.-c(i,j))*c(i,j)))+g_br(i,j-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i,j-1)+&
&br(i,j-1))+br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))+g_q(i,j-1)
          flux(i,j) = q(i,j-1)+(1.-c(i,j))*(br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))
        else
          g_flux(i,j) = g_bl(i,j)*(1.+c(i,j))*(1+c(i,j))+g_br(i,j)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i,j)+br(i,j))+bl(i,&
&j)+c(i,j)*(bl(i,j)+br(i,j)))+g_q(i,j)
          flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i,j)+c(i,j)*(bl(i,j)+br(i,j)))
        endif
      endif
    end do
  end do
else
  do j = js-2, je+2
    do i = ifirst, ilast
      g_xt = (-0.25)*g_q(i,j-1)+0.25*g_q(i,j+1)
      xt = 0.25*(q(i,j+1)-q(i,j-1))
      g_dmh = g_xt*sign(1.,xt)
      dmh = abs(xt)
      g_dmi = g_q(i,j-1)*(0.5+sign(0.5,q(i,j-1)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j-1)-q(i,j)))
      dmi = max(q(i,j-1),q(i,j))
      g_dmk = g_dmi*(0.5+sign(0.5,dmi-q(i,j+1)))+g_q(i,j+1)*(0.5-sign(0.5,dmi-q(i,j+1)))-g_q(i,j)
      dmk = max(dmi,q(i,j+1))-q(i,j)
      g_dml = g_q(i,j-1)*(0.5+sign(0.5,q(i,j)-q(i,j-1)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i,j-1)))
      dml = min(q(i,j-1),q(i,j))
      g_dmn = (-(g_dml*(0.5+sign(0.5,q(i,j+1)-dml))+g_q(i,j+1)*(0.5-sign(0.5,q(i,j+1)-dml))))+g_q(i,j)
      dmn = q(i,j)-min(dml,q(i,j+1))
      g_dmo = g_dmh*(0.5+sign(0.5,dmk-dmh))+g_dmk*(0.5-sign(0.5,dmk-dmh))
      dmo = min(dmh,dmk)
      g_dmp = g_dmn*(0.5-sign(0.5,dmn-dmo))+g_dmo*(0.5+sign(0.5,dmn-dmo))
      dmp = min(dmo,dmn)
      g_dm(i,j) = g_dmp*sign(1.,dmp)*sign(1.,xt)
      dm(i,j) = sign(dmp,xt)
    end do
  end do
  if (grid_type .lt. 3) then
    js3 = max(3,js-1)
    je3 = min(npy-3,je+1)
    do j = js3, min(npy-2,je+2)
      do i = ifirst, ilast
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
        al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    if (jord .eq. 11) then
      do j = js3, je3
        do i = ifirst, ilast
          g_xt = 2*g_dm(i,j)
          xt = 2.*dm(i,j)
          g_blp = g_al(i,j)-g_q(i,j)
          blp = al(i,j)-q(i,j)
          blo = min(abs(xt),abs(blp))
          g_bl(i,j) = -((g_blp*(0.5-sign(0.5,abs(blp)-abs(xt)))*sign(1.,blp)+g_xt*(0.5+sign(0.5,abs(blp)-abs(xt)))*sign(1.,xt))*&
&sign(1.,blo)*sign(1.,xt))
          bl(i,j) = -sign(blo,xt)
          g_brp = g_al(i,j+1)-g_q(i,j)
          brp = al(i,j+1)-q(i,j)
          g_bro = g_brp*(0.5-sign(0.5,abs(brp)-abs(xt)))*sign(1.,brp)+g_xt*(0.5+sign(0.5,abs(brp)-abs(xt)))*sign(1.,xt)
          bro = min(abs(xt),abs(brp))
          g_br(i,j) = g_bro*sign(1.,bro)*sign(1.,xt)
          br(i,j) = sign(bro,xt)
        end do
      end do
    else if (jord .eq. 12) then
      do j = js-3, je+2
        do i = ifirst, ilast
          g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
          dq(i,j) = q(i,j+1)-q(i,j)
        end do
      end do
      do j = js3, je3
        do i = ifirst, ilast
          g_pmp = (-2)*g_dq(i,j)
          pmp = -(2.*dq(i,j))
          g_lac = 1.5*g_dq(i,j+1)+g_pmp
          lac = pmp+1.5*dq(i,j+1)
          g_blq = g_pmp*(0.5-sign(0.5,0.-pmp))
          blq = max(0.,pmp)
          g_blr = g_blq*(0.5+sign(0.5,blq-lac))+g_lac*(0.5-sign(0.5,blq-lac))
          blr = max(blq,lac)
          g_blt = g_pmp*(0.5-sign(0.5,pmp-0.))
          blt = min(0.,pmp)
          g_blu = g_blt*(0.5+sign(0.5,lac-blt))+g_lac*(0.5-sign(0.5,lac-blt))
          blu = min(blt,lac)
          g_bls = g_al(i,j)*(0.5+sign(0.5,al(i,j)-q(i,j)-blu))+g_blu*(0.5-sign(0.5,al(i,j)-q(i,j)-blu))-g_q(i,j)*(0.5+sign(0.5,&
&al(i,j)-q(i,j)-blu))
          bls = max(al(i,j)-q(i,j),blu)
          g_bl(i,j) = g_blr*(0.5+sign(0.5,bls-blr))+g_bls*(0.5-sign(0.5,bls-blr))
          bl(i,j) = min(blr,bls)
          g_pmp = 2*g_dq(i,j-1)
          pmp = 2.*dq(i,j-1)
          g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
          lac = pmp-1.5*dq(i,j-2)
          g_brq = g_pmp*(0.5-sign(0.5,0.-pmp))
          brq = max(0.,pmp)
          g_brr = g_brq*(0.5+sign(0.5,brq-lac))+g_lac*(0.5-sign(0.5,brq-lac))
          brr = max(brq,lac)
          g_brt = g_pmp*(0.5-sign(0.5,pmp-0.))
          brt = min(0.,pmp)
          g_bru = g_brt*(0.5+sign(0.5,lac-brt))+g_lac*(0.5-sign(0.5,lac-brt))
          bru = min(brt,lac)
          g_brs = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-q(i,j)-bru))+g_bru*(0.5-sign(0.5,al(i,j+1)-q(i,j)-bru))-g_q(i,j)*(0.5+&
&sign(0.5,al(i,j+1)-q(i,j)-bru))
          brs = max(al(i,j+1)-q(i,j),bru)
          g_br(i,j) = g_brr*(0.5+sign(0.5,brs-brr))+g_brs*(0.5-sign(0.5,brs-brr))
          br(i,j) = min(brr,brs)
        end do
      end do
    else
      do j = js3, je3
        do i = ifirst, ilast
          g_bl(i,j) = g_al(i,j)-g_q(i,j)
          bl(i,j) = al(i,j)-q(i,j)
          g_br(i,j) = g_al(i,j+1)-g_q(i,j)
          br(i,j) = al(i,j+1)-q(i,j)
        end do
      end do
    endif
    if (jord .ne. 11) then
      do j = js3, je3
        help_j = ilast-ifirst+1
        call g_pert_ppm( help_j,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),0 )
      end do
    endif
    if (js .eq. 1) then
      do i = ifirst, ilast
        g_br(i,2) = g_al(i,3)-g_q(i,2)
        br(i,2) = al(i,3)-q(i,2)
        g_xt = (-((g_q(i,-1)+g_q(i,2))*(0.5*dya(i,1)/(dya(i,1)+dya(i,2)))))+(g_q(i,1)+g_q(i,0))*(0.5*(2.*dya(i,1)+dya(i,2))/(dya(i,&
&1)+dya(i,2)))
        xt = 0.5*((2.*dya(i,1)+dya(i,2))*(q(i,0)+q(i,1))-dya(i,1)*(q(i,-1)+q(i,2)))/(dya(i,1)+dya(i,2))
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_bl(i,1) = (-g_q(i,1))+g_xt
        bl(i,1) = xt-q(i,1)
        g_br(i,0) = (-g_q(i,0))+g_xt
        br(i,0) = xt-q(i,0)
        g_xt = 0.57142857*g_dm(i,-1)+0.78571429*g_q(i,-1)+0.21428571*g_q(i,0)
        xt = 4./7.*dm(i,-1)+11./14.*q(i,-1)+3./14.*q(i,0)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_bl(i,0) = (-g_q(i,0))+g_xt
        bl(i,0) = xt-q(i,0)
        g_xt = (-0.57142857)*g_dm(i,2)+0.78571429*g_q(i,2)+0.21428571*g_q(i,1)
        xt = 3./14.*q(i,1)+11./14.*q(i,2)-4./7.*dm(i,2)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(i,1) = (-g_q(i,1))+g_xt
        br(i,1) = xt-q(i,1)
        g_bl(i,2) = (-g_q(i,2))+g_xt
        bl(i,2) = xt-q(i,2)
      end do
      do j = 0, 2
        help_k = ilast-ifirst+1
        call g_pert_ppm( help_k,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),1 )
      end do
    endif
    if (je+1 .eq. npy) then
      do i = ifirst, ilast
        g_bl(i,npy-2) = g_al(i,npy-2)-g_q(i,npy-2)
        bl(i,npy-2) = al(i,npy-2)-q(i,npy-2)
        g_xt = (-(g_q(i,npy-2)*(0.5*dya(i,npy-1)/(dya(i,npy-1)+dya(i,npy-2)))))+g_q(i,npy-1)*(0.5*(2.*dya(i,npy-1)+dya(i,npy-2))/&
&(dya(i,npy-1)+dya(i,npy-2)))-g_q(i,npy+1)*(0.5*dya(i,npy-1)/(dya(i,npy-1)+dya(i,npy-2)))+g_q(i,npy)*(0.5*(2.*dya(i,npy-1)+&
&dya(i,npy-2))/(dya(i,npy-1)+dya(i,npy-2)))
        xt = 0.5*((2.*dya(i,npy-1)+dya(i,npy-2))*(q(i,npy-1)+q(i,npy))-dya(i,npy-1)*(q(i,npy-2)+q(i,npy+1)))/(dya(i,npy-1)+dya(i,&
&npy-2))
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(i,npy-1) = (-g_q(i,npy-1))+g_xt
        br(i,npy-1) = xt-q(i,npy-1)
        g_bl(i,npy) = (-g_q(i,npy))+g_xt
        bl(i,npy) = xt-q(i,npy)
        g_xt = (-0.57142857)*g_dm(i,npy+1)+0.78571429*g_q(i,npy+1)+0.21428571*g_q(i,npy)
        xt = 3./14.*q(i,npy)+11./14.*q(i,npy+1)-4./7.*dm(i,npy+1)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(i,npy) = (-g_q(i,npy))+g_xt
        br(i,npy) = xt-q(i,npy)
        g_xt = 0.57142857*g_dm(i,npy-2)+0.78571429*g_q(i,npy-2)+0.21428571*g_q(i,npy-1)
        xt = 3./14.*q(i,npy-1)+11./14.*q(i,npy-2)+4./7.*dm(i,npy-2)
        g_xt = g_xt*(0.5-sign(0.5,0.-xt))
        xt = max(0.,xt)
        g_br(i,npy-2) = (-g_q(i,npy-2))+g_xt
        br(i,npy-2) = xt-q(i,npy-2)
        g_bl(i,npy-1) = (-g_q(i,npy-1))+g_xt
        bl(i,npy-1) = xt-q(i,npy-1)
      end do
      do j = npy-2, npy
        help_l = ilast-ifirst+1
        call g_pert_ppm( help_l,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),1 )
      end do
    endif
  else
    do j = js-1, je+2
      do i = ifirst, ilast
        g_al(i,j) = g_dm(i,j-1)*r3-g_dm(i,j)*r3+0.5*g_q(i,j-1)+0.5*g_q(i,j)
        al(i,j) = 0.5*(q(i,j-1)+q(i,j))+r3*(dm(i,j-1)-dm(i,j))
      end do
    end do
    if (jord .eq. 11) then
      do j = js-1, je+1
        do i = ifirst, ilast
          g_xt = 2*g_dm(i,j)
          xt = 2.*dm(i,j)
          g_bli = g_al(i,j)-g_q(i,j)
          bli = al(i,j)-q(i,j)
          blh = min(abs(xt),abs(bli))
          g_bl(i,j) = -((g_bli*(0.5-sign(0.5,abs(bli)-abs(xt)))*sign(1.,bli)+g_xt*(0.5+sign(0.5,abs(bli)-abs(xt)))*sign(1.,xt))*&
&sign(1.,blh)*sign(1.,xt))
          bl(i,j) = -sign(blh,xt)
          g_bri = g_al(i,j+1)-g_q(i,j)
          bri = al(i,j+1)-q(i,j)
          g_brh = g_bri*(0.5-sign(0.5,abs(bri)-abs(xt)))*sign(1.,bri)+g_xt*(0.5+sign(0.5,abs(bri)-abs(xt)))*sign(1.,xt)
          brh = min(abs(xt),abs(bri))
          g_br(i,j) = g_brh*sign(1.,brh)*sign(1.,xt)
          br(i,j) = sign(brh,xt)
        end do
      end do
    else if (jord .eq. 12) then
      do j = js-3, je+2
        do i = ifirst, ilast
          g_dq(i,j) = g_q(i,j+1)-g_q(i,j)
          dq(i,j) = q(i,j+1)-q(i,j)
        end do
      end do
      do j = js-1, je+1
        do i = ifirst, ilast
          g_pmp = (-2)*g_dq(i,j)
          pmp = -(2.*dq(i,j))
          g_lac = 1.5*g_dq(i,j+1)+g_pmp
          lac = pmp+1.5*dq(i,j+1)
          g_blj = g_pmp*(0.5-sign(0.5,0.-pmp))
          blj = max(0.,pmp)
          g_blk = g_blj*(0.5+sign(0.5,blj-lac))+g_lac*(0.5-sign(0.5,blj-lac))
          blk = max(blj,lac)
          g_blm = g_pmp*(0.5-sign(0.5,pmp-0.))
          blm = min(0.,pmp)
          g_bln = g_blm*(0.5+sign(0.5,lac-blm))+g_lac*(0.5-sign(0.5,lac-blm))
          bln = min(blm,lac)
          g_bll = g_al(i,j)*(0.5+sign(0.5,al(i,j)-q(i,j)-bln))+g_bln*(0.5-sign(0.5,al(i,j)-q(i,j)-bln))-g_q(i,j)*(0.5+sign(0.5,&
&al(i,j)-q(i,j)-bln))
          bll = max(al(i,j)-q(i,j),bln)
          g_bl(i,j) = g_blk*(0.5+sign(0.5,bll-blk))+g_bll*(0.5-sign(0.5,bll-blk))
          bl(i,j) = min(blk,bll)
          g_pmp = 2*g_dq(i,j-1)
          pmp = 2.*dq(i,j-1)
          g_lac = (-1.5)*g_dq(i,j-2)+g_pmp
          lac = pmp-1.5*dq(i,j-2)
          g_brj = g_pmp*(0.5-sign(0.5,0.-pmp))
          brj = max(0.,pmp)
          g_brk = g_brj*(0.5+sign(0.5,brj-lac))+g_lac*(0.5-sign(0.5,brj-lac))
          brk = max(brj,lac)
          g_brm = g_pmp*(0.5-sign(0.5,pmp-0.))
          brm = min(0.,pmp)
          g_brn = g_brm*(0.5+sign(0.5,lac-brm))+g_lac*(0.5-sign(0.5,lac-brm))
          brn = min(brm,lac)
          g_brl = g_al(i,j+1)*(0.5+sign(0.5,al(i,j+1)-q(i,j)-brn))+g_brn*(0.5-sign(0.5,al(i,j+1)-q(i,j)-brn))-g_q(i,j)*(0.5+&
&sign(0.5,al(i,j+1)-q(i,j)-brn))
          brl = max(al(i,j+1)-q(i,j),brn)
          g_br(i,j) = g_brk*(0.5+sign(0.5,brl-brk))+g_brl*(0.5-sign(0.5,brl-brk))
          br(i,j) = min(brk,brl)
        end do
      end do
    else
      do j = js-1, je+1
        do i = ifirst, ilast
          g_bl(i,j) = g_al(i,j)-g_q(i,j)
          bl(i,j) = al(i,j)-q(i,j)
          g_br(i,j) = g_al(i,j+1)-g_q(i,j)
          br(i,j) = al(i,j+1)-q(i,j)
        end do
      end do
    endif
    if (jord .ne. 11) then
      do j = js-1, je+1
        help_m = ifirst-ilast+1
        call g_pert_ppm( help_m,q(ifirst:ilast,j),g_q(ifirst:ilast,j),bl(ifirst:ilast,j),g_bl(ifirst:ilast,j),br(ifirst:ilast,j),&
&g_br(ifirst:ilast,j),0 )
      end do
    endif
  endif
  do j = js, je+1
    do i = ifirst, ilast
      if (c(i,j) .gt. 0.) then
        g_flux(i,j) = (-(g_bl(i,j-1)*(1.-c(i,j))*c(i,j)))+g_br(i,j-1)*(1.-c(i,j))*(1-c(i,j))-g_c(i,j)*((1.-c(i,j))*(bl(i,j-1)+br(i,&
&j-1))+br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))+g_q(i,j-1)
        flux(i,j) = q(i,j-1)+(1.-c(i,j))*(br(i,j-1)-c(i,j)*(bl(i,j-1)+br(i,j-1)))
      else
        g_flux(i,j) = g_bl(i,j)*(1.+c(i,j))*(1+c(i,j))+g_br(i,j)*(1.+c(i,j))*c(i,j)+g_c(i,j)*((1.+c(i,j))*(bl(i,j)+br(i,j))+bl(i,j)&
&+c(i,j)*(bl(i,j)+br(i,j)))+g_q(i,j)
        flux(i,j) = q(i,j)+(1.+c(i,j))*(bl(i,j)+c(i,j)*(bl(i,j)+br(i,j)))
      endif
    end do
  end do
endif

end subroutine g_fyppm


subroutine g_pert_ppm( im, a0, g_a0, al, g_al, ar, g_ar, iv )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r12 = 1./12.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: im
real, intent(in) :: a0(im)
real, intent(inout) :: al(im)
real, intent(inout) :: ar(im)
real, intent(in) :: g_a0(im)
real, intent(inout) :: g_al(im)
real, intent(inout) :: g_ar(im)
integer, intent(in) :: iv

!==============================================
! declare local variables
!==============================================
real :: a4
real :: a6da
real :: da1
real :: da2
real :: fmin
real :: g_a4
real :: g_a6da
real :: g_da1
real :: g_da2
real :: g_fmin
integer :: i

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (iv .eq. 0) then
  do i = 1, im
    g_a4 = (-3)*g_al(i)-3*g_ar(i)
    a4 = -(3.*(ar(i)+al(i)))
    g_da1 = (-g_al(i))+g_ar(i)
    da1 = ar(i)-al(i)
    if (abs(da1) .lt. (-a4)) then
      g_fmin = g_a0(i)+g_a4*((-(0.25/(a4*a4)*da1**2))+r12)+2*g_da1*0.25/a4*da1
      fmin = a0(i)+0.25/a4*da1**2+a4*r12
      if (fmin .lt. 0.) then
        if (ar(i) .gt. 0. .and. al(i) .gt. 0.) then
          g_ar(i) = 0.
          ar(i) = 0.
          g_al(i) = 0.
          al(i) = 0.
        else if (da1 .gt. 0.) then
          g_ar(i) = (-2)*g_al(i)
          ar(i) = -(2.*al(i))
        else
          g_al(i) = (-2)*g_ar(i)
          al(i) = -(2.*ar(i))
        endif
      endif
    endif
  end do
else
  do i = 1, im
    if (al(i)*ar(i) .lt. 0.) then
      g_da1 = g_al(i)-g_ar(i)
      da1 = al(i)-ar(i)
      g_da2 = 2*g_da1*da1
      da2 = da1**2
      g_a6da = 3*g_al(i)*da1+3*g_ar(i)*da1+3*g_da1*(al(i)+ar(i))
      a6da = 3.*(al(i)+ar(i))*da1
      if (a6da .lt. (-da2)) then
        g_ar(i) = (-2)*g_al(i)
        ar(i) = -(2.*al(i))
      else if (a6da .gt. da2) then
        g_al(i) = (-2)*g_ar(i)
        al(i) = -(2.*ar(i))
      endif
    else
      g_al(i) = 0.
      al(i) = 0.
      g_ar(i) = 0.
      ar(i) = 0.
    endif
  end do
endif

end subroutine g_pert_ppm


subroutine g_xmist_2d( q, g_q, dm, g_dm, ng, iord, ifirst, ilast, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng
real, intent(inout) :: dm(ifirst-ng:ilast+ng,jfirst:jlast)
real, intent(inout) :: g_dm(ifirst-ng:ilast+ng,jfirst:jlast)
real, intent(in) :: g_q(ifirst-ng:ilast+ng,jfirst:jlast)
integer, intent(in) :: iord
real, intent(in) :: q(ifirst-ng:ilast+ng,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
real :: dmh
real :: dmi
real :: dmj
real :: g_dmh
real :: g_dmi
real :: g_dmj
real :: g_qmax
real :: g_qmaxi
real :: g_qmin
real :: g_qmini
integer :: i
integer :: j
real :: qmax
real :: qmaxi
real :: qmin
real :: qmini

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do j = jfirst, jlast
  do i = ifirst-ng+1, ilast+ng-1
    g_dm(i,j) = (-0.25)*g_q(i-1,j)+0.25*g_q(i+1,j)
    dm(i,j) = 0.25*(q(i+1,j)-q(i-1,j))
  end do
end do
if (iord .gt. 0) then
  do j = jfirst, jlast
    do i = ifirst-ng+1, ilast+ng-1
      g_qmaxi = g_q(i-1,j)*(0.5+sign(0.5,q(i-1,j)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i-1,j)-q(i,j)))
      qmaxi = max(q(i-1,j),q(i,j))
      g_qmax = (-g_q(i,j))+g_q(i+1,j)*(0.5-sign(0.5,qmaxi-q(i+1,j)))+g_qmaxi*(0.5+sign(0.5,qmaxi-q(i+1,j)))
      qmax = max(qmaxi,q(i+1,j))-q(i,j)
      g_qmini = g_q(i-1,j)*(0.5+sign(0.5,q(i,j)-q(i-1,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i-1,j)))
      qmini = min(q(i-1,j),q(i,j))
      g_qmin = g_q(i,j)-(g_q(i+1,j)*(0.5-sign(0.5,q(i+1,j)-qmini))+g_qmini*(0.5+sign(0.5,q(i+1,j)-qmini)))
      qmin = q(i,j)-min(qmini,q(i+1,j))
      g_dmh = g_dm(i,j)*sign(1.,dm(i,j))
      dmh = abs(dm(i,j))
      g_dmi = g_dmh*(0.5+sign(0.5,qmin-dmh))+g_qmin*(0.5-sign(0.5,qmin-dmh))
      dmi = min(dmh,qmin)
      g_dmj = g_dmi*(0.5+sign(0.5,qmax-dmi))+g_qmax*(0.5-sign(0.5,qmax-dmi))
      dmj = min(dmi,qmax)
      g_dm(i,j) = g_dmj*sign(1.,dmj)*sign(1.,dm(i,j))
      dm(i,j) = sign(dmj,dm(i,j))
    end do
  end do
endif

end subroutine g_xmist_2d


subroutine g_xtp( fx, g_fx, q, g_q, c, g_c, iord, ifirst, ilast, jfirst, jlast, npx, npy, uniform_ppm )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real, intent(in) :: c(is:ie+1,jfirst:jlast)
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
real, intent(out) :: fx(ifirst:ilast+1,jfirst:jlast)
real, intent(in) :: g_c(is:ie+1,jfirst:jlast)
real, intent(out) :: g_fx(ifirst:ilast+1,jfirst:jlast)
real, intent(in) :: g_q(isd:ied,jfirst:jlast)
integer, intent(in) :: iord
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(in) :: q(isd:ied,jfirst:jlast)
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: dm(ifirst-ng:ilast+ng,jfirst:jlast)
real :: g_dm(ifirst-ng:ilast+ng,jfirst:jlast)
integer :: i
integer :: iu
integer :: j

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (iord .eq. 1) then
  do j = jfirst, jlast
    do i = ifirst, ilast+1
      iu = floor(real(i)-c(i,j))
      g_fx(i,j) = g_q(iu,j)
      fx(i,j) = q(iu,j)
    end do
  end do
else if (abs(iord) .eq. 2) then
  call g_xmist_2d( q,g_q,dm,g_dm,ng,iord,ifirst,ilast,jfirst,jlast )
  do j = jfirst, jlast
    do i = ifirst, ilast+1
      iu = floor(real(i)-c(i,j))
      g_fx(i,j) = (-(g_c(i,j)*dm(iu,j)))+g_dm(iu,j)*(sign(1.,c(i,j))-c(i,j))+g_q(iu,j)
      fx(i,j) = q(iu,j)+(sign(1.,c(i,j))-c(i,j))*dm(iu,j)
    end do
  end do
else
  call g_fxppm( c,g_c,q,g_q,fx,g_fx,iord,ifirst,ilast,jfirst,jlast,npx,npy,uniform_ppm )
endif

end subroutine g_xtp


subroutine g_ymist( q, g_q, dm, g_dm, ng, jord, ifirst, ilast, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng
real, intent(inout) :: dm(ifirst:ilast,jfirst-ng:jlast+ng)
real, intent(inout) :: g_dm(ifirst:ilast,jfirst-ng:jlast+ng)
real, intent(in) :: g_q(ifirst:ilast,jfirst-ng:jlast+ng)
integer, intent(in) :: jord
real, intent(in) :: q(ifirst:ilast,jfirst-ng:jlast+ng)

!==============================================
! declare local variables
!==============================================
real :: dmh
real :: dmi
real :: dmj
real :: g_dmh
real :: g_dmi
real :: g_dmj
real :: g_qmax
real :: g_qmaxi
real :: g_qmin
real :: g_qmini
integer :: i
integer :: j
real :: qmax
real :: qmaxi
real :: qmin
real :: qmini

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do j = jfirst-ng+1, jlast+ng-1
  do i = ifirst, ilast
    g_dm(i,j) = (-0.25)*g_q(i,j-1)+0.25*g_q(i,j+1)
    dm(i,j) = 0.25*(q(i,j+1)-q(i,j-1))
  end do
end do
if (jord .gt. 0) then
  do j = jfirst-ng+1, jlast+ng-1
    do i = ifirst, ilast
      g_qmaxi = g_q(i,j-1)*(0.5+sign(0.5,q(i,j-1)-q(i,j)))+g_q(i,j)*(0.5-sign(0.5,q(i,j-1)-q(i,j)))
      qmaxi = max(q(i,j-1),q(i,j))
      g_qmax = (-g_q(i,j))+g_q(i,j+1)*(0.5-sign(0.5,qmaxi-q(i,j+1)))+g_qmaxi*(0.5+sign(0.5,qmaxi-q(i,j+1)))
      qmax = max(qmaxi,q(i,j+1))-q(i,j)
      g_qmini = g_q(i,j-1)*(0.5+sign(0.5,q(i,j)-q(i,j-1)))+g_q(i,j)*(0.5-sign(0.5,q(i,j)-q(i,j-1)))
      qmini = min(q(i,j-1),q(i,j))
      g_qmin = g_q(i,j)-(g_q(i,j+1)*(0.5-sign(0.5,q(i,j+1)-qmini))+g_qmini*(0.5+sign(0.5,q(i,j+1)-qmini)))
      qmin = q(i,j)-min(qmini,q(i,j+1))
      g_dmh = g_dm(i,j)*sign(1.,dm(i,j))
      dmh = abs(dm(i,j))
      g_dmi = g_dmh*(0.5+sign(0.5,qmin-dmh))+g_qmin*(0.5-sign(0.5,qmin-dmh))
      dmi = min(dmh,qmin)
      g_dmj = g_dmi*(0.5+sign(0.5,qmax-dmi))+g_qmax*(0.5-sign(0.5,qmax-dmi))
      dmj = min(dmi,qmax)
      g_dm(i,j) = g_dmj*sign(1.,dmj)*sign(1.,dm(i,j))
      dm(i,j) = sign(dmj,dm(i,j))
    end do
  end do
endif

end subroutine g_ymist


subroutine g_ytp( fy, g_fy, q, g_q, c, g_c, jord, ifirst, ilast, jfirst, jlast, npx, npy, uniform_ppm )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.43  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: c(isd:ied,js:je+1)
integer, intent(in) :: ifirst
integer, intent(in) :: ilast
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real, intent(out) :: fy(ifirst:ilast,jfirst:jlast+1)
real, intent(in) :: g_c(isd:ied,js:je+1)
real, intent(out) :: g_fy(ifirst:ilast,jfirst:jlast+1)
real, intent(in) :: g_q(ifirst:ilast,jfirst-ng:jlast+ng)
integer, intent(in) :: jord
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(in) :: q(ifirst:ilast,jfirst-ng:jlast+ng)
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: dm(ifirst:ilast,jfirst-ng:jlast+ng)
real :: g_dm(ifirst:ilast,jfirst-ng:jlast+ng)
integer :: i
integer :: j
integer :: jt

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (jord .eq. 1) then
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      jt = floor(real(j)-c(i,j))
      g_fy(i,j) = g_q(i,jt)
      fy(i,j) = q(i,jt)
    end do
  end do
else if (abs(jord) .eq. 2) then
  call g_ymist( q,g_q,dm,g_dm,ng,jord,ifirst,ilast,jfirst,jlast )
  do j = jfirst, jlast+1
    do i = ifirst, ilast
      jt = floor(real(j)-c(i,j))
      g_fy(i,j) = (-(g_c(i,j)*dm(i,jt)))+g_dm(i,jt)*(sign(1.,c(i,j))-c(i,j))+g_q(i,jt)
      fy(i,j) = q(i,jt)+(sign(1.,c(i,j))-c(i,j))*dm(i,jt)
    end do
  end do
else
  call g_fyppm( c,g_c,q,g_q,fy,g_fy,jord,ifirst,ilast,jfirst,jlast,npx,npy,uniform_ppm,dm,g_dm )
endif

end subroutine g_ytp


end module     g_tp_core_mod



