!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.28
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_a2b_edge_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.30  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use pre_direct_new
use fv_grid_utils_mod, only : edge_e,edge_n,edge_s,edge_w,ne_corner,nw_corner,se_corner,sw_corner,van2
use fv_grid_tools_mod, only : dxa,dya,grid_type
use fv_mp_mod, only : gid
use a2b_edge_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains

subroutine g_a2b_ord2( qin, g_qin, qout, g_qout, npx, npy, is, ie, js, je, ng, replace )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.38  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: r3 = 1./3.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ie
integer, intent(in) :: is
integer, intent(in) :: je
integer, intent(in) :: js
integer, intent(in) :: ng
real, intent(inout) :: g_qin(is-ng:ie+ng,js-ng:je+ng)
real, intent(out) :: g_qout(is-ng:ie+ng,js-ng:je+ng)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: qin(is-ng:ie+ng,js-ng:je+ng)
real, intent(out) :: qout(is-ng:ie+ng,js-ng:je+ng)
logical,optional, intent(in) :: replace

!==============================================
! declare local variables
!==============================================
real :: g_q1(npx)
real :: g_q2(npy)
integer :: i
integer :: ie1
integer :: is1
integer :: is2
integer :: j
integer :: je1
integer :: js1
integer :: js2
real :: q1(npx)
real :: q2(npy)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (grid_type .lt. 3) then
  is1 = max(1,is-1)
  js1 = max(1,js-1)
  is2 = max(2,is)
  js2 = max(2,js)
  ie1 = min(npx-1,ie+1)
  je1 = min(npy-1,je+1)
  do j = js2, je1
    do i = is2, ie1
      g_qout(i,j) = 0.25*g_qin(i-1,j-1)+0.25*g_qin(i,j-1)+0.25*g_qin(i-1,j)+0.25*g_qin(i,j)
      qout(i,j) = 0.25*(qin(i-1,j-1)+qin(i,j-1)+qin(i-1,j)+qin(i,j))
    end do
  end do
  if (sw_corner) then
    g_qout(1,1) = (g_qin(1,1)+g_qin(0,1)+g_qin(1,0))*r3
    qout(1,1) = r3*(qin(1,1)+qin(1,0)+qin(0,1))
  endif
  if (se_corner) then
    g_qout(npx,1) = (g_qin(npx-1,1)+g_qin(npx,1)+g_qin(npx-1,0))*r3
    qout(npx,1) = r3*(qin(npx-1,1)+qin(npx-1,0)+qin(npx,1))
  endif
  if (ne_corner) then
    g_qout(npx,npy) = (g_qin(npx-1,npy-1)+g_qin(npx,npy-1)+g_qin(npx-1,npy))*r3
    qout(npx,npy) = r3*(qin(npx-1,npy-1)+qin(npx,npy-1)+qin(npx-1,npy))
  endif
  if (nw_corner) then
    g_qout(1,npy) = (g_qin(1,npy-1)+g_qin(0,npy-1)+g_qin(1,npy))*r3
    qout(1,npy) = r3*(qin(1,npy-1)+qin(0,npy-1)+qin(1,npy))
  endif
  if (is .eq. 1) then
    do j = js1, je1
      g_q2(j) = 0.5*g_qin(1,j)+0.5*g_qin(0,j)
      q2(j) = 0.5*(qin(0,j)+qin(1,j))
    end do
    do j = js2, je1
      g_qout(1,j) = g_q2(j-1)*edge_w(j)+g_q2(j)*(1.-edge_w(j))
      qout(1,j) = edge_w(j)*q2(j-1)+(1.-edge_w(j))*q2(j)
    end do
  endif
  if (ie+1 .eq. npx) then
    do j = js1, je1
      g_q2(j) = 0.5*g_qin(npx-1,j)+0.5*g_qin(npx,j)
      q2(j) = 0.5*(qin(npx-1,j)+qin(npx,j))
    end do
    do j = js2, je1
      g_qout(npx,j) = g_q2(j-1)*edge_e(j)+g_q2(j)*(1.-edge_e(j))
      qout(npx,j) = edge_e(j)*q2(j-1)+(1.-edge_e(j))*q2(j)
    end do
  endif
  if (js .eq. 1) then
    do i = is1, ie1
      g_q1(i) = 0.5*g_qin(i,1)+0.5*g_qin(i,0)
      q1(i) = 0.5*(qin(i,0)+qin(i,1))
    end do
    do i = is2, ie1
      g_qout(i,1) = g_q1(i-1)*edge_s(i)+g_q1(i)*(1.-edge_s(i))
      qout(i,1) = edge_s(i)*q1(i-1)+(1.-edge_s(i))*q1(i)
    end do
  endif
  if (je+1 .eq. npy) then
    do i = is1, ie1
      g_q1(i) = 0.5*g_qin(i,npy-1)+0.5*g_qin(i,npy)
      q1(i) = 0.5*(qin(i,npy-1)+qin(i,npy))
    end do
    do i = is2, ie1
      g_qout(i,npy) = g_q1(i-1)*edge_n(i)+g_q1(i)*(1.-edge_n(i))
      qout(i,npy) = edge_n(i)*q1(i-1)+(1.-edge_n(i))*q1(i)
    end do
  endif
else
  do j = js, je+1
    do i = is, ie+1
      g_qout(i,j) = 0.25*g_qin(i-1,j-1)+0.25*g_qin(i,j-1)+0.25*g_qin(i-1,j)+0.25*g_qin(i,j)
      qout(i,j) = 0.25*(qin(i-1,j-1)+qin(i,j-1)+qin(i-1,j)+qin(i,j))
    end do
  end do
endif
if (present(replace)) then
  if (replace) then
    do j = js, je+1
      do i = is, ie+1
        g_qin(i,j) = g_qout(i,j)
        qin(i,j) = qout(i,j)
      end do
    end do
  endif
endif

end subroutine g_a2b_ord2


subroutine g_a2b_ord4( qin, g_qin, qout, g_qout, npx, npy, is, ie, js, je, ng, replace )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.38  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: a1 = 0.5625
real, parameter :: a2 = -0.0625
real, parameter :: b1 = 7./12.
real, parameter :: b2 = -(1./12.)
real, parameter :: c1 = 2./3.
real, parameter :: c2 = -(1./6.)
real, parameter :: d1 = 0.375
real, parameter :: d2 = -(1./24.)

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ie
integer, intent(in) :: is
integer, intent(in) :: je
integer, intent(in) :: js
integer, intent(in) :: ng
real, intent(inout) :: g_qin(is-ng:ie+ng,js-ng:je+ng)
real, intent(inout) :: g_qout(is-ng:ie+ng,js-ng:je+ng)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: qin(is-ng:ie+ng,js-ng:je+ng)
real, intent(inout) :: qout(is-ng:ie+ng,js-ng:je+ng)
logical,optional, intent(in) :: replace

!==============================================
! declare local variables
!==============================================
real :: g_qx(is:ie+1,js-ng:je+ng)
real :: g_qxx(is-ng:ie+ng,js-ng:je+ng)
real :: g_qy(is-ng:ie+ng,js:je+1)
real :: g_qyy(is-ng:ie+ng,js-ng:je+ng)
real :: gratio
integer :: i
integer :: j
real :: qx(is:ie+1,js-ng:je+ng)
real :: qxx(is-ng:ie+ng,js-ng:je+ng)
real :: qy(is-ng:ie+ng,js:je+1)
real :: qyy(is-ng:ie+ng,js-ng:je+ng)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
if (grid_type .lt. 3) then
  if (sw_corner) then
    g_qout(1,1) = (g_qin(2,-1)+g_qin(-1,2)+g_qin(2,2))*d2+(g_qin(1,1)+g_qin(0,1)+g_qin(1,0))*d1
    qout(1,1) = d1*(qin(1,0)+qin(0,1)+qin(1,1))+d2*(qin(2,-1)+qin(-1,2)+qin(2,2))
  endif
  if (se_corner) then
    g_qout(npx,1) = (g_qin(npx-2,-1)+g_qin(npx-2,2)+g_qin(npx+1,2))*d2+(g_qin(npx-1,1)+g_qin(npx,1)+g_qin(npx-1,0))*d1
    qout(npx,1) = d1*(qin(npx-1,0)+qin(npx-1,1)+qin(npx,1))+d2*(qin(npx-2,-1)+qin(npx-2,2)+qin(npx+1,2))
  endif
  if (ne_corner) then
    g_qout(npx,npy) = (g_qin(npx-2,npy-2)+g_qin(npx+1,npy-2))*d2+(g_qin(npx-1,npy-1)+g_qin(npx,npy-1))*d1+g_qin(npx-2,npy+1)*d2+&
&g_qin(npx-1,npy)*d1
    qout(npx,npy) = d1*(qin(npx-1,npy-1)+qin(npx,npy-1)+qin(npx-1,npy))+d2*(qin(npx-2,npy-2)+qin(npx+1,npy-2)+qin(npx-2,npy+1))
  endif
  if (nw_corner) then
    g_qout(1,npy) = (g_qin(-1,npy-2)+g_qin(2,npy-2))*d2+(g_qin(1,npy-1)+g_qin(0,npy-1))*d1+g_qin(2,npy+1)*d2+g_qin(1,npy)*d1
    qout(1,npy) = d1*(qin(0,npy-1)+qin(1,npy-1)+qin(1,npy))+d2*(qin(-1,npy-2)+qin(2,npy-2)+qin(2,npy+1))
  endif
  do j = max(1,js-2), min(npy-1,je+2)
    do i = max(3,is), min(npx-2,ie+1)
      g_qx(i,j) = g_qin(i-2,j)*b2+g_qin(i-1,j)*b1+g_qin(i+1,j)*b2+g_qin(i,j)*b1
      qx(i,j) = b2*(qin(i-2,j)+qin(i+1,j))+b1*(qin(i-1,j)+qin(i,j))
    end do
  end do
  if (is .eq. 1) then
    do j = max(1,js-2), min(npy-1,je+2)
      gratio = dxa(2,j)/dxa(1,j)
      g_qx(1,j) = (g_qin(-1,j)+g_qin(2,j))*((-0.5)/(1.+gratio))+(g_qin(1,j)+g_qin(0,j))*(0.5*(2+gratio)/(1.+gratio))
      qx(1,j) = 0.5*((2.+gratio)*(qin(0,j)+qin(1,j))-(qin(-1,j)+qin(2,j)))/(1.+gratio)
      g_qx(2,j) = g_qin(2,j)*(3/(2.+2.*gratio))+g_qin(1,j)*(3.*gratio/(2.+2.*gratio))-g_qx(3,j)/(2.+2.*gratio)-g_qx(1,j)*(gratio/&
&(2.+2.*gratio))
      qx(2,j) = (3.*(gratio*qin(1,j)+qin(2,j))-(gratio*qx(1,j)+qx(3,j)))/(2.+2.*gratio)
    end do
    do j = max(3,js), min(npy-2,je+1)
      g_qout(1,j) = g_qx(1,j-2)*a2+g_qx(1,j-1)*a1+g_qx(1,j+1)*a2+g_qx(1,j)*a1
      qout(1,j) = a2*(qx(1,j-2)+qx(1,j+1))+a1*(qx(1,j-1)+qx(1,j))
    end do
    if (js .eq. 1) then
      g_qout(1,2) = (g_qout(1,3)+g_qout(1,1))*c2+(g_qx(1,2)+g_qx(1,1))*c1
      qout(1,2) = c1*(qx(1,1)+qx(1,2))+c2*(qout(1,1)+qout(1,3))
    endif
    if (je+1 .eq. npy) then
      g_qout(1,npy-1) = (g_qout(1,npy-2)+g_qout(1,npy))*c2+(g_qx(1,npy-2)+g_qx(1,npy-1))*c1
      qout(1,npy-1) = c1*(qx(1,npy-2)+qx(1,npy-1))+c2*(qout(1,npy-2)+qout(1,npy))
    endif
  endif
  if (ie+1 .eq. npx) then
    do j = max(1,js-2), min(npy-1,je+2)
      gratio = dxa(npx-2,j)/dxa(npx-1,j)
      g_qx(npx,j) = g_qin(npx-2,j)*((-0.5)/(1.+gratio))+g_qin(npx-1,j)*(0.5*(2+gratio)/(1.+gratio))+g_qin(npx+1,j)*((-0.5)/(1.+&
&gratio))+g_qin(npx,j)*(0.5*(2+gratio)/(1.+gratio))
      qx(npx,j) = 0.5*((2.+gratio)*(qin(npx-1,j)+qin(npx,j))-(qin(npx-2,j)+qin(npx+1,j)))/(1.+gratio)
      g_qx(npx-1,j) = g_qin(npx-2,j)*(3/(2.+2.*gratio))+g_qin(npx-1,j)*(3.*gratio/(2.+2.*gratio))-g_qx(npx-2,j)/(2.+2.*gratio)-&
&g_qx(npx,j)*(gratio/(2.+2.*gratio))
      qx(npx-1,j) = (3.*(qin(npx-2,j)+gratio*qin(npx-1,j))-(gratio*qx(npx,j)+qx(npx-2,j)))/(2.+2.*gratio)
    end do
    do j = max(3,js), min(npy-2,je+1)
      g_qout(npx,j) = g_qx(npx,j-2)*a2+g_qx(npx,j-1)*a1+g_qx(npx,j+1)*a2+g_qx(npx,j)*a1
      qout(npx,j) = a2*(qx(npx,j-2)+qx(npx,j+1))+a1*(qx(npx,j-1)+qx(npx,j))
    end do
    if (js .eq. 1) then
      g_qout(npx,2) = (g_qout(npx,3)+g_qout(npx,1))*c2+(g_qx(npx,2)+g_qx(npx,1))*c1
      qout(npx,2) = c1*(qx(npx,1)+qx(npx,2))+c2*(qout(npx,1)+qout(npx,3))
    endif
    if (je+1 .eq. npy) then
      g_qout(npx,npy-1) = (g_qout(npx,npy-2)+g_qout(npx,npy))*c2+(g_qx(npx,npy-2)+g_qx(npx,npy-1))*c1
      qout(npx,npy-1) = c1*(qx(npx,npy-2)+qx(npx,npy-1))+c2*(qout(npx,npy-2)+qout(npx,npy))
    endif
  endif
  do j = max(3,js), min(npy-2,je+1)
    do i = max(1,is-2), min(npx-1,ie+2)
      g_qy(i,j) = g_qin(i,j-2)*b2+g_qin(i,j-1)*b1+g_qin(i,j+1)*b2+g_qin(i,j)*b1
      qy(i,j) = b2*(qin(i,j-2)+qin(i,j+1))+b1*(qin(i,j-1)+qin(i,j))
    end do
  end do
  if (js .eq. 1) then
    do i = max(1,is-2), min(npx-1,ie+2)
      gratio = dya(i,2)/dya(i,1)
      g_qy(i,1) = (g_qin(i,-1)+g_qin(i,2))*((-0.5)/(1.+gratio))+(g_qin(i,1)+g_qin(i,0))*(0.5*(2+gratio)/(1.+gratio))
      qy(i,1) = 0.5*((2.+gratio)*(qin(i,0)+qin(i,1))-(qin(i,-1)+qin(i,2)))/(1.+gratio)
      g_qy(i,2) = g_qin(i,2)*(3/(2.+2.*gratio))+g_qin(i,1)*(3.*gratio/(2.+2.*gratio))-g_qy(i,3)/(2.+2.*gratio)-g_qy(i,1)*(gratio/&
&(2.+2.*gratio))
      qy(i,2) = (3.*(gratio*qin(i,1)+qin(i,2))-(gratio*qy(i,1)+qy(i,3)))/(2.+2.*gratio)
    end do
    do i = max(3,is), min(npx-2,ie+1)
      g_qout(i,1) = g_qy(i-2,1)*a2+g_qy(i-1,1)*a1+g_qy(i+1,1)*a2+g_qy(i,1)*a1
      qout(i,1) = a2*(qy(i-2,1)+qy(i+1,1))+a1*(qy(i-1,1)+qy(i,1))
    end do
    if (is .eq. 1) then
      g_qout(2,1) = (g_qout(3,1)+g_qout(1,1))*c2+(g_qy(2,1)+g_qy(1,1))*c1
      qout(2,1) = c1*(qy(1,1)+qy(2,1))+c2*(qout(1,1)+qout(3,1))
    endif
    if (ie+1 .eq. npx) then
      g_qout(npx-1,1) = (g_qout(npx-2,1)+g_qout(npx,1))*c2+(g_qy(npx-2,1)+g_qy(npx-1,1))*c1
      qout(npx-1,1) = c1*(qy(npx-2,1)+qy(npx-1,1))+c2*(qout(npx-2,1)+qout(npx,1))
    endif
  endif
  if (je+1 .eq. npy) then
    do i = max(1,is-2), min(npx-1,ie+2)
      gratio = dya(i,npy-2)/dya(i,npy-1)
      g_qy(i,npy) = g_qin(i,npy-2)*((-0.5)/(1.+gratio))+g_qin(i,npy-1)*(0.5*(2+gratio)/(1.+gratio))+g_qin(i,npy+1)*((-0.5)/(1.+&
&gratio))+g_qin(i,npy)*(0.5*(2+gratio)/(1.+gratio))
      qy(i,npy) = 0.5*((2.+gratio)*(qin(i,npy-1)+qin(i,npy))-(qin(i,npy-2)+qin(i,npy+1)))/(1.+gratio)
      g_qy(i,npy-1) = g_qin(i,npy-2)*(3/(2.+2.*gratio))+g_qin(i,npy-1)*(3.*gratio/(2.+2.*gratio))-g_qy(i,npy-2)/(2.+2.*gratio)-&
&g_qy(i,npy)*(gratio/(2.+2.*gratio))
      qy(i,npy-1) = (3.*(qin(i,npy-2)+gratio*qin(i,npy-1))-(gratio*qy(i,npy)+qy(i,npy-2)))/(2.+2.*gratio)
    end do
    do i = max(3,is), min(npx-2,ie+1)
      g_qout(i,npy) = g_qy(i-2,npy)*a2+g_qy(i-1,npy)*a1+g_qy(i+1,npy)*a2+g_qy(i,npy)*a1
      qout(i,npy) = a2*(qy(i-2,npy)+qy(i+1,npy))+a1*(qy(i-1,npy)+qy(i,npy))
    end do
    if (is .eq. 1) then
      g_qout(2,npy) = (g_qout(3,npy)+g_qout(1,npy))*c2+(g_qy(2,npy)+g_qy(1,npy))*c1
      qout(2,npy) = c1*(qy(1,npy)+qy(2,npy))+c2*(qout(1,npy)+qout(3,npy))
    endif
    if (ie+1 .eq. npx) then
      g_qout(npx-1,npy) = (g_qout(npx-2,npy)+g_qout(npx,npy))*c2+(g_qy(npx-2,npy)+g_qy(npx-1,npy))*c1
      qout(npx-1,npy) = c1*(qy(npx-2,npy)+qy(npx-1,npy))+c2*(qout(npx-2,npy)+qout(npx,npy))
    endif
  endif
  do j = max(3,js), min(npy-2,je+1)
    do i = max(2,is), min(npx-1,ie+1)
      g_qxx(i,j) = g_qx(i,j-2)*a2+g_qx(i,j-1)*a1+g_qx(i,j+1)*a2+g_qx(i,j)*a1
      qxx(i,j) = a2*(qx(i,j-2)+qx(i,j+1))+a1*(qx(i,j-1)+qx(i,j))
    end do
  end do
  if (js .eq. 1) then
    do i = max(2,is), min(npx-1,ie+1)
      g_qxx(i,2) = g_qout(i,1)*c2+(g_qx(i,2)+g_qx(i,1))*c1+g_qxx(i,3)*c2
      qxx(i,2) = c1*(qx(i,1)+qx(i,2))+c2*(qout(i,1)+qxx(i,3))
    end do
  endif
  if (je+1 .eq. npy) then
    do i = max(2,is), min(npx-1,ie+1)
      g_qxx(i,npy-1) = g_qout(i,npy)*c2+(g_qx(i,npy-2)+g_qx(i,npy-1))*c1+g_qxx(i,npy-2)*c2
      qxx(i,npy-1) = c1*(qx(i,npy-2)+qx(i,npy-1))+c2*(qout(i,npy)+qxx(i,npy-2))
    end do
  endif
  do j = max(2,js), min(npy-1,je+1)
    do i = max(3,is), min(npx-2,ie+1)
      g_qyy(i,j) = g_qy(i-2,j)*a2+g_qy(i-1,j)*a1+g_qy(i+1,j)*a2+g_qy(i,j)*a1
      qyy(i,j) = a2*(qy(i-2,j)+qy(i+1,j))+a1*(qy(i-1,j)+qy(i,j))
    end do
    if (is .eq. 1) then
      g_qyy(2,j) = g_qout(1,j)*c2+(g_qy(2,j)+g_qy(1,j))*c1+g_qyy(3,j)*c2
      qyy(2,j) = c1*(qy(1,j)+qy(2,j))+c2*(qout(1,j)+qyy(3,j))
    endif
    if (ie+1 .eq. npx) then
      g_qyy(npx-1,j) = g_qout(npx,j)*c2+(g_qy(npx-2,j)+g_qy(npx-1,j))*c1+g_qyy(npx-2,j)*c2
      qyy(npx-1,j) = c1*(qy(npx-2,j)+qy(npx-1,j))+c2*(qout(npx,j)+qyy(npx-2,j))
    endif
    do i = max(2,is), min(npx-1,ie+1)
      g_qout(i,j) = 0.5*g_qxx(i,j)+0.5*g_qyy(i,j)
      qout(i,j) = 0.5*(qxx(i,j)+qyy(i,j))
    end do
  end do
else
  do j = js-2, je+2
    do i = is, ie+1
      g_qx(i,j) = g_qin(i-2,j)*b2+g_qin(i-1,j)*b1+g_qin(i+1,j)*b2+g_qin(i,j)*b1
      qx(i,j) = b1*(qin(i-1,j)+qin(i,j))+b2*(qin(i-2,j)+qin(i+1,j))
    end do
  end do
  do j = js, je+1
    do i = is-2, ie+2
      g_qy(i,j) = g_qin(i,j-2)*b2+g_qin(i,j-1)*b1+g_qin(i,j+1)*b2+g_qin(i,j)*b1
      qy(i,j) = b1*(qin(i,j-1)+qin(i,j))+b2*(qin(i,j-2)+qin(i,j+1))
    end do
  end do
  do j = js, je+1
    do i = is, ie+1
      g_qout(i,j) = 0.5*g_qx(i,j-2)*a2+0.5*g_qx(i,j-1)*a1+0.5*g_qx(i,j+1)*a2+0.5*g_qx(i,j)*a1+0.5*g_qy(i-2,j)*a2+0.5*g_qy(i-1,j)*&
&a1+0.5*g_qy(i+1,j)*a2+0.5*g_qy(i,j)*a1
      qout(i,j) = 0.5*(a1*(qx(i,j-1)+qx(i,j)+qy(i-1,j)+qy(i,j))+a2*(qx(i,j-2)+qx(i,j+1)+qy(i-2,j)+qy(i+1,j)))
    end do
  end do
endif
if (present(replace)) then
  if (replace) then
    do j = js, je+1
      do i = is, ie+1
        g_qin(i,j) = g_qout(i,j)
        qin(i,j) = qout(i,j)
      end do
    end do
  endif
endif

end subroutine g_a2b_ord4


end module     g_a2b_edge_mod


