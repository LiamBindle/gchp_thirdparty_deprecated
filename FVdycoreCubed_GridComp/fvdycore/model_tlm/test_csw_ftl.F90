!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.28
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine g_geopk( ptop, pe, peln, delp, g_delp, pk, g_pk, gz, g_gz, hs, pt, g_pt, km, akap, last_call, dp_check, cg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.28  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: akap
logical, intent(in) :: cg
integer, intent(in) :: km
real, intent(inout) :: delp(isd:ied,jsd:jed,km)
logical, intent(in) :: dp_check
real, intent(inout) :: g_delp(isd:ied,jsd:jed,km)
real, intent(out) :: g_gz(isd:ied,jsd:jed,km+1)
real, intent(out) :: g_pk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: g_pt(isd:ied,jsd:jed,km)
real, intent(out) :: gz(isd:ied,jsd:jed,km+1)
real, intent(in) :: hs(isd:ied,jsd:jed)
logical, intent(in) :: last_call
real, intent(out) :: pe(is-1:ie+1,km+1,js-1:je+1)
real, intent(out) :: peln(is:ie,km+1,js:je)
real, intent(out) :: pk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,km)
real, intent(in) :: ptop

!==============================================
! declare local variables
!==============================================
real :: a2b_ord
real :: g_logp(is-2:ie+2)
real :: g_p1d(is-2:ie+2)
integer :: i
integer :: ifirst
integer :: ilast
integer :: j
integer :: jfirst
integer :: jlast
integer :: k
real :: logp(is-2:ie+2)
real :: p1d(is-2:ie+2)
real :: ptk

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
ptk = ptop**akap
ifirst = is-1
jfirst = js-1
ilast = ie+1
jlast = je+1
if (( .not. cg) .and. a2b_ord .eq. 4) then
  ifirst = is-2
  ilast = ie+2
  jfirst = js-2
  jlast = je+2
endif
do j = jfirst, jlast
  do i = ifirst, ilast
    g_p1d(i) = 0.
    p1d(i) = ptop
    g_pk(i,j,1) = 0.
    pk(i,j,1) = ptk
    g_gz(i,j,km+1) = 0.
    gz(i,j,km+1) = hs(i,j)
  end do
  do k = 2, km+1
    do i = ifirst, ilast
      g_p1d(i) = g_delp(i,j,k-1)+g_p1d(i)
      p1d(i) = p1d(i)+delp(i,j,k-1)
      g_logp(i) = g_p1d(i)*(1./p1d(i))
      logp(i) = log(p1d(i))
      g_pk(i,j,k) = g_logp(i)*akap*exp(akap*logp(i))
      pk(i,j,k) = exp(akap*logp(i))
    end do
  end do
  do k = km, 1, -1
    do i = ifirst, ilast
      g_gz(i,j,k) = g_gz(i,j,k+1)+g_pk(i,j,k+1)*pt(i,j,k)-g_pk(i,j,k)*pt(i,j,k)+g_pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
      gz(i,j,k) = gz(i,j,k+1)+pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
    end do
  end do
end do

end subroutine g_geopk


subroutine g_test_csw( delpc, g_delpc, delp, g_delp, ptc, g_ptc, pt, g_pt, u, g_u, v, g_v, w, g_w, uc, g_uc, vc, g_vc, ua, g_ua, &
&va, g_va, omga, ut, vt, dt, dt2, hydrostatic, dord4, ptop, pe, peln, pkc, g_pkc, gz, g_gz, phis, akap, npx, npy, npz, ng, divg_d, &
&g_divg_d, pfull, mfx, mfy, cx, cy, crx, xfx, cry, yfx, uniform_ppm, last_step )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.28  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use g_sw_core_mod, only : g_c_sw, g_d_sw, g_divergence_corner
use g_a2b_edge_mod, only : g_a2b_ord2

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real :: akap
integer :: npz
real :: crx(is:ie+1,jsd:jed,npz)
real :: cry(isd:ied,js:je+1,npz)
real :: cx(is:ie+1,jsd:jed,npz)
real :: cy(isd:ied,js:je+1,npz)
real :: delp(isd:ied,jsd:jed,npz)
real :: delpc(isd:ied,jsd:jed,npz)
real :: divg_d(isd:ied+1,jsd:jed+1,npz)
logical :: dord4
real :: dt
real :: dt2
real :: g_delp(isd:ied,jsd:jed,npz)
real :: g_delpc(isd:ied,jsd:jed,npz)
real :: g_divg_d(isd:ied+1,jsd:jed+1,npz)
real :: g_gz(isd:ied,jsd:jed,npz+1)
real :: g_pkc(isd:ied,jsd:jed,npz+1)
real :: g_pt(isd:ied,jsd:jed,npz)
real :: g_ptc(isd:ied,jsd:jed,npz)
real :: g_u(isd:ied,jsd:jed+1,npz)
real :: g_ua(isd:ied,jsd:jed,npz)
real :: g_uc(isd:ied+1,jsd:jed,npz)
real :: g_v(isd:ied+1,jsd:jed,npz)
real :: g_va(isd:ied,jsd:jed,npz)
real :: g_vc(isd:ied,jsd:jed+1,npz)
real :: g_w(isd:ied,jsd:jed,npz)
real :: gz(isd:ied,jsd:jed,npz+1)
logical :: hydrostatic
logical :: last_step
real :: mfx(is:ie+1,js:je,npz)
real :: mfy(is:ie,js:je+1,npz)
integer :: ng
integer :: npx
integer :: npy
real :: omga(isd:ied,jsd:jed,npz)
real :: pe(is-1:ie+1,npz+1,js-1:je+1)
real :: peln(is:ie,npz+1,js:je)
real :: pfull(npz)
real :: phis(isd:ied,jsd:jed)
real :: pkc(isd:ied,jsd:jed,npz+1)
real :: pt(isd:ied,jsd:jed,npz)
real :: ptc(isd:ied,jsd:jed,npz)
real :: ptop
real :: u(isd:ied,jsd:jed+1,npz)
real :: ua(isd:ied,jsd:jed,npz)
real :: uc(isd:ied+1,jsd:jed,npz)
logical :: uniform_ppm
real :: ut(isd:ied,jsd:jed,npz)
real :: v(isd:ied+1,jsd:jed,npz)
real :: va(isd:ied,jsd:jed,npz)
real :: vc(isd:ied,jsd:jed+1,npz)
real :: vt(isd:ied,jsd:jed,npz)
real :: w(isd:ied,jsd:jed,npz)
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)

!==============================================
! declare local variables
!==============================================
real :: d_divg
real :: g_crxh(is:ie+1,jsd:jed,npz)
real :: g_cryh(isd:ied,js:je+1,npz)
real :: g_uth(isd:ied,jsd:jed,npz)
real :: g_vth(isd:ied,jsd:jed,npz)
real :: g_vti(isd:ied,jsd:jed,npz)
real :: g_wk(isd:ied,jsd:jed)
real :: g_xfxh(is:ie+1,jsd:jed,npz)
real :: g_yfxh(isd:ied,js:je+1,npz)
integer :: help_h
integer :: help_i
real :: help_l
real :: help_m
real :: help_n
integer :: hord_m
integer :: hord_t
integer :: hord_v
integer :: i
integer :: ieb1
integer :: ism1
integer :: j
integer :: jeb1
integer :: jsm1
integer :: k
real :: wk(isd:ied,jsd:jed)

!----------------------------------------------
! RESET ACTIVE INPUT VARIABLES
!----------------------------------------------
g_divg_d(:,:,:) = 0.
g_gz(:,:,:) = 0.
g_pkc(:,:,:) = 0.
g_w(:,:,:) = 0.

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, npz
  g_uth = 0.
  g_vti = 0.
  call g_c_sw( delpc(isd,jsd,k),g_delpc(isd,jsd,k),delp(isd,jsd,k),g_delp(isd,jsd,k),ptc(isd,jsd,k),g_ptc(isd,jsd,k),pt(isd,jsd,k),&
&g_pt(isd,jsd,k),u(isd,jsd,k),g_u(isd,jsd,k),v(isd,jsd,k),g_v(isd,jsd,k),w(isd,jsd,k),uc(isd,jsd,k),g_uc(isd,jsd,k),vc(isd,jsd,k)&
&,g_vc(isd,jsd,k),ua(isd,jsd,k),g_ua(isd,jsd,k),va(isd,jsd,k),g_va(isd,jsd,k),omga(isd,jsd,k),ut(isd,jsd,k),g_uth,vt(isd,jsd,k),&
&g_vti,dt2,hydrostatic,dord4 )
end do
if (hydrostatic) then
  call g_geopk( ptop,pe,peln,delpc,g_delpc,pkc,g_pkc,gz,g_gz,phis,ptc,g_ptc,npz,akap, .false. , .false. , .true.  )
endif
ieb1 = ie+1
jeb1 = je+1
ism1 = is-1
jsm1 = js-1
do k = 1, npz
  if (hydrostatic) then
    do j = jsm1, jeb1
      do i = ism1, ieb1
        g_wk(i,j) = g_pkc(i,j,k+1)-g_pkc(i,j,k)
        wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
      end do
    end do
  else
    do j = jsd, jed
      do i = isd, ied
        g_wk(i,j) = g_delpc(i,j,k)
        wk(i,j) = delpc(i,j,k)
      end do
    end do
  endif
  do j = js, je
    do i = is, ieb1
      g_uc(i,j,k) = g_gz(i-1,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))-g_gz(i,j,k+1)*dt2*rdxc(i,j)/&
&(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k))+g_gz(i-1,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k))-&
&g_gz(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))+g_pkc(i-1,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))&
&*(gz(i-1,j,k)-gz(i,j,k+1))+g_pkc(i,j,k+1)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))-g_pkc(i-1,j,k)*dt2*&
&rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))-g_pkc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k)-gz(i,j,&
&k+1))+g_uc(i,j,k)-g_wk(i-1,j)*dt2*rdxc(i,j)/((wk(i-1,j)+wk(i,j))*(wk(i-1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+&
&1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))-g_wk(i,j)*dt2*rdxc(i,j)/((wk(i-1,j)+wk(i,j))*(wk(i-&
&1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
      uc(i,j,k) = uc(i,j,k)+dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-&
&gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
    end do
  end do
  do j = js, jeb1
    do i = is, ie
      g_vc(i,j,k) = g_gz(i,j-1,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))+g_gz(i,j-1,k)*dt2*rdyc(i,j)/&
&(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k))-g_gz(i,j,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k))-&
&g_gz(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))+g_pkc(i,j-1,k+1)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))&
&*(gz(i,j-1,k)-gz(i,j,k+1))-g_pkc(i,j-1,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))+g_pkc(i,j,k+1)*dt2*&
&rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))-g_pkc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k)-gz(i,j,&
&k+1))+g_vc(i,j,k)-g_wk(i,j-1)*dt2*rdyc(i,j)/((wk(i,j-1)+wk(i,j))*(wk(i,j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+&
&1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))-g_wk(i,j)*dt2*rdyc(i,j)/((wk(i,j-1)+wk(i,j))*(wk(i,&
&j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      vc(i,j,k) = vc(i,j,k)+dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-&
&gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
    end do
  end do
end do
      call mpp_update_domains( uc, vc, domain, gridtype=CGRID_NE, complete=.true.)
      call mpp_update_domains( g_uc, g_vc, domain, gridtype=CGRID_NE, complete=.true.)
if (dord4) then
  call g_divergence_corner( u,g_u,v,g_v,ua,g_ua,va,g_va,divg_d,g_divg_d,npz )
endif
do k = 1, npz
  hord_m = hord_mt
  hord_t = hord_tm
  hord_v = hord_vt
  if (n_sponge .eq. (-1) .or. npz .eq. 1) then
    d_divg = dddmp
  else
    if (k .le. n_sponge .and. npz .gt. 16) then
      hord_v = 1
      hord_t = 1
      help_l = 6.*dddmp
      if (0.24 .gt. help_l) then
        d_divg = help_l
      else
        d_divg = 0.24
      endif
      if (0.02 .lt. d_divg) then
        d_divg = d_divg
      else
        d_divg = 0.02
      endif
    else if (k .eq. n_sponge+1 .and. npz .gt. 16) then
      help_m = 4.*dddmp
      if (0.24 .gt. help_m) then
        d_divg = help_m
      else
        d_divg = 0.24
      endif
      if (0.01 .lt. d_divg) then
        d_divg = d_divg
      else
        d_divg = 0.01
      endif
    else
      help_n = dddmp*(1.-3.*tanh(0.1*log(pfull(k)/pfull(npz))))
      if (0.24 .gt. help_n) then
        d_divg = help_n
      else
        d_divg = 0.24
      endif
    endif
  endif
  if (d_ext .gt. 0.) then
    call g_a2b_ord2( delp(isd,jsd,k),g_delp(isd,jsd,k),wk,g_wk,npx,npy,is,ie,js,je,ng, .false.  )
  endif
  g_vth = 0.
  g_crxh = 0.
  g_cryh = 0.
  g_xfxh = 0.
  g_yfxh = 0.
  call g_d_sw( vt(isd,jsd,k),g_vth,delp(isd,jsd,k),g_delp(isd,jsd,k),ptc(isd,jsd,k),g_ptc(isd,jsd,k),pt(isd,jsd,k),g_pt(isd,jsd,k),&
&u(isd,jsd,k),g_u(isd,jsd,k),v(isd,jsd,k),g_v(isd,jsd,k),w(isd,jsd,k),g_w(isd,jsd,k),uc(isd,jsd,k),g_uc(isd,jsd,k),vc(isd,jsd,k),&
&g_vc(isd,jsd,k),ua(isd,jsd,k),g_ua(isd,jsd,k),va(isd,jsd,k),g_va(isd,jsd,k),divg_d(isd,jsd,k),g_divg_d(isd,jsd,k),mfx(is,js,k),&
&mfy(is,js,k),cx(is,jsd,k),cy(isd,js,k),crx(is,jsd,k),g_crxh,cry(isd,js,k),g_cryh,xfx(is,jsd,k),g_xfxh,yfx(isd,js,k),g_yfxh,dt,&
&hord_m,hord_v,hord_t,d_divg,dddm4,hydrostatic,uniform_ppm )
end do

end subroutine g_test_csw

