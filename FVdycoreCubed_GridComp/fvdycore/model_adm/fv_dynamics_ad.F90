!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     adfv_dynamics_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants_mod, only : grav,hlv,pi,radius
use dyn_core_mod, only : dyn_core
use mapz_module, only : compute_total_energy, lagrangian_to_eulerian
use tracer_2d_mod, only : tracer_2d, tracer_2d_1l
use fv_pack_mod, only : full_phys,hord_mt,hord_tm,hord_tr,hord_vt,k_top,kord_mt,kord_tm,kord_tr,nf_omega,p_ref,remap_t,rf_center,&
&tau,uniform_ppm,z_tracer
use grid_utils, only : da_min,ne_corner,nw_corner,ptop,se_corner,sina_u,sina_v,sw_corner,cubed_to_latlon, g_sum
use grid_tools, only : area,dx,dxa,dy,dya,rarea,rdxc,rdyc
use mp_mod, only : gid,ie,ied,is,isd,je,jed,js,jsd
use timingmodule, only : timing_off, timing_on
use diag_manager_mod, only : send_data
use fv_diagnostics_mod, only : fv_time,id_divg,id_te
use fv_dynamics_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine adfv_dynamics( npx, npy, npz, nq, ng, bdt, consv_te, fill, reproduce_sum, kappa, cp_air, zvir, ks, ncnst, n_split, &
&q_split, u, adu, v, adv, w, adw, delz, addelz, hydrostatic, pt, adpt, delp, addelp, q, adq, pe, adpe, pk, adpk, peln, pkz, adpkz, &
&phis, omga, adomga, ua, adua, va, adva, uc, vc, ak, bk, mfx, admfx, mfy, admfy, cx, adcx, cy, adcy, ze0, adze0, hybrid_z )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use admapz_module, only : adcompute_total_energy, adlagrangian_to_eulerian
use adtracer_2d_mod, only : adtracer_2d, adtracer_2d_1l
use addyn_core_mod, only : addyn_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: adcx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: adcy(isd:ied,js:je+1,npz)
real, intent(inout) :: addelp(isd:ied,jsd:jed,npz)
real, intent(inout) :: addelz(is:ie,js:je,npz)
real, intent(inout) :: admfx(is:ie+1,js:je,npz)
real, intent(inout) :: admfy(is:ie,js:je+1,npz)
real, intent(inout) :: adomga(isd:ied,jsd:jed,npz)
real, intent(inout) :: adpe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: adpk(is:ie,js:je,npz+1)
real, intent(inout) :: adpkz(is:ie,js:je,npz)
real, intent(inout) :: adpt(isd:ied,jsd:jed,npz)
integer, intent(in) :: ncnst
real, intent(inout) :: adq(isd:ied,jsd:jed,npz,ncnst)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adua(isd:ied,jsd:jed,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adva(isd:ied,jsd:jed,npz)
real, intent(inout) :: adw(isd:ied,jsd:jed,npz)
real, intent(inout) :: adze0(is:ie,js:je,npz+1)
real, intent(in) :: ak(npz+1)
real, intent(in) :: bdt
real, intent(in) :: bk(npz+1)
real, intent(in) :: consv_te
real, intent(in) :: cp_air
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
logical, intent(in) :: fill
logical, intent(in) :: hybrid_z
logical, intent(in) :: hydrostatic
real, intent(in) :: kappa
integer, intent(in) :: ks
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: nq
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pkz(is:ie,js:je,npz)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: q(isd:ied,jsd:jed,npz,ncnst)
integer, intent(in) :: q_split
logical, intent(in) :: reproduce_sum
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)
real, intent(inout) :: ze0(is:ie,js:je,npz+1)
real, intent(in) :: zvir

!==============================================
! declare local variables
!==============================================
real :: addp1(is:ie,js:je,1:npz)
real, allocatable :: adpelnh(:,:,:)
real :: adpem(is-1:ie+1,1:npz+1,js-1:je+1)
real :: adq2(isd:ied,jsd:jed,nq)
real, allocatable :: aduch(:,:,:)
real, allocatable :: advch(:,:,:)
real :: akap
real :: delph(lbound(delp,1):ubound(delp,1),lbound(delp,2):ubound(delp,2),lbound(delp,3):ubound(delp,3))
real :: dp1(is:ie,js:je,1:npz)
integer :: i
integer :: iq
integer :: j
integer :: k
integer :: k1
integer :: ka1
real :: peh(lbound(pe,1):ubound(pe,1),lbound(pe,2):ubound(pe,2),lbound(pe,3):ubound(pe,3))
real :: pem(is-1:ie+1,1:npz+1,js-1:je+1)
real :: pfull(npz)
real :: ph1
real :: ph2
real :: pkh(lbound(pk,1):ubound(pk,1),lbound(pk,2):ubound(pk,2),lbound(pk,3):ubound(pk,3))
real :: pth(lbound(pt,1):ubound(pt,1),lbound(pt,2):ubound(pt,2),lbound(pt,3):ubound(pt,3))
real :: q2(isd:ied,jsd:jed,nq)
real :: qh(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
real :: rg
real :: te_2d(is:ie,js:je)
real :: teq(is:ie,js:je)
real :: time_total
real :: uah(lbound(ua,1):ubound(ua,1),lbound(ua,2):ubound(ua,2),lbound(ua,3):ubound(ua,3))
real :: uh(lbound(u,1):ubound(u,1),lbound(u,2):ubound(u,2),lbound(u,3):ubound(u,3))
logical :: used
real :: vah(lbound(va,1):ubound(va,1),lbound(va,2):ubound(va,2),lbound(va,3):ubound(va,3))
real :: vh(lbound(v,1):ubound(v,1),lbound(v,2):ubound(v,2),lbound(v,3):ubound(v,3))
real :: wh(lbound(w,1):ubound(w,1),lbound(w,2):ubound(w,2),lbound(w,3):ubound(w,3))

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
wh(:,:,:) = w(:,:,:)
vah(:,:,:) = va(:,:,:)
vh(:,:,:) = v(:,:,:)
uah(:,:,:) = ua(:,:,:)
uh(:,:,:) = u(:,:,:)
qh(:,:,:,:) = q(:,:,:,:)
pth(:,:,:) = pt(:,:,:)
pkh(:,:,:) = pk(:,:,:)
peh(:,:,:) = pe(:,:,:)
delph(:,:,:) = delp(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
addp1(:,:,:) = 0.
adpem(:,:,:) = 0.
adq2(:,:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
akap = kappa
rg = kappa*cp_air
do k = 1, npz
  ph1 = ak(k)+bk(k)*p_ref
  ph2 = ak(k+1)+bk(k+1)*p_ref
  pfull(k) = (ph2-ph1)/log(ph2/ph1)
end do
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
endif
if (tau .gt. 0.) then
  call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
endif
do k = 1, npz
  do j = js, je
    do i = is, ie
      pt(i,j,k) = cp_air*pt(i,j,k)/pkz(i,j,k)*(1.+zvir*q(i,j,k,1))
    end do
  end do
end do
do k = 1, npz
  do j = js, je
    do i = is, ie
      dp1(i,j,k) = delp(i,j,k)
    end do
  end do
end do
call dyn_core( npx,npy,npz,ng,bdt,n_split,cp_air,akap,grav,hydrostatic,u,v,w,delz,pt,delp,pe,pk,phis,omga,ptop,pfull,ua,va,uc,vc,&
&mfx,mfy,cx,cy,pem,pkz,uniform_ppm,time_total )
if (nq .ne. 0) then
  if (z_tracer) then
    do k = 1, npz
      do iq = 1, nq
        do j = js, je
          do i = is, ie
            q2(i,j,iq) = q(i,j,k,iq)
          end do
        end do
      end do
      call tracer_2d_1l( q2,dp1(is,js,k),mfx(is,js,k),mfy(is,js,k),cx(is,jsd,k),cy(isd,js,k),npx,npy,npz,nq,hord_tr,q_split,k,q,&
&bdt,uniform_ppm,id_divg )
    end do
  else
    call tracer_2d( q,dp1,mfx,mfy,cx,cy,npx,npy,npz,nq,hord_tr,q_split,bdt,uniform_ppm,id_divg )
  endif
  if (id_divg .gt. 0) then
    used = send_data(id_divg,dp1,fv_time)
  endif
endif
if (npz .gt. 4) then
  allocate( adpelnh(is:ie,1:npz+1,js:je) )
  adpelnh(:,:,:) = 0.
  call adlagrangian_to_eulerian( consv_te,pe,adpe,delp,addelp,pkz,adpkz,pk,adpk,npz,is,ie,js,je,isd,ied,jsd,jed,nq,u,adu,v,adv,&
&delz,addelz,pt,adpt,q,adq,phis,grav,zvir,cp_air,akap,kord_mt,kord_tr,kord_tm,peln,adpelnh,ua,adua,va,adva,omga,adomga,dp1,addp1,&
&fill,reproduce_sum,ak,bk,ks,ze0,adze0,remap_t,hydrostatic,hybrid_z,k_top,ncnst )
  deallocate( adpelnh )
endif
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pk(:,:,:) = pkh(:,:,:)
pt(:,:,:) = pth(:,:,:)
q(:,:,:,:) = qh(:,:,:,:)
u(:,:,:) = uh(:,:,:)
ua(:,:,:) = uah(:,:,:)
v(:,:,:) = vh(:,:,:)
va(:,:,:) = vah(:,:,:)
w(:,:,:) = wh(:,:,:)
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
endif
if (tau .gt. 0.) then
  call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
endif
do k = 1, npz
  do j = js, je
    do i = is, ie
      pt(i,j,k) = cp_air*pt(i,j,k)/pkz(i,j,k)*(1.+zvir*q(i,j,k,1))
    end do
  end do
end do
do k = 1, npz
  do j = js, je
    do i = is, ie
      dp1(i,j,k) = delp(i,j,k)
    end do
  end do
end do
call dyn_core( npx,npy,npz,ng,bdt,n_split,cp_air,akap,grav,hydrostatic,u,v,w,delz,pt,delp,pe,pk,phis,omga,ptop,pfull,ua,va,uc,vc,&
&mfx,mfy,cx,cy,pem,pkz,uniform_ppm,time_total )
if (nq .ne. 0) then
  if (z_tracer) then
    do k = npz, 1, -1
      delp(:,:,:) = delph(:,:,:)
      pe(:,:,:) = peh(:,:,:)
      pk(:,:,:) = pkh(:,:,:)
      pt(:,:,:) = pth(:,:,:)
      q(:,:,:,:) = qh(:,:,:,:)
      u(:,:,:) = uh(:,:,:)
      ua(:,:,:) = uah(:,:,:)
      v(:,:,:) = vh(:,:,:)
      va(:,:,:) = vah(:,:,:)
      w(:,:,:) = wh(:,:,:)
      if (consv_te .gt. 0.) then
        call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
      endif
      if (tau .gt. 0.) then
        call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
      endif
      do ka1 = 1, npz
        do j = js, je
          do i = is, ie
            pt(i,j,ka1) = cp_air*pt(i,j,ka1)/pkz(i,j,ka1)*(1.+zvir*q(i,j,ka1,1))
          end do
        end do
      end do
      do ka1 = 1, npz
        do j = js, je
          do i = is, ie
            dp1(i,j,ka1) = delp(i,j,ka1)
          end do
        end do
      end do
      call dyn_core( npx,npy,npz,ng,bdt,n_split,cp_air,akap,grav,hydrostatic,u,v,w,delz,pt,delp,pe,pk,phis,omga,ptop,pfull,ua,va,&
&uc,vc,mfx,mfy,cx,cy,pem,pkz,uniform_ppm,time_total )
      do k1 = 1, k-1
        do iq = 1, nq
          do j = js, je
            do i = is, ie
              q2(i,j,iq) = q(i,j,k1,iq)
            end do
          end do
        end do
        call tracer_2d_1l( q2,dp1(is,js,k1),mfx(is,js,k1),mfy(is,js,k1),cx(is,jsd,k1),cy(isd,js,k1),npx,npy,npz,nq,hord_tr,q_split,&
&k1,q,bdt,uniform_ppm,id_divg )
      end do
      do iq = 1, nq
        do j = js, je
          do i = is, ie
            q2(i,j,iq) = q(i,j,k,iq)
          end do
        end do
      end do
      call adtracer_2d_1l( q2,adq2,dp1(is,js,k),addp1(is,js,k),mfx(is,js,k),admfx(is,js,k),mfy(is,js,k),admfy(is,js,k),cx(is,jsd,k)&
&,adcx(is,jsd,k),cy(isd,js,k),adcy(isd,js,k),npx,npy,npz,nq,hord_tr,q_split,k,adq,bdt,uniform_ppm,id_divg )
      do iq = 1, nq
        do j = js, je
          do i = is, ie
            adq(i,j,k,iq) = adq(i,j,k,iq)+adq2(i,j,iq)
            adq2(i,j,iq) = 0.
          end do
        end do
      end do
    end do
  else
    call adtracer_2d( addp1,mfx,admfx,mfy,admfy,npz,q_split )
  endif
endif
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pt(:,:,:) = pth(:,:,:)
q(:,:,:,:) = qh(:,:,:,:)
u(:,:,:) = uh(:,:,:)
ua(:,:,:) = uah(:,:,:)
v(:,:,:) = vh(:,:,:)
va(:,:,:) = vah(:,:,:)
w(:,:,:) = wh(:,:,:)
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
endif
if (tau .gt. 0.) then
  call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
endif
do k = 1, npz
  do j = js, je
    do i = is, ie
      pt(i,j,k) = cp_air*pt(i,j,k)/pkz(i,j,k)*(1.+zvir*q(i,j,k,1))
    end do
  end do
end do
allocate( advch(isd:ied,jsd:jed+1,1:npz) )
advch(:,:,:) = 0.
allocate( aduch(isd:ied+1,jsd:jed,1:npz) )
aduch(:,:,:) = 0.
call addyn_core( npx,npy,npz,ng,bdt,n_split,akap,hydrostatic,u,adu,v,adv,w,adw,pt,adpt,delp,addelp,pe,adpe,adpk,phis,omga,adomga,&
&ptop,pfull,ua,adua,va,adva,uc,aduch,vc,advch,mfx,admfx,mfy,admfy,cx,adcx,cy,adcy,pem,adpem,uniform_ppm )
deallocate( aduch )
deallocate( advch )
do k = 1, npz
  do j = js, je
    do i = is, ie
      addelp(i,j,k) = addelp(i,j,k)+addp1(i,j,k)
      addp1(i,j,k) = 0.
    end do
  end do
end do
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pt(:,:,:) = pth(:,:,:)
q(:,:,:,:) = qh(:,:,:,:)
u(:,:,:) = uh(:,:,:)
ua(:,:,:) = uah(:,:,:)
v(:,:,:) = vh(:,:,:)
va(:,:,:) = vah(:,:,:)
w(:,:,:) = wh(:,:,:)
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
endif
if (tau .gt. 0.) then
  call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
endif
do k = 1, npz
  do j = js, je
    do i = is, ie
      adpkz(i,j,k) = adpkz(i,j,k)-adpt(i,j,k)*cp_air*pt(i,j,k)/(pkz(i,j,k)*pkz(i,j,k))*(1.+zvir*q(i,j,k,1))
      adq(i,j,k,1) = adq(i,j,k,1)+adpt(i,j,k)*cp_air*pt(i,j,k)/pkz(i,j,k)*zvir
      adpt(i,j,k) = adpt(i,j,k)*cp_air/pkz(i,j,k)*(1.+zvir*q(i,j,k,1))
    end do
  end do
end do
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pt(:,:,:) = pth(:,:,:)
q(:,:,:,:) = qh(:,:,:,:)
u(:,:,:) = uh(:,:,:)
ua(:,:,:) = uah(:,:,:)
v(:,:,:) = vh(:,:,:)
va(:,:,:) = vah(:,:,:)
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
endif
if (tau .gt. 0.) then
  call adrayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,adu,v,adv,adpt,ua,adua,va,adva,cp_air,rg, .true.  )
endif
if (consv_te .gt. 0.) then
  call adcompute_total_energy( isd,ied,jsd,jed,npz,adu,adv,adua,adva )
endif

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine adfv_dynamics


subroutine adrayleigh_friction( dt, npz, ks, pm, tau, p_c, u, adu, v, adv, adpt, ua, adua, va, adva, cp, rg, conserve )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use grid_utils, only : adcubed_to_latlon

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: sday = 86400.

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: adpt(isd:ied,jsd:jed,npz)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adua(isd:ied,jsd:jed,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adva(isd:ied,jsd:jed,npz)
logical, intent(in) :: conserve
real, intent(in) :: cp
real, intent(in) :: dt
integer, intent(in) :: ks
real, intent(in) :: p_c
real, intent(in) :: pm(npz)
real, intent(in) :: rg
real, intent(in) :: tau
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: c1
real :: fac
integer :: i
integer :: j
integer :: k
integer :: kmax
real :: pc
real :: rf(npz)
logical :: rf_initialized =  .false. 

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
kmax = max(npz/3+1,ks)
if ( .not. rf_initialized) then
  if (p_c .le. 0.) then
    pc = pm(1)
  else
    pc = p_c
  endif
  c1 = 1./(tau*sday)
  do k = 1, kmax
    if (pm(k) .lt. 3000.) then
      rf(k) = c1*(1.+tanh(log10(pc/pm(k))))
      rf(k) = 1./(1.+dt*rf(k))
    endif
  end do
endif
if (conserve) then
  call cubed_to_latlon( u,v,ua,va,dx,dy,dxa,dya,npz )
endif
do k = 1, kmax
  if (pm(k) .lt. 3000.) then
    do j = js, je
      do i = is, ie+1
        adv(i,j,k) = adv(i,j,k)*rf(k)
      end do
    end do
    do j = js, je+1
      do i = is, ie
        adu(i,j,k) = adu(i,j,k)*rf(k)
      end do
    end do
    if (conserve) then
      fac = 0.5*(1.-rf(k)**2)/(cp-rg*ptop/pm(k))
      do j = js, je
        do i = is, ie
          adua(i,j,k) = adua(i,j,k)+2*adpt(i,j,k)*fac*ua(i,j,k)
          adva(i,j,k) = adva(i,j,k)+2*adpt(i,j,k)*fac*va(i,j,k)
        end do
      end do
    endif
  endif
end do
if (conserve) then
  call adcubed_to_latlon( adu,adv,adua,adva,dx,dy,dxa,dya,npz )
endif

end subroutine adrayleigh_friction


subroutine mdfv_dynamics( npx, npy, npz, nq, ng, bdt, consv_te, fill, reproduce_sum, kappa, cp_air, zvir, ks, ncnst, n_split, &
&q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln, pkz, phis, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&u_srf, v_srf, srf_init, ze0, hybrid_z, time_total )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use admapz_module, only : mdlagrangian_to_eulerian

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(in) :: ak(npz+1)
real, intent(in) :: bdt
real, intent(in) :: bk(npz+1)
real, intent(in) :: consv_te
real, intent(in) :: cp_air
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
logical, intent(in) :: fill
logical, intent(in) :: hybrid_z
logical, intent(in) :: hydrostatic
real, intent(in) :: kappa
integer, intent(in) :: ks
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: n_split
integer, intent(in) :: ncnst
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: nq
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pkz(is:ie,js:je,npz)
real, intent(inout) :: ps(isd:ied,jsd:jed)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: q(isd:ied,jsd:jed,npz,ncnst)
integer, intent(in) :: q_split
logical, intent(in) :: reproduce_sum
logical, intent(inout) :: srf_init
real,optional, intent(in) :: time_total
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(out) :: u_srf(is:ie,js:je)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(out) :: v_srf(is:ie,js:je)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)
real, intent(inout) :: ze0(is:ie,js:je,npz+1)
real, intent(in) :: zvir

!==============================================
! declare local variables
!==============================================
real :: akap
real :: dp1(is:ie,js:je,1:npz)
integer :: i
integer :: iq
integer :: j
integer :: k
real :: pem(is-1:ie+1,1:npz+1,js-1:je+1)
real :: pfull(npz)
real :: ph1
real :: ph2
real :: q2(isd:ied,jsd:jed,nq)
real :: rg
real :: te_2d(is:ie,js:je)
real :: teq(is:ie,js:je)
logical :: used

!**********************************************
! executable statements of routine
!**********************************************
akap = kappa
rg = kappa*cp_air
do k = 1, npz
  ph1 = ak(k)+bk(k)*p_ref
  ph2 = ak(k+1)+bk(k+1)*p_ref
  pfull(k) = (ph2-ph1)/log(ph2/ph1)
end do
if (consv_te .gt. 0.) then
  call compute_total_energy( is,ie,js,je,isd,ied,jsd,jed,npz,u,v,pt,delp,q,pe,peln,phis,zvir,cp_air,rg,hlv,te_2d,ua,va,teq,&
&full_phys,id_te )
  if (id_te .gt. 0) then
    used = send_data(id_te,teq,fv_time)
  endif
endif
if (tau .gt. 0.) then
  call rayleigh_friction( bdt,npz,ks,pfull,tau,rf_center,u,v,w,pt,ua,va,cp_air,rg,hydrostatic, .true.  )
endif
do k = 1, npz
  do j = js, je
    do i = is, ie
      pt(i,j,k) = cp_air*pt(i,j,k)/pkz(i,j,k)*(1.+zvir*q(i,j,k,1))
    end do
  end do
end do
do k = 1, npz
  do j = js, je
    do i = is, ie
      dp1(i,j,k) = delp(i,j,k)
    end do
  end do
end do
call dyn_core( npx,npy,npz,ng,bdt,n_split,cp_air,akap,grav,hydrostatic,u,v,w,delz,pt,delp,pe,pk,phis,omga,ptop,pfull,ua,va,uc,vc,&
&mfx,mfy,cx,cy,pem,pkz,uniform_ppm,time_total )
if (nq .ne. 0) then
  if (z_tracer) then
    do k = 1, npz
      do iq = 1, nq
        do j = js, je
          do i = is, ie
            q2(i,j,iq) = q(i,j,k,iq)
          end do
        end do
      end do
      call tracer_2d_1l( q2,dp1(is,js,k),mfx(is,js,k),mfy(is,js,k),cx(is,jsd,k),cy(isd,js,k),npx,npy,npz,nq,hord_tr,q_split,k,q,&
&bdt,uniform_ppm,id_divg )
    end do
  else
    call tracer_2d( q,dp1,mfx,mfy,cx,cy,npx,npy,npz,nq,hord_tr,q_split,bdt,uniform_ppm,id_divg )
  endif
  if (id_divg .gt. 0) then
    used = send_data(id_divg,dp1,fv_time)
  endif
endif
if (npz .gt. 4) then
  call mdlagrangian_to_eulerian( consv_te,ps,pe,delp,pkz,pk,bdt,npz,is,ie,js,je,isd,ied,jsd,jed,nq,u,v,w,delz,pt,q,phis,grav,zvir,&
&cp_air,akap,kord_mt,kord_tr,kord_tm,peln,te_2d,ng,ua,va,omga,dp1,pem,fill,reproduce_sum,ak,bk,ks,ze0,remap_t,hydrostatic,&
&hybrid_z,k_top,ncnst )
  if ( .not. srf_init) then
    do j = js, je
      i = ie
    end do
  endif
endif
end subroutine mdfv_dynamics


end module     adfv_dynamics_mod


