module     adfv_tracer2d_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use tp_core_mod, only : fv_tp_2d
use fv_grid_tools_mod, only : area,dx,dxa,dy,dya,rarea
use fv_grid_utils_mod, only : sina_u,sina_v
use fv_mp_mod, only : domain,gid,ie,ied,is,isd,je,jed,js,jsd,ng
use mpp_domains_mod, only : mpp_update_domains,mpp_update_domains_ad
use fv_timing_mod, only : timing_off, timing_on
use fv_tracer2d_mod
      use fv_my_mpp,  only: mpp_update_domains_dummy4,mp_reduce_max_dummy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine adtracer_2d( q, adq, dp1, addp1, mfx, admfx, mfy, admfy, cx, adcx, cy, adcy, npx, npy, npz, nq, hord, q_split, dt, &
&uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use adtp_core_mod, only : adfv_tp_2d
use adfv_my_mpp, only : admp_reduce_max_dummy, admpp_update_domains_dummy4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: adcx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: adcy(isd:ied,js:je+1,npz)
real, intent(inout) :: addp1(is:ie,js:je,npz)
real, intent(inout) :: admfx(is:ie+1,js:je,npz)
real, intent(inout) :: admfy(is:ie,js:je+1,npz)
integer, intent(in) :: nq
real, intent(inout) :: adq(isd:ied,jsd:jed,npz,nq)
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: dp1(is:ie,js:je,npz)
real, intent(in) :: dt
integer, intent(in) :: hord
integer, intent(in) :: id_divg
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: adc_global
real :: adcmax(npz)
real :: adcmaxh
real :: addp2(isd:ied,jsd:jed)
real :: adfrac
real :: adfx(is:ie+1,js:je)
real :: adfy(is:ie,js:je+1)
real :: adra_x(is:ie,jsd:jed)
real :: adra_y(isd:ied,js:je)
real :: adrdt
real :: adxfx(is:ie+1,jsd:jed,npz)
real :: adyfx(isd:ied,js:je+1,npz)
real :: c_global
real :: cmax(npz)
real :: cmaxh
real :: cxh(lbound(cx,1):ubound(cx,1),lbound(cx,2):ubound(cx,2),lbound(cx,3):ubound(cx,3))
real :: cyh(lbound(cy,1):ubound(cy,1),lbound(cy,2):ubound(cy,2),lbound(cy,3):ubound(cy,3))
real :: dp1h(lbound(dp1,1):ubound(dp1,1),lbound(dp1,2):ubound(dp1,2),lbound(dp1,3):ubound(dp1,3))
real :: dp1i(lbound(dp1,1):ubound(dp1,1),lbound(dp1,2):ubound(dp1,2),lbound(dp1,3):ubound(dp1,3))
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fxh(lbound(fx,1):ubound(fx,1),lbound(fx,2):ubound(fx,2))
real :: fy(is:ie,js:je+1)
real :: fyh(lbound(fy,1):ubound(fy,1),lbound(fy,2):ubound(fy,2))
integer :: i
integer :: iq
integer :: iq1
integer :: it
integer :: it1
integer :: j
integer :: k
integer :: k1
real :: mfxh(lbound(mfx,1):ubound(mfx,1),lbound(mfx,2):ubound(mfx,2),lbound(mfx,3):ubound(mfx,3))
real :: mfyh(lbound(mfy,1):ubound(mfy,1),lbound(mfy,2):ubound(mfy,2),lbound(mfy,3):ubound(mfy,3))
integer :: nsplt
real :: qh(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
real :: qi(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
real :: qj(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
real :: qk(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
qk(:,:,:,:) = q(:,:,:,:)
mfyh(:,:,:) = mfy(:,:,:)
mfxh(:,:,:) = mfx(:,:,:)
dp1i(:,:,:) = dp1(:,:,:)
cyh(:,:,:) = cy(:,:,:)
cxh(:,:,:) = cx(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adc_global = 0.
adcmax(:) = 0.
addp2(:,:) = 0.
adfrac = 0.
adfx(:,:) = 0.
adfy(:,:) = 0.
adra_x(:,:) = 0.
adra_y(:,:) = 0.
adrdt = 0.
adxfx(:,:,:) = 0.
adyfx(:,:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do k = 1, npz
  do j = jsd, jed
    do i = is, ie+1
      if (cx(i,j,k) .gt. 0.) then
        xfx(i,j,k) = cx(i,j,k)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      else
        xfx(i,j,k) = cx(i,j,k)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      endif
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      if (cy(i,j,k) .gt. 0.) then
        yfx(i,j,k) = cy(i,j,k)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      else
        yfx(i,j,k) = cy(i,j,k)*dya(i,j)*dx(i,j)*sina_v(i,j)
      endif
    end do
  end do
end do
if (q_split .eq. 0) then
  do k = 1, npz
    cmax(k) = 0.
    do j = js, je
      do i = is, ie
        cmax(k) = max(max(abs(cx(i,j,k))+1.-sina_u(i,j),abs(cy(i,j,k))+1.-sina_v(i,j)),cmax(k))
      end do
    end do
  end do
  call mp_reduce_max_dummy( cmax,npz )
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      c_global = max(cmax(k),c_global)
    end do
  endif
  nsplt = int(1.+c_global)
else
  nsplt = q_split
endif
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do k = 1, npz
    do j = jsd, jed
      do i = is, ie+1
        cx(i,j,k) = cx(i,j,k)*frac
        xfx(i,j,k) = xfx(i,j,k)*frac
      end do
    end do
    do j = js, je
      do i = is, ie+1
        mfx(i,j,k) = mfx(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = isd, ied
        cy(i,j,k) = cy(i,j,k)*frac
        yfx(i,j,k) = yfx(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = is, ie
        mfy(i,j,k) = mfy(i,j,k)*frac
      end do
    end do
  end do
endif
if (id_divg .gt. 0) then
  rdt = 1./(frac*dt)
  do k = 1, npz
    do j = js, je
      do i = is, ie
        adrdt = adrdt+addp1(i,j,k)*(xfx(i+1,j,k)-xfx(i,j,k)+yfx(i,j+1,k)-yfx(i,j,k))*rarea(i,j)
        adxfx(i+1,j,k) = adxfx(i+1,j,k)+addp1(i,j,k)*rarea(i,j)*rdt
        adxfx(i,j,k) = adxfx(i,j,k)-addp1(i,j,k)*rarea(i,j)*rdt
        adyfx(i,j+1,k) = adyfx(i,j+1,k)+addp1(i,j,k)*rarea(i,j)*rdt
        adyfx(i,j,k) = adyfx(i,j,k)-addp1(i,j,k)*rarea(i,j)*rdt
        addp1(i,j,k) = 0.
      end do
    end do
  end do
  adfrac = adfrac-adrdt*(1.*dt/(frac*dt*frac*dt))
  adrdt = 0.
endif
do it = nsplt, 1, -1
  dp1(:,:,:) = dp1i(:,:,:)
  q(:,:,:,:) = qk(:,:,:,:)
  do it1 = 1, it-1
    call mpp_update_domains_dummy4( q,is,ie,js,je,isd,ied,jsd,jed,npz,nq )
    do k = 1, npz
      do j = jsd, jed
        do i = is, ie
          ra_x(i,j) = area(i,j)+xfx(i,j,k)-xfx(i+1,j,k)
        end do
      end do
      do j = js, je
        do i = isd, ied
          ra_y(i,j) = area(i,j)+yfx(i,j,k)-yfx(i,j+1,k)
        end do
      end do
      do j = js, je
        do i = is, ie
          dp2(i,j) = dp1(i,j,k)+(mfx(i,j,k)-mfx(i+1,j,k)+mfy(i,j,k)-mfy(i,j+1,k))*rarea(i,j)
        end do
      end do
      do iq = 1, nq
        call fv_tp_2d( q(isd,jsd,k,iq),cx(is,jsd,k),cy(isd,js,k),npx,npy,hord,fx,fy,xfx(is,jsd,k),yfx(isd,js,k),area,ra_x,ra_y,&
&uniform_ppm,mfx(is,js,k),mfy(is,js,k), .true. ,k )
        do j = js, je
          do i = is, ie
            q(i,j,k,iq) = (q(i,j,k,iq)*dp1(i,j,k)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      end do
      do j = js, je
        do i = is, ie
          dp1(i,j,k) = dp2(i,j)
        end do
      end do
    end do
  end do
  qj(:,:,:,:) = q(:,:,:,:)
  dp1h(:,:,:) = dp1(:,:,:)
  call mpp_update_domains_dummy4( q,is,ie,js,je,isd,ied,jsd,jed,npz,nq )
  do k = npz, 1, -1
    dp1(:,:,:) = dp1h(:,:,:)
    q(:,:,:,:) = qj(:,:,:,:)
    call mpp_update_domains_dummy4( q,is,ie,js,je,isd,ied,jsd,jed,npz,nq )
    do k1 = 1, k-1
      do j = jsd, jed
        do i = is, ie
          ra_x(i,j) = area(i,j)+xfx(i,j,k1)-xfx(i+1,j,k1)
        end do
      end do
      do j = js, je
        do i = isd, ied
          ra_y(i,j) = area(i,j)+yfx(i,j,k1)-yfx(i,j+1,k1)
        end do
      end do
      do j = js, je
        do i = is, ie
          dp2(i,j) = dp1(i,j,k1)+(mfx(i,j,k1)-mfx(i+1,j,k1)+mfy(i,j,k1)-mfy(i,j+1,k1))*rarea(i,j)
        end do
      end do
      do iq = 1, nq
        call fv_tp_2d( q(isd,jsd,k1,iq),cx(is,jsd,k1),cy(isd,js,k1),npx,npy,hord,fx,fy,xfx(is,jsd,k1),yfx(isd,js,k1),area,ra_x,&
&ra_y,uniform_ppm,mfx(is,js,k1),mfy(is,js,k1), .true. ,k1 )
        do j = js, je
          do i = is, ie
            q(i,j,k1,iq) = (q(i,j,k1,iq)*dp1(i,j,k1)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      end do
      do j = js, je
        do i = is, ie
          dp1(i,j,k1) = dp2(i,j)
        end do
      end do
    end do
    qi(:,:,:,:) = q(:,:,:,:)
    do j = jsd, jed
      do i = is, ie
        ra_x(i,j) = area(i,j)+xfx(i,j,k)-xfx(i+1,j,k)
      end do
    end do
    do j = js, je
      do i = isd, ied
        ra_y(i,j) = area(i,j)+yfx(i,j,k)-yfx(i,j+1,k)
      end do
    end do
    do j = js, je
      do i = is, ie
        dp2(i,j) = dp1(i,j,k)+(mfx(i,j,k)-mfx(i+1,j,k)+mfy(i,j,k)-mfy(i,j+1,k))*rarea(i,j)
      end do
    end do
    do j = js, je
      do i = is, ie
        addp2(i,j) = addp2(i,j)+addp1(i,j,k)
        addp1(i,j,k) = 0.
      end do
    end do
    do iq = nq, 1, -1
      q(:,:,:,:) = qi(:,:,:,:)
      do iq1 = 1, iq-1
        call fv_tp_2d( q(isd,jsd,k,iq1),cx(is,jsd,k),cy(isd,js,k),npx,npy,hord,fx,fy,xfx(is,jsd,k),yfx(isd,js,k),area,ra_x,ra_y,&
&uniform_ppm,mfx(is,js,k),mfy(is,js,k), .true. ,k )
        do j = js, je
          do i = is, ie
            q(i,j,k,iq1) = (q(i,j,k,iq1)*dp1(i,j,k)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      end do
      qh(:,:,:,:) = q(:,:,:,:)
      fyh(:,:) = fy(:,:)
      fxh(:,:) = fx(:,:)
      call fv_tp_2d( q(isd,jsd,k,iq),cx(is,jsd,k),cy(isd,js,k),npx,npy,hord,fx,fy,xfx(is,jsd,k),yfx(isd,js,k),area,ra_x,ra_y,&
&uniform_ppm,mfx(is,js,k),mfy(is,js,k), .true. ,k )
      do j = js, je
        do i = is, ie
          addp1(i,j,k) = addp1(i,j,k)+adq(i,j,k,iq)*(q(i,j,k,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq(i,j,k,iq)*((q(i,j,k,iq)*dp1(i,j,k)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,&
&j)*dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,k,iq) = adq(i,j,k,iq)*(dp1(i,j,k)/dp2(i,j))
        end do
      end do
      fx(:,:) = fxh(:,:)
      fy(:,:) = fyh(:,:)
      q(:,:,:,:) = qh(:,:,:,:)
      call adfv_tp_2d( q(isd,jsd,k,iq),adq(isd,jsd,k,iq),cx(is,jsd,k),adcx(is,jsd,k),cy(isd,js,k),adcy(isd,js,k),npx,npy,hord,fx,&
&adfx,fy,adfy,xfx(is,jsd,k),adxfx(is,jsd,k),yfx(isd,js,k),adyfx(isd,js,k),area,ra_x,adra_x,ra_y,adra_y,uniform_ppm,mfx(is,js,&
&k),admfx(is,js,k),mfy(is,js,k),admfy(is,js,k), .true.  )
    end do
    do j = js, je
      do i = is, ie
        addp1(i,j,k) = addp1(i,j,k)+addp2(i,j)
        admfx(i+1,j,k) = admfx(i+1,j,k)-addp2(i,j)*rarea(i,j)
        admfx(i,j,k) = admfx(i,j,k)+addp2(i,j)*rarea(i,j)
        admfy(i,j+1,k) = admfy(i,j+1,k)-addp2(i,j)*rarea(i,j)
        admfy(i,j,k) = admfy(i,j,k)+addp2(i,j)*rarea(i,j)
        addp2(i,j) = 0.
      end do
    end do
    do j = js, je
      do i = isd, ied
        adyfx(i,j+1,k) = adyfx(i,j+1,k)-adra_y(i,j)
        adyfx(i,j,k) = adyfx(i,j,k)+adra_y(i,j)
        adra_y(i,j) = 0.
      end do
    end do
    do j = jsd, jed
      do i = is, ie
        adxfx(i+1,j,k) = adxfx(i+1,j,k)-adra_x(i,j)
        adxfx(i,j,k) = adxfx(i,j,k)+adra_x(i,j)
        adra_x(i,j) = 0.
      end do
    end do
  end do
  call admpp_update_domains_dummy4( adq,is,ie,js,je,isd,ied,jsd,jed,npz,nq )
end do
cx(:,:,:) = cxh(:,:,:)
cy(:,:,:) = cyh(:,:,:)
mfx(:,:,:) = mfxh(:,:,:)
mfy(:,:,:) = mfyh(:,:,:)
do k = 1, npz
  do j = jsd, jed
    do i = is, ie+1
      if (cx(i,j,k) .gt. 0.) then
        xfx(i,j,k) = cx(i,j,k)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      else
        xfx(i,j,k) = cx(i,j,k)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      endif
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      if (cy(i,j,k) .gt. 0.) then
        yfx(i,j,k) = cy(i,j,k)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      else
        yfx(i,j,k) = cy(i,j,k)*dya(i,j)*dx(i,j)*sina_v(i,j)
      endif
    end do
  end do
end do
if (nsplt .ne. 1) then
  do k = 1, npz
    do j = js, je+1
      do i = is, ie
        adfrac = adfrac+admfy(i,j,k)*mfy(i,j,k)
        admfy(i,j,k) = admfy(i,j,k)*frac
      end do
    end do
    do j = js, je+1
      do i = isd, ied
        adfrac = adfrac+adyfx(i,j,k)*yfx(i,j,k)
        adyfx(i,j,k) = adyfx(i,j,k)*frac
        adfrac = adfrac+adcy(i,j,k)*cy(i,j,k)
        adcy(i,j,k) = adcy(i,j,k)*frac
      end do
    end do
    do j = js, je
      do i = is, ie+1
        adfrac = adfrac+admfx(i,j,k)*mfx(i,j,k)
        admfx(i,j,k) = admfx(i,j,k)*frac
      end do
    end do
    do j = jsd, jed
      do i = is, ie+1
        adfrac = adfrac+adxfx(i,j,k)*xfx(i,j,k)
        adxfx(i,j,k) = adxfx(i,j,k)*frac
        adfrac = adfrac+adcx(i,j,k)*cx(i,j,k)
        adcx(i,j,k) = adcx(i,j,k)*frac
      end do
    end do
  end do
endif
adfrac = 0.
cx(:,:,:) = cxh(:,:,:)
cy(:,:,:) = cyh(:,:,:)
if (q_split .eq. 0) then
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      adcmax(k) = adcmax(k)+adc_global*(0.5+sign(0.5,cmax(k)-c_global))
      adc_global = adc_global*(0.5-sign(0.5,cmax(k)-c_global))
    end do
  endif
  adcmax(1) = adcmax(1)+adc_global
  adc_global = 0.
  call admp_reduce_max_dummy( adcmax,npz )
  do k = npz, 1, -1
    cmax(k) = 0.
    do j = js, je
      do i = is, ie
        cmaxh = max(abs(cx(i,j,k))+1.-sina_u(i,j),abs(cy(i,j,k))+1.-sina_v(i,j))
        adcmaxh = adcmax(k)*(0.5+sign(0.5,cmaxh-cmax(k)))
        adcmax(k) = adcmax(k)*(0.5-sign(0.5,cmaxh-cmax(k)))
        adcx(i,j,k) = adcx(i,j,k)+adcmaxh*(0.5+sign(0.5,abs(cx(i,j,k))+1.-sina_u(i,j)-(abs(cy(i,j,k))+1.-sina_v(i,j))))*sign(1.,&
&cx(i,j,k))
        adcy(i,j,k) = adcy(i,j,k)+adcmaxh*(0.5-sign(0.5,abs(cx(i,j,k))+1.-sina_u(i,j)-(abs(cy(i,j,k))+1.-sina_v(i,j))))*sign(1.,&
&cy(i,j,k))
      end do
    end do
    adcmax(k) = 0.
  end do
endif
cx(:,:,:) = cxh(:,:,:)
cy(:,:,:) = cyh(:,:,:)
do k = 1, npz
  do j = js, je+1
    do i = isd, ied
      if (cy(i,j,k) .gt. 0.) then
        adcy(i,j,k) = adcy(i,j,k)+adyfx(i,j,k)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
        adyfx(i,j,k) = 0.
      else
        adcy(i,j,k) = adcy(i,j,k)+adyfx(i,j,k)*dya(i,j)*dx(i,j)*sina_v(i,j)
        adyfx(i,j,k) = 0.
      endif
    end do
  end do
  do j = jsd, jed
    do i = is, ie+1
      if (cx(i,j,k) .gt. 0.) then
        adcx(i,j,k) = adcx(i,j,k)+adxfx(i,j,k)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
        adxfx(i,j,k) = 0.
      else
        adcx(i,j,k) = adcx(i,j,k)+adxfx(i,j,k)*dxa(i,j)*dy(i,j)*sina_u(i,j)
        adxfx(i,j,k) = 0.
      endif
    end do
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine adtracer_2d


subroutine adtracer_2d_1l( q, adq, dp1, addp1, mfx, admfx, mfy, admfy, cx, adcx, cy, adcy, npx, npy, npz, nq, hord, q_split, k, &
&adq3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use adtp_core_mod, only : adfv_tp_2d
use adfv_my_mpp, only : admp_reduce_max_dummy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: adcx(is:ie+1,jsd:jed)
real, intent(inout) :: adcy(isd:ied,js:je+1)
real, intent(inout) :: addp1(is:ie,js:je)
real, intent(inout) :: admfx(is:ie+1,js:je)
real, intent(inout) :: admfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: adq(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: adq3(isd:ied,jsd:jed,npz,nq)
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: adcmax
real :: adcmaxh
real :: addp2(isd:ied,jsd:jed)
real :: adfrac
real :: adfx(is:ie+1,js:je)
real :: adfy(is:ie,js:je+1)
real :: adra_x(is:ie,jsd:jed)
real :: adra_y(isd:ied,js:je)
real :: adrdt
real :: adxfx(is:ie+1,jsd:jed)
real :: adyfx(isd:ied,js:je+1)
real :: cmax
real :: cmaxh
real :: cxh(lbound(cx,1):ubound(cx,1),lbound(cx,2):ubound(cx,2))
real :: cyh(lbound(cy,1):ubound(cy,1),lbound(cy,2):ubound(cy,2))
real :: dp1h(lbound(dp1,1):ubound(dp1,1),lbound(dp1,2):ubound(dp1,2))
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fxh(lbound(fx,1):ubound(fx,1),lbound(fx,2):ubound(fx,2))
real :: fy(is:ie,js:je+1)
real :: fyh(lbound(fy,1):ubound(fy,1),lbound(fy,2):ubound(fy,2))
integer :: i
integer :: iq
integer :: iq1
integer :: it
integer :: it1
integer :: j
real :: mfxh(lbound(mfx,1):ubound(mfx,1),lbound(mfx,2):ubound(mfx,2))
real :: mfyh(lbound(mfy,1):ubound(mfy,1),lbound(mfy,2):ubound(mfy,2))
integer :: nsplt
real :: qh(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: qi(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: qj(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
qj(:,:,:) = q(:,:,:)
mfyh(:,:) = mfy(:,:)
mfxh(:,:) = mfx(:,:)
dp1h(:,:) = dp1(:,:)
cyh(:,:) = cy(:,:)
cxh(:,:) = cx(:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adcmax = 0.
addp2(:,:) = 0.
adfrac = 0.
adfx(:,:) = 0.
adfy(:,:) = 0.
adra_x(:,:) = 0.
adra_y(:,:) = 0.
adrdt = 0.
adxfx(:,:) = 0.
adyfx(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (q_split .eq. 0) then
  cmax = 0.
  do j = js, je
    do i = is, ie
      cmax = max(max(abs(cx(i,j))+1.-sina_u(i,j),abs(cy(i,j))+1.-sina_v(i,j)),cmax)
    end do
  end do
  call mp_reduce_max_dummy( cmax )
  nsplt = int(1.0001+cmax)
else
  nsplt = q_split
endif
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      cx(i,j) = cx(i,j)*frac
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      cy(i,j) = cy(i,j)*frac
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie
    ra_x(i,j) = area(i,j)+xfx(i,j)-xfx(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    ra_y(i,j) = area(i,j)+yfx(i,j)-yfx(i,j+1)
  end do
end do
if (id_divg .gt. 0) then
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      adrdt = adrdt+addp1(i,j)*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)
      adxfx(i+1,j) = adxfx(i+1,j)+addp1(i,j)*rarea(i,j)*rdt
      adxfx(i,j) = adxfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j+1) = adyfx(i,j+1)+addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j) = adyfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      addp1(i,j) = 0.
    end do
  end do
  adfrac = adfrac-adrdt*(1.*dt/(frac*dt*frac*dt))
  adrdt = 0.
endif
do it = nsplt, 1, -1
  dp1(:,:) = dp1h(:,:)
  q(:,:,:) = qj(:,:,:)
  do it1 = 1, it-1
    do j = js, je
      do i = is, ie
        dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
      end do
    end do
    do iq = 1, nq
      call fv_tp_2d( q(isd,jsd,iq),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx,mfy, .true. ,k )
      if (it1 .eq. nsplt) then
      else
        do j = js, je
          do i = is, ie
            q(i,j,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      endif
    end do
    if (it1 .ne. nsplt) then
      do j = js, je
        do i = is, ie
          dp1(i,j) = dp2(i,j)
        end do
      end do
    endif
  end do
  qi(:,:,:) = q(:,:,:)
  do j = js, je
    do i = is, ie
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        addp2(i,j) = addp2(i,j)+addp1(i,j)
        addp1(i,j) = 0.
      end do
    end do
  endif
  do iq = nq, 1, -1
    q(:,:,:) = qi(:,:,:)
    do iq1 = 1, iq-1
      call fv_tp_2d( q(isd,jsd,iq1),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx,mfy, .true. ,k )
      if (it .eq. nsplt) then
      else
        do j = js, je
          do i = is, ie
            q(i,j,iq1) = (q(i,j,iq1)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      endif
    end do
    qh(:,:,:) = q(:,:,:)
    fyh(:,:) = fy(:,:)
    fxh(:,:) = fx(:,:)
    call fv_tp_2d( q(isd,jsd,iq),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx,mfy, .true. ,k )
    if (it .eq. nsplt) then
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq3(i,j,k,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq3(i,j,k,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)+adq3(i,j,k,iq)*(dp1(i,j)/dp2(i,j))
          adq3(i,j,k,iq) = 0.
        end do
      end do
    else
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq(i,j,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq(i,j,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)*(dp1(i,j)/dp2(i,j))
        end do
      end do
    endif
    fx(:,:) = fxh(:,:)
    fy(:,:) = fyh(:,:)
    q(:,:,:) = qh(:,:,:)
    call adfv_tp_2d( q(isd,jsd,iq),adq(isd,jsd,iq),cx,adcx,cy,adcy,npx,npy,hord,fx,adfx,fy,adfy,xfx,adxfx,yfx,adyfx,area,ra_x,&
&adra_x,ra_y,adra_y,uniform_ppm,mfx,admfx,mfy,admfy, .true.  )
  end do
  do j = js, je
    do i = is, ie
      addp1(i,j) = addp1(i,j)+addp2(i,j)
      admfx(i+1,j) = admfx(i+1,j)-addp2(i,j)*rarea(i,j)
      admfx(i,j) = admfx(i,j)+addp2(i,j)*rarea(i,j)
      admfy(i,j+1) = admfy(i,j+1)-addp2(i,j)*rarea(i,j)
      admfy(i,j) = admfy(i,j)+addp2(i,j)*rarea(i,j)
      addp2(i,j) = 0.
    end do
  end do
end do
do j = js, je
  do i = isd, ied
    adyfx(i,j+1) = adyfx(i,j+1)-adra_y(i,j)
    adyfx(i,j) = adyfx(i,j)+adra_y(i,j)
    adra_y(i,j) = 0.
  end do
end do
do j = jsd, jed
  do i = is, ie
    adxfx(i+1,j) = adxfx(i+1,j)-adra_x(i,j)
    adxfx(i,j) = adxfx(i,j)+adra_x(i,j)
    adra_x(i,j) = 0.
  end do
end do
cx(:,:) = cxh(:,:)
cy(:,:) = cyh(:,:)
mfx(:,:) = mfxh(:,:)
mfy(:,:) = mfyh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (nsplt .ne. 1) then
  do j = js, je+1
    do i = is, ie
      adfrac = adfrac+admfy(i,j)*mfy(i,j)
      admfy(i,j) = admfy(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      adfrac = adfrac+adyfx(i,j)*yfx(i,j)
      adyfx(i,j) = adyfx(i,j)*frac
      adfrac = adfrac+adcy(i,j)*cy(i,j)
      adcy(i,j) = adcy(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      adfrac = adfrac+admfx(i,j)*mfx(i,j)
      admfx(i,j) = admfx(i,j)*frac
    end do
  end do
  do j = jsd, jed
    do i = is, ie+1
      adfrac = adfrac+adxfx(i,j)*xfx(i,j)
      adxfx(i,j) = adxfx(i,j)*frac
      adfrac = adfrac+adcx(i,j)*cx(i,j)
      adcx(i,j) = adcx(i,j)*frac
    end do
  end do
endif
adfrac = 0.
cx(:,:) = cxh(:,:)
cy(:,:) = cyh(:,:)
if (q_split .eq. 0) then
  cmax = 0.
  call admp_reduce_max_dummy( adcmax )
  do j = js, je
    do i = is, ie
      cmaxh = max(abs(cx(i,j))+1.-sina_u(i,j),abs(cy(i,j))+1.-sina_v(i,j))
      adcmaxh = adcmax*(0.5+sign(0.5,cmaxh-cmax))
      adcmax = adcmax*(0.5-sign(0.5,cmaxh-cmax))
      adcx(i,j) = adcx(i,j)+adcmaxh*(0.5+sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cx(i,j))
      adcy(i,j) = adcy(i,j)+adcmaxh*(0.5-sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cy(i,j))
    end do
  end do
endif
cy(:,:) = cyh(:,:)
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    else
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    endif
  end do
end do
cx(:,:) = cxh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    else
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    endif
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine adtracer_2d_1l


end module     adfv_tracer2d_mod


