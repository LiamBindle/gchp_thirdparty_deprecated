!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.28
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     adadv_pe_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: tp_advpe_adv_pe
real, allocatable :: tp_advpe_grad_25h(:,:,:,:)
real, allocatable :: tp_advpe_v3_24h(:,:,:,:)

end module     adadv_pe_store


module     addyn_core_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real, allocatable :: tp2d_dyn_core_delpc_6h(:,:,:)
integer :: tp2d_dyn_core_dyn_core
real, allocatable :: tp_dyn_core_crx_33h(:,:,:,:)
real, allocatable :: tp_dyn_core_cry_34h(:,:,:,:)
real, allocatable :: tp_dyn_core_delp_31h(:,:,:,:)
real, allocatable :: tp_dyn_core_delp_41h(:,:,:,:)
real, allocatable :: tp_dyn_core_delpc_15h(:,:,:,:)
real, allocatable :: tp_dyn_core_delpc_18h(:,:,:,:)
real, allocatable :: tp_dyn_core_delpc_37h(:,:,:,:)
integer :: tp_dyn_core_dyn_core
real, allocatable :: tp_dyn_core_gz_25h(:,:,:,:)
real, allocatable :: tp_dyn_core_gz_42h(:,:,:,:)
logical :: tp_dyn_core_last_step_11h(4)
real, allocatable :: tp_dyn_core_omga_17h(:,:,:,:)
real, allocatable :: tp_dyn_core_pe_45h(:,:,:,:)
real, allocatable :: tp_dyn_core_peln_38h(:,:,:,:)
real, allocatable :: tp_dyn_core_pk_44h(:,:,:,:)
real, allocatable :: tp_dyn_core_pkc_24h(:,:,:,:)
real, allocatable :: tp_dyn_core_pkc_43h(:,:,:,:)
real, allocatable :: tp_dyn_core_pt_30h(:,:,:,:)
real, allocatable :: tp_dyn_core_pt_40h(:,:,:,:)
real, allocatable :: tp_dyn_core_ptc_16h(:,:,:,:)
real, allocatable :: tp_dyn_core_ptc_19h(:,:,:,:)
real, allocatable :: tp_dyn_core_ptc_28h(:,:,:,:)
real, allocatable :: tp_dyn_core_vt_27h(:,:,:,:)
real, allocatable :: tp_dyn_core_w_39h(:,:,:,:)
real, allocatable :: tp_dyn_core_xfx_35h(:,:,:,:)
real, allocatable :: tp_dyn_core_yfx_36h(:,:,:,:)
real, allocatable :: tp_dyn_core_zh_20h(:,:,:,:)
real, allocatable :: tp_dyn_core_zh_32h(:,:,:,:)

end module     addyn_core_store


module     adone_grad_p_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real, allocatable :: tp_one_gradb_gz_12h(:,:,:)
real, allocatable :: tp_one_gradb_gz_13h(:,:,:)
real, allocatable :: tp_one_gradb_gz_19h(:,:,:)
real, allocatable :: tp_one_gradb_gz_20h(:,:,:)
integer :: tp_one_gradb_one_grad_p
real, allocatable :: tp_one_gradb_pkc_14h(:,:,:)
real, allocatable :: tp_one_gradb_pkc_15h(:,:,:)
real, allocatable :: tp_one_gradb_pkc_21h(:,:,:)
real, allocatable :: tp_one_gradb_pkc_22h(:,:,:)
real, allocatable :: tp_one_gradb_wk_11h(:,:,:)
real, allocatable :: tp_one_gradb_wk_18h(:,:,:)

end module     adone_grad_p_store


module     adtwo_grad_p_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real, allocatable :: tp_two_gradb_gz_12h(:,:,:)
real, allocatable :: tp_two_gradb_gz_20h(:,:,:)
real, allocatable :: tp_two_gradb_pk3_14h(:,:,:)
real, allocatable :: tp_two_gradb_pk3_22h(:,:,:)
real, allocatable :: tp_two_gradb_pk3_5h(:,:,:)
real, allocatable :: tp_two_gradb_pkc_13h(:,:,:)
real, allocatable :: tp_two_gradb_pkc_21h(:,:,:)
integer :: tp_two_gradb_two_grad_p
real, allocatable :: tp_two_gradb_wk1_10h(:,:,:)
real, allocatable :: tp_two_gradb_wk1_18h(:,:,:)

end module     adtwo_grad_p_store


module     addyn_core_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.28  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains, mpp_update_domains_ad,mpp_get_boundary_ad


use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use dyn_core_mod

use fv_grid_utils_mod, only: sw_corner, se_corner, ne_corner, nw_corner

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

public addyn_core

contains
subroutine adadv_pe( adua, adva, adpem, adom, npx, npy, npz, ng, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use ada2b_edge_mod, only : ada2b_ord2, ada2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adadv_pe_store, only : tp_advpe_adv_pe,tp_advpe_grad_25h,tp_advpe_v3_24h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: adom(isd:ied,jsd:jed,npz)
real, intent(inout) :: adpem(is-1:ie+1,1:npz+1,js-1:je+1)
real, intent(inout) :: adua(isd:ied,jsd:jed,npz)
real, intent(inout) :: adva(isd:ied,jsd:jed,npz)
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer :: taf_rec

!==============================================
! declare local variables
!==============================================
real :: adgrad(3,is:ie,js:je)
real :: adpb(isd:ied,jsd:jed)
real :: adpdx(3,is:ie,js:je+1)
real :: adpdy(3,is:ie+1,js:je)
real :: adpin(isd:ied,jsd:jed)
real :: adut(is:ie,js:je)
real :: adv3(3,is:ie,js:je)
real :: advt(is:ie,js:je)
real :: grad(3,is:ie,js:je)
integer :: i
integer :: j
integer :: k
integer :: n
real :: v3(3,is:ie,js:je)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adgrad(:,:,:) = 0.
adpb(:,:) = 0.
adpdx(:,:,:) = 0.
adpdy(:,:,:) = 0.
adpin(:,:) = 0.
adut(:,:) = 0.
adv3(:,:,:) = 0.
advt(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do k = npz, 1, -1
  v3 = tp_advpe_v3_24h(:,:,:,(taf_rec-1)*npz+k)
  grad = tp_advpe_grad_25h(:,:,:,(taf_rec-1)*npz+k)
  do j = js, je
    do i = is, ie
      adgrad(3,i,j) = adgrad(3,i,j)+0.5*adom(i,j,k)*rarea(i,j)*v3(3,i,j)
      adgrad(2,i,j) = adgrad(2,i,j)+0.5*adom(i,j,k)*rarea(i,j)*v3(2,i,j)
      adgrad(1,i,j) = adgrad(1,i,j)+0.5*adom(i,j,k)*rarea(i,j)*v3(1,i,j)
      adv3(3,i,j) = adv3(3,i,j)+0.5*adom(i,j,k)*rarea(i,j)*grad(3,i,j)
      adv3(2,i,j) = adv3(2,i,j)+0.5*adom(i,j,k)*rarea(i,j)*grad(2,i,j)
      adv3(1,i,j) = adv3(1,i,j)+0.5*adom(i,j,k)*rarea(i,j)*grad(1,i,j)
    end do
  end do
  do j = js, je
    do i = is, ie
      do n = 1, 3
        adpdx(n,i,j+1) = adpdx(n,i,j+1)+adgrad(n,i,j)
        adpdx(n,i,j) = adpdx(n,i,j)-adgrad(n,i,j)
        adpdy(n,i+1,j) = adpdy(n,i+1,j)+adgrad(n,i,j)
        adpdy(n,i,j) = adpdy(n,i,j)-adgrad(n,i,j)
        adgrad(n,i,j) = 0.
      end do
    end do
  end do
  do j = js, je
    do i = is, ie+1
      do n = 1, 3
        adpb(i,j+1) = adpb(i,j+1)+adpdy(n,i,j)*dy(i,j)*en2(n,i,j)
        adpb(i,j) = adpb(i,j)+adpdy(n,i,j)*dy(i,j)*en2(n,i,j)
        adpdy(n,i,j) = 0.
      end do
    end do
  end do
  do j = js, je+1
    do i = is, ie
      do n = 1, 3
        adpb(i+1,j) = adpb(i+1,j)+adpdx(n,i,j)*dx(i,j)*en1(n,i,j)
        adpb(i,j) = adpb(i,j)+adpdx(n,i,j)*dx(i,j)*en1(n,i,j)
        adpdx(n,i,j) = 0.
      end do
    end do
  end do
  call ada2b_ord2( adpin,adpb,npx,npy,is,ie,js,je,ng )
  do j = js-1, je+1
    do i = is-1, ie+1
      adpem(i,k+1,j) = adpem(i,k+1,j)+adpin(i,j)
      adpin(i,j) = 0.
    end do
  end do
  do j = js, je
    do i = is, ie
      do n = 1, 3
        adut(i,j) = adut(i,j)+adv3(n,i,j)*ec1(n,i,j)
        advt(i,j) = advt(i,j)+adv3(n,i,j)*ec2(n,i,j)
        adv3(n,i,j) = 0.
      end do
    end do
  end do
  if (k .eq. npz) then
    do j = js, je
      do i = is, ie
        adva(i,j,npz) = adva(i,j,npz)+advt(i,j)
        advt(i,j) = 0.
        adua(i,j,npz) = adua(i,j,npz)+adut(i,j)
        adut(i,j) = 0.
      end do
    end do
  else
    do j = js, je
      do i = is, ie
        adva(i,j,k+1) = adva(i,j,k+1)+0.5*advt(i,j)
        adva(i,j,k) = adva(i,j,k)+0.5*advt(i,j)
        advt(i,j) = 0.
        adua(i,j,k+1) = adua(i,j,k+1)+0.5*adut(i,j)
        adua(i,j,k) = adua(i,j,k)+0.5*adut(i,j)
        adut(i,j) = 0.
      end do
    end do
  endif
end do

end subroutine adadv_pe


subroutine addyn_core( npx, npy, npz, ng, bdt, n_split, cp, akap, hydrostatic, adu, adv, w, adw, addelz, pt, adpt, delp, addelp, &
&pe, adpe, pk, adpk, omga, adomga, ptop, pfull, adua, adva, aduc, advc, admfx, admfy, adcx, adcy, adpem, peln, adpeln, uniform_ppm )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use nh_core_mod, only : riem_solver, riem_solver_c, update_dz_c, update_dz_d
use adnh_core_mod, only : adriem_solver, adriem_solver_c, adupdate_dz_c, adupdate_dz_d
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use fv_my_mpp, only : mpp_get_boundary_dummy, mpp_update_domains_dummy
use adfv_my_mpp, only : admpp_get_boundary_dgrid, admpp_update_domains_cgrid, admpp_update_domains_dgrid, &
&admpp_update_domains_dummy, admpp_update_domains_dummy
use fv_my_mpp, only : mpp_update_domains_cgrid, mpp_update_domains_dgrid
use fv_my_mpp, only : mpp_get_boundary_dgrid
use addyn_core_store, only : tp2d_dyn_core_delpc_6h,tp2d_dyn_core_dyn_core,tp_dyn_core_crx_33h,tp_dyn_core_cry_34h,&
&tp_dyn_core_delp_31h,tp_dyn_core_delp_41h,tp_dyn_core_delpc_15h,tp_dyn_core_delpc_18h,tp_dyn_core_delpc_37h,tp_dyn_core_dyn_core,&
&tp_dyn_core_gz_25h,tp_dyn_core_gz_42h,tp_dyn_core_last_step_11h,tp_dyn_core_omga_17h,tp_dyn_core_pe_45h,tp_dyn_core_peln_38h,&
&tp_dyn_core_pk_44h,tp_dyn_core_pkc_24h,tp_dyn_core_pkc_43h,tp_dyn_core_pt_30h,tp_dyn_core_pt_40h,tp_dyn_core_ptc_16h,&
&tp_dyn_core_ptc_19h,tp_dyn_core_ptc_28h,tp_dyn_core_vt_27h,tp_dyn_core_w_39h,tp_dyn_core_xfx_35h,tp_dyn_core_yfx_36h,&
&tp_dyn_core_zh_20h,tp_dyn_core_zh_32h
use adsw_core_mod, only : adc_sw, add_sw, addivergence_corner
use ada2b_edge_mod, only : ada2b_ord2

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: adcx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: adcy(isd:ied,js:je+1,npz)
real, intent(inout) :: addelp(isd:ied,jsd:jed,npz)
real, intent(inout) :: addelz(is:ie,js:je,npz)
real, intent(inout) :: admfx(is:ie+1,js:je,npz)
real, intent(inout) :: admfy(is:ie,js:je+1,npz)
real, intent(inout) :: adomga(isd:ied,jsd:jed,npz)
real, intent(inout) :: adpe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: adpeln(is:ie,npz+1,js:je)
real, intent(inout) :: adpem(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: adpk(is:ie,js:je,npz+1)
real, intent(inout) :: adpt(isd:ied,jsd:jed,npz)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adua(isd:ied,jsd:jed,npz)
real, intent(inout) :: aduc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adva(isd:ied,jsd:jed,npz)
real, intent(inout) :: advc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adw(isd:ied,jsd:jed,npz)
real, intent(in) :: akap
real, intent(in) :: bdt
real, intent(in) :: cp
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
logical, intent(in) :: hydrostatic
integer :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(in) :: pfull(npz)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(in) :: ptop
logical, intent(in) :: uniform_ppm
real, intent(inout) :: w(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: adcrx(is:ie+1,jsd:jed,npz)
real :: adcry(isd:ied,js:je+1,npz)
real :: addelpc(isd:ied,jsd:jed,npz)
real :: addivg2(is:ie+1,js:je+1)
real :: addivg_d(isd:ied+1,jsd:jed+1,npz)
real :: adgz(isd:ied,jsd:jed,npz+1)
real, allocatable :: adpk3h(:,:,:)
real :: adpkc(isd:ied,jsd:jed,npz+1)
real :: adptc(isd:ied,jsd:jed,npz)
real :: adut(isd:ied,jsd:jed,npz)
real :: advt(isd:ied,jsd:jed,npz)
real :: adwk(isd:ied,jsd:jed)
real :: adxfx(is:ie+1,jsd:jed,npz)
real :: adyfx(isd:ied,js:je+1,npz)
real :: adzh(isd:ied,jsd:jed,npz)
real :: crx(is:ie+1,jsd:jed,npz)
real :: cry(isd:ied,js:je+1,npz)
real :: d_divg
real :: delpc(isd:ied,jsd:jed,npz)
real :: divg2(is:ie+1,js:je+1)
logical :: do_omega
logical :: dord4
real :: dt
real :: dt2
real :: gz(isd:ied,jsd:jed,npz+1)
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: help_r
integer :: help_s
integer :: help_t
integer :: help_u
integer :: hord_m
integer :: hord_t
integer :: hord_v
integer :: i
integer :: ieb1
integer :: iep1
integer :: ism1
integer :: it
integer :: j
integer :: jeb1
integer :: jep1
integer :: jsm1
integer :: k
logical :: last_step
real :: pk3(isd:ied,jsd:jed,npz+1)
real :: pkc(isd:ied,jsd:jed,npz+1)
real :: ptc(isd:ied,jsd:jed,npz)
real :: rdt
integer :: taf_rec_npz
real :: vt(isd:ied,jsd:jed,npz)
real :: wk(isd:ied,jsd:jed)
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)
real :: zh(isd:ied,jsd:jed,npz)

!==============================================
! declare data
!==============================================

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adcrx(:,:,:) = 0.
adcry(:,:,:) = 0.
addelpc(:,:,:) = 0.
addivg2(:,:) = 0.
addivg_d(:,:,:) = 0.
adgz(:,:,:) = 0.
adpkc(:,:,:) = 0.
adptc(:,:,:) = 0.
adut(:,:,:) = 0.
advt(:,:,:) = 0.
adwk(:,:) = 0.
adxfx(:,:,:) = 0.
adyfx(:,:,:) = 0.
adzh(:,:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (dddm4 .gt. 0.) then
  dord4 =  .true. 
else
  dord4 =  .false. 
endif
dt = bdt/real(n_split)
dt2 = 0.5*dt
rdt = 1./dt
ism1 = is-1
iep1 = ie+1
jsm1 = js-1
jep1 = je+1
do it = n_split, 1, -1
  if (it .eq. n_split) then
    do_omega =  .true. 
  else
    do_omega =  .false. 
  endif
  last_step = tp_dyn_core_last_step_11h(it)
  ieb1 = ie+1
  jeb1 = je+1
  help_j = jed+1
  help_k = ied+1
  vt = tp_dyn_core_vt_27h(:,:,:,it)
  ptc = tp_dyn_core_ptc_28h(:,:,:,it)
  help_r = jed+1
  help_s = ied+1
  if (last_step .and. grid_type .lt. 4) then
    help_t = jed+1
    help_u = ied+1
    call admpp_get_boundary_dgrid( adu,adv,is,ie,js,je,isd,ied,jsd,help_t,npz,is,ie,js,je,isd,help_u,jsd,jed,npz,npx,npy,npz,is,ie,js,je )
  endif
  call admpp_update_domains_dgrid( adu,adv,is,ie,js,je,isd,ied,jsd,help_r,npz,is,ie,js,je,isd,help_s,jsd,jed,npz )
  if (( .not. hydrostatic) .and. m_grad_p .eq. 0) then
    allocate( adpk3h(isd:ied,jsd:jed,1:npz+1) )
    adpk3h(:,:,:) = 0.
    call adtwo_grad_p( adu,adv,pkc,adpkc,gz,adgz,addelp,pk3,adpk3h,addivg2,dt,ng,npx,npy,npz,it )
    deallocate( adpk3h )
  else
    call adone_grad_p( adu,adv,pkc,adpkc,gz,adgz,addivg2,addelp,dt,ng,npx,npy,npz,hydrostatic,it )
  endif
  if (do_omega) then
    call adadv_pe( adua,adva,adpem,adomga,npx,npy,npz,ng,it )
    do k = 1, npz
      do j = js, je
        do i = is, ie
          adpe(i,k+1,j) = adpe(i,k+1,j)+adomga(i,j,k)*rdt
          adpem(i,k+1,j) = adpem(i,k+1,j)-adomga(i,j,k)*rdt
          adomga(i,j,k) = 0.
        end do
      end do
    end do
  endif
  if (last_step .and. hydrostatic) then
    do k = 1, npz+1
      do j = js, je
        do i = is, ie
          adpkc(i,j,k) = adpkc(i,j,k)+adpk(i,j,k)
          adpk(i,j,k) = 0.
        end do
      end do
    end do
  endif
  if (hydrostatic) then
    pt = tp_dyn_core_pt_30h(:,:,:,it)
    delp = tp_dyn_core_delp_31h(:,:,:,it)
    call adgeopk( ptop,adpe,adpeln,delp,addelp,pkc,adpkc,adgz,pt,adpt,npz,akap,last_step, .false.  )
  else
    zh = tp_dyn_core_zh_32h(:,:,:,it)
    crx = tp_dyn_core_crx_33h(:,:,:,it)
    cry = tp_dyn_core_cry_34h(:,:,:,it)
    xfx = tp_dyn_core_xfx_35h(:,:,:,it)
    yfx = tp_dyn_core_yfx_36h(:,:,:,it)
    delpc = tp_dyn_core_delpc_37h(:,:,:,it)
    peln = tp_dyn_core_peln_38h(:,:,:,it)
    w = tp_dyn_core_w_39h(:,:,:,it)
    pt = tp_dyn_core_pt_40h(:,:,:,it)
    delp = tp_dyn_core_delp_41h(:,:,:,it)
    gz = tp_dyn_core_gz_42h(:,:,:,it)
    pkc = tp_dyn_core_pkc_43h(:,:,:,it)
    pk = tp_dyn_core_pk_44h(:,:,:,it)
    pe = tp_dyn_core_pe_45h(:,:,:,it)
    if (a2b_ord .eq. 4) then
      help_n = npz+1
      help_o = npz+1
      call admpp_update_domains_dummy( adgz,is,ie,js,je,isd,ied,jsd,jed,help_o )
      call admpp_update_domains_dummy( adpkc,is,ie,js,je,isd,ied,jsd,jed,help_n )
    else
      help_p = npz+1
      help_q = npz+1
      call admpp_update_domains_dummy( adgz,is,ie,js,je,isd,ied,jsd,jed,help_q )
      call admpp_update_domains_dummy( adpkc,is,ie,js,je,isd,ied,jsd,jed,help_p )
    endif
    call adriem_solver( dt,is,ie,js,je,npz,ng,akap,cp,ptop,peln,adpeln,w,adw,pt,adpt,delp,addelp,gz,adgz,pkc,adpkc,pk,adpk,pe,adpe,&
&m_grad_p )
    call adupdate_dz_d( hord_tm,is,ie,js,je,npz,ng,npx,npy,area,zh,adzh,crx,adcrx,cry,adcry,xfx,adxfx,yfx,adyfx,delpc,addelpc,&
&n_sponge )
  endif
  call admpp_update_domains_dummy( addelp,is,ie,js,je,isd,ied,jsd,jed,npz )
  call admpp_update_domains_dummy( adpt,is,ie,js,je,isd,ied,jsd,jed,npz )
  if (d_ext .gt. 0.) then
    d_divg = d_ext*da_min_c
    do j = js, jep1
      do i = is, iep1
        wk(i,j) = ptc(i,j,1)
        divg2(i,j) = wk(i,j)*vt(i,j,1)
      end do
      do k = 2, npz
        do i = is, iep1
          wk(i,j) = wk(i,j)+ptc(i,j,k)
          divg2(i,j) = divg2(i,j)+ptc(i,j,k)*vt(i,j,k)
        end do
      end do
      do i = is, iep1
        adwk(i,j) = adwk(i,j)-addivg2(i,j)*(d_divg*divg2(i,j)/(wk(i,j)*wk(i,j)))
        addivg2(i,j) = addivg2(i,j)*(d_divg/wk(i,j))
      end do
      do k = npz, 2, -1
        do i = is, iep1
          adptc(i,j,k) = adptc(i,j,k)+addivg2(i,j)*vt(i,j,k)
          advt(i,j,k) = advt(i,j,k)+addivg2(i,j)*ptc(i,j,k)
          adptc(i,j,k) = adptc(i,j,k)+adwk(i,j)
        end do
      end do
      do i = is, iep1
        wk(i,j) = ptc(i,j,1)
        advt(i,j,1) = advt(i,j,1)+addivg2(i,j)*wk(i,j)
        adwk(i,j) = adwk(i,j)+addivg2(i,j)*vt(i,j,1)
        addivg2(i,j) = 0.
        adptc(i,j,1) = adptc(i,j,1)+adwk(i,j)
        adwk(i,j) = 0.
      end do
    end do
  else
    addivg2 = 0.
  endif
  do k = npz, 1, -1
    hord_m = hord_mt
    hord_t = hord_tm
    hord_v = hord_vt
    if (n_sponge .eq. (-1) .or. npz .eq. 1) then
      d_divg = dddmp
    else
      if (k .le. n_sponge .and. npz .gt. 16) then
        hord_v = 1
        hord_t = 1
        d_divg = min(0.24,6.*dddmp)
        d_divg = max(0.02,d_divg)
      else if (k .eq. n_sponge+1 .and. npz .gt. 16) then
        d_divg = min(0.24,4.*dddmp)
        d_divg = max(0.01,d_divg)
      else
        d_divg = min(0.24,dddmp*(1.-3.*tanh(0.1*log(pfull(k)/pfull(npz)))))
      endif
    endif
    taf_rec_npz = (it-1)*npz+k
    if (d_ext .gt. 0.) then
      do j = js, jep1
        do i = is, iep1
          adwk(i,j) = adwk(i,j)+adptc(i,j,k)
          adptc(i,j,k) = 0.
        end do
      end do
    endif
         call timing_on('adm_dsw')
    call add_sw( advt(isd,jsd,k),addelp(isd,jsd,k),adptc(isd,jsd,k),adpt(isd,jsd,k),adu(isd,jsd,k),adv(isd,jsd,k),adw(isd,jsd,k),&
&aduc(isd,jsd,k),advc(isd,jsd,k),adua(isd,jsd,k),adva(isd,jsd,k),addivg_d(isd,jsd,k),admfx(is,js,k),admfy(is,js,k),adcx(is,jsd,&
&k),adcy(isd,js,k),adcrx(is,jsd,k),adcry(isd,js,k),adxfx(is,jsd,k),adyfx(isd,js,k),dt,hord_m,hord_v,hord_t,d_divg,dddm4,&
&hydrostatic,uniform_ppm,taf_rec_npz )
         call timing_off('adm_dsw')
    if (d_ext .gt. 0.) then
      call ada2b_ord2( addelp(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng, .false.  )
    endif
  end do
  if (dord4) then
    if (grid_type .ne. 4) then
      call admpp_update_domains_dummy( addivg_d,is,ie,js,je,isd,ied,jsd,jed,npz )
    endif
    call addivergence_corner( adu,adv,adua,adva,addivg_d,npz )
  endif
  call admpp_update_domains_cgrid( advc,aduc,is,ie,js,je,isd,ied,jsd,help_j,npz,is,ie,js,je,isd,help_k,jsd,jed,npz )
  pkc = tp_dyn_core_pkc_24h(:,:,:,it)
  gz = tp_dyn_core_gz_25h(:,:,:,it)
  do k = npz, 1, -1
    delpc(:,:,k) = tp2d_dyn_core_delpc_6h(:,:,(it-1)*npz+k)
    if (hydrostatic) then
      do j = jsm1, jeb1
        do i = ism1, ieb1
          wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
        end do
      end do
    else
      do j = jsd, jed
        do i = isd, ied
          wk(i,j) = delpc(i,j,k)
        end do
      end do
    endif
    do j = js, jeb1
      do i = is, ie
        adgz(i,j-1,k+1) = adgz(i,j-1,k+1)+advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))
        adgz(i,j-1,k) = adgz(i,j-1,k)+advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k))
        adgz(i,j,k+1) = adgz(i,j,k+1)-advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j-1,k+1)-pkc(i,j,k))
        adgz(i,j,k) = adgz(i,j,k)-advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(pkc(i,j,k+1)-pkc(i,j-1,k))
        adpkc(i,j-1,k+1) = adpkc(i,j-1,k+1)+advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k)-gz(i,j,k+1))
        adpkc(i,j-1,k) = adpkc(i,j-1,k)-advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))
        adpkc(i,j,k+1) = adpkc(i,j,k+1)+advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k+1)-gz(i,j,k))
        adpkc(i,j,k) = adpkc(i,j,k)-advc(i,j,k)*dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*(gz(i,j-1,k)-gz(i,j,k+1))
        adwk(i,j-1) = adwk(i,j-1)-advc(i,j,k)*dt2*rdyc(i,j)/((wk(i,j-1)+wk(i,j))*(wk(i,j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
        adwk(i,j) = adwk(i,j)-advc(i,j,k)*dt2*rdyc(i,j)/((wk(i,j-1)+wk(i,j))*(wk(i,j-1)+wk(i,j)))*((gz(i,j-1,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      end do
    end do
    do j = js, je
      do i = is, ieb1
        adgz(i-1,j,k+1) = adgz(i-1,j,k+1)+aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))
        adgz(i,j,k+1) = adgz(i,j,k+1)-aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k))
        adgz(i-1,j,k) = adgz(i-1,j,k)+aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i-1,j,k+1)-pkc(i,j,k))
        adgz(i,j,k) = adgz(i,j,k)-aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(pkc(i,j,k+1)-pkc(i-1,j,k))
        adpkc(i-1,j,k+1) = adpkc(i-1,j,k+1)+aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k)-gz(i,j,k+1))
        adpkc(i,j,k+1) = adpkc(i,j,k+1)+aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))
        adpkc(i-1,j,k) = adpkc(i-1,j,k)-aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k+1)-gz(i,j,k))
        adpkc(i,j,k) = adpkc(i,j,k)-aduc(i,j,k)*dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*(gz(i-1,j,k)-gz(i,j,k+1))
        adwk(i-1,j) = adwk(i-1,j)-aduc(i,j,k)*dt2*rdxc(i,j)/((wk(i-1,j)+wk(i,j))*(wk(i-1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
        adwk(i,j) = adwk(i,j)-aduc(i,j,k)*dt2*rdxc(i,j)/((wk(i-1,j)+wk(i,j))*(wk(i-1,j)+wk(i,j)))*((gz(i-1,j,k+1)-gz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
      end do
    end do
    if (hydrostatic) then
      do j = jsm1, jeb1
        do i = ism1, ieb1
          adpkc(i,j,k+1) = adpkc(i,j,k+1)+adwk(i,j)
          adpkc(i,j,k) = adpkc(i,j,k)-adwk(i,j)
          adwk(i,j) = 0.
        end do
      end do
    else
      do j = jsd, jed
        do i = isd, ied
          addelp(i,j,k) = addelp(i,j,k)+addelpc(i,j,k)
          addelpc(i,j,k) = 0.
          addelpc(i,j,k) = addelpc(i,j,k)+adwk(i,j)
          adwk(i,j) = 0.
        end do
      end do
    endif
  end do
  if (hydrostatic) then
    delpc = tp_dyn_core_delpc_15h(:,:,:,it)
    ptc = tp_dyn_core_ptc_16h(:,:,:,it)
    call adgeopk( ptop,adpe,adpeln,delpc,addelpc,pkc,adpkc,adgz,ptc,adptc,npz,akap, .false. , .true.  )
  else
    omga = tp_dyn_core_omga_17h(:,:,:,it)
    delpc = tp_dyn_core_delpc_18h(:,:,:,it)
    ptc = tp_dyn_core_ptc_19h(:,:,:,it)
    zh = tp_dyn_core_zh_20h(:,:,:,it)
    help_h = npz+1
    help_i = npz+1
    call admpp_update_domains_dummy( adgz,is,ie,js,je,isd,ied,jsd,jed,help_i )
    call admpp_update_domains_dummy( adpkc,is,ie,js,je,isd,ied,jsd,jed,help_h )
    call adriem_solver_c( dt2,is,ie,js,je,npz,ng,akap,cp,ptop,omga,adomga,ptc,adptc,delpc,addelpc,1 )
    call adupdate_dz_c( is,ie,js,je,npz,ng,area,zh,adgz )
  endif
  do k = npz, 1, -1
    taf_rec_npz = (it-1)*npz+k
    call adc_sw( addelpc(isd,jsd,k),addelp(isd,jsd,k),adptc(isd,jsd,k),adpt(isd,jsd,k),adu(isd,jsd,k),adv(isd,jsd,k),adw(isd,jsd,k)&
&,aduc(isd,jsd,k),advc(isd,jsd,k),adua(isd,jsd,k),adva(isd,jsd,k),adomga(isd,jsd,k),adut(isd,jsd,k),advt(isd,jsd,k),dt2,&
&hydrostatic,dord4,taf_rec_npz )
  end do
  if (it .eq. n_split) then
    do j = jsm1, jep1
      do k = npz, 1, -1
        do i = ism1, iep1
          addelp(i,j,k) = addelp(i,j,k)+adpem(i,k+1,j)
          adpem(i,k,j) = adpem(i,k,j)+adpem(i,k+1,j)
          adpem(i,k+1,j) = 0.
        end do
      end do
      do i = ism1, iep1
        adpem(i,1,j) = 0.
      end do
    end do
  endif
  if ( .not. hydrostatic) then
    call admpp_update_domains_dummy( adw,is,ie,js,je,isd,ied,jsd,jed,npz )
    call admpp_update_domains_dummy( adzh,is,ie,js,je,isd,ied,jsd,jed,npz )
    do j = js, je
      do k = 1, npz-1
        do i = is, ie
          addelz(i,j,k) = addelz(i,j,k)-adzh(i,j,k)
          adzh(i,j,k+1) = adzh(i,j,k+1)+adzh(i,j,k)
          adzh(i,j,k) = 0.
        end do
      end do
      do i = is, ie
        addelz(i,j,npz) = addelz(i,j,npz)-adzh(i,j,npz)
        adzh(i,j,npz) = 0.
      end do
    end do
  endif
end do
call admpp_update_domains_dummy( addelp,is,ie,js,je,isd,ied,jsd,jed,npz )
if (npz .gt. 1) then
  call admpp_update_domains_dummy( adpt,is,ie,js,je,isd,ied,jsd,jed,npz )
endif

end subroutine addyn_core


subroutine adgeopk( ptop, adpe, adpeln, delp, addelp, pk, adpk, adgz, pt, adpt, km, akap, last_call, cg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use ada2b_edge_mod, only : ada2b_ord2, ada2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: km
real, intent(inout) :: addelp(isd:ied,jsd:jed,km)
real, intent(inout) :: adgz(isd:ied,jsd:jed,km+1)
real, intent(inout) :: adpe(is-1:ie+1,km+1,js-1:je+1)
real, intent(inout) :: adpeln(is:ie,km+1,js:je)
real, intent(inout) :: adpk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: adpt(isd:ied,jsd:jed,km)
real, intent(in) :: akap
logical, intent(in) :: cg
real, intent(inout) :: delp(isd:ied,jsd:jed,km)
logical, intent(in) :: last_call
real, intent(out) :: pk(isd:ied,jsd:jed,km+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,km)
real, intent(in) :: ptop

!==============================================
! declare local variables
!==============================================
real :: adlogp(is-2:ie+2)
real :: adp1d(is-2:ie+2)
integer :: i
integer :: ifirst
integer :: ilast
integer :: j
integer :: jfirst
integer :: jlast
integer :: k
real :: logp(is-2:ie+2)
real :: p1d(is-2:ie+2)
integer :: tape_geopk_geopk
real, allocatable :: tape_geopk_p1d_1h(:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adlogp(:) = 0.
adp1d(:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
ifirst = is-1
jfirst = js-1
ilast = ie+1
jlast = je+1
if (( .not. cg) .and. a2b_ord .eq. 4) then
  ifirst = is-2
  ilast = ie+2
  jfirst = js-2
  jlast = je+2
endif
do j = jlast, jfirst, -1
  do i = ifirst, ilast
    p1d(i) = ptop
  end do
!----------------------------------------------
! OPEN TAPE tape_geopk
!----------------------------------------------
  tape_geopk_geopk = km+1-2+1

!----------------------------------------------
! TAPE COMPUTATIONS
!----------------------------------------------
  do k = 2, km
    if ( .not. allocated(tape_geopk_p1d_1h)) then
      allocate( tape_geopk_p1d_1h(is-2:ie+2,tape_geopk_geopk) )
    endif
    tape_geopk_p1d_1h(:,k-1) = p1d
    do i = ifirst, ilast
      p1d(i) = p1d(i)+delp(i,j,k-1)
    end do
  end do
  k = km+1
  if ( .not. allocated(tape_geopk_p1d_1h)) then
    allocate( tape_geopk_p1d_1h(is-2:ie+2,tape_geopk_geopk) )
  endif
  tape_geopk_p1d_1h(:,k-1) = p1d

!----------------------------------------------
! ADJOINT COMPUTATIONS
!----------------------------------------------
  do i = ifirst, ilast
    p1d(i) = ptop
  end do
  do k = 2, km+1
    do i = ifirst, ilast
      p1d(i) = p1d(i)+delp(i,j,k-1)
      logp(i) = log(p1d(i))
      pk(i,j,k) = exp(akap*logp(i))
    end do
  end do
  do k = 1, km
    do i = ifirst, ilast
      adgz(i,j,k+1) = adgz(i,j,k+1)+adgz(i,j,k)
      adpk(i,j,k+1) = adpk(i,j,k+1)+adgz(i,j,k)*pt(i,j,k)
      adpk(i,j,k) = adpk(i,j,k)-adgz(i,j,k)*pt(i,j,k)
      adpt(i,j,k) = adpt(i,j,k)+adgz(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
      adgz(i,j,k) = 0.
    end do
  end do
  do k = km+1, 2, -1
    p1d = tape_geopk_p1d_1h(:,k-1)
    if (last_call .and. j .gt. js-2 .and. j .lt. je+2) then
      if (j .ge. js .and. j .le. je) then
        do i = is, ie
          adlogp(i) = adlogp(i)+adpeln(i,k,j)
          adpeln(i,k,j) = 0.
        end do
      endif
      do i = max(ifirst,is-1), min(ilast,ie+1)
        adp1d(i) = adp1d(i)+adpe(i,k,j)
        adpe(i,k,j) = 0.
      end do
    endif
    do i = ifirst, ilast
      p1d(i) = p1d(i)+delp(i,j,k-1)
      logp(i) = log(p1d(i))
      adlogp(i) = adlogp(i)+adpk(i,j,k)*akap*exp(akap*logp(i))
      adpk(i,j,k) = 0.
      adp1d(i) = adp1d(i)+adlogp(i)*(1./p1d(i))
      adlogp(i) = 0.
      addelp(i,j,k-1) = addelp(i,j,k-1)+adp1d(i)
    end do
  end do

!----------------------------------------------
! CLOSE TAPE tape_geopk
!----------------------------------------------
  if (allocated(tape_geopk_p1d_1h)) then
    deallocate( tape_geopk_p1d_1h )
  endif

  if (last_call .and. j .gt. js-2 .and. j .lt. je+2) then
    do i = max(ifirst,is-1), min(ilast,ie+1)
      adpe(i,1,j) = 0.
    end do
  endif
  do i = ifirst, ilast
    adgz(i,j,km+1) = 0.
    adpk(i,j,1) = 0.
    adp1d(i) = 0.
  end do
end do

end subroutine adgeopk


subroutine adone_grad_p( adu, adv, pkc, adpkc, gz, adgz, addivg2, addelp, dt, ng, npx, npy, npz, hydrostatic, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adone_grad_p_store, only : tp_one_gradb_gz_12h,tp_one_gradb_gz_13h,tp_one_gradb_gz_19h,tp_one_gradb_gz_20h,&
&tp_one_gradb_one_grad_p,tp_one_gradb_pkc_14h,tp_one_gradb_pkc_15h,tp_one_gradb_pkc_21h,tp_one_gradb_pkc_22h,tp_one_gradb_wk_11h,&
&tp_one_gradb_wk_18h
use ada2b_edge_mod, only : ada2b_ord2, ada2b_ord4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: addelp(isd:ied,jsd:jed,npz)
real, intent(inout) :: addivg2(is:ie+1,js:je+1)
real, intent(inout) :: adgz(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: adpkc(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(in) :: dt
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
logical, intent(in) :: hydrostatic
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
integer :: taf_rec

!==============================================
! declare local variables
!==============================================
real :: adwk(isd:ied,jsd:jed)
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: wk(isd:ied,jsd:jed)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adwk(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
iep1 = ie+1
jep1 = je+1
do k = npz, 1, -1
  wk = tp_one_gradb_wk_18h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k) = tp_one_gradb_gz_19h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k+1) = tp_one_gradb_gz_20h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k) = tp_one_gradb_pkc_21h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k+1) = tp_one_gradb_pkc_22h(:,:,(taf_rec-1)*npz+k)
  do j = js, je
    do i = is, iep1
      addivg2(i,j+1) = addivg2(i,j+1)-adv(i,j,k)*rdy(i,j)
      addivg2(i,j) = addivg2(i,j)+adv(i,j,k)*rdy(i,j)
      adgz(i,j+1,k+1) = adgz(i,j+1,k+1)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))
      adgz(i,j+1,k) = adgz(i,j+1,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))
      adpkc(i,j+1,k+1) = adpkc(i,j+1,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adpkc(i,j+1,k) = adpkc(i,j+1,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpkc(i,j,k+1) = adpkc(i,j,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpkc(i,j,k) = adpkc(i,j,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adwk(i,j+1) = adwk(i,j+1)-adv(i,j,k)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,&
&j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      adwk(i,j) = adwk(i,j)-adv(i,j,k)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,&
&k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      adv(i,j,k) = adv(i,j,k)*rdy(i,j)
    end do
  end do
  wk = tp_one_gradb_wk_11h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k) = tp_one_gradb_gz_12h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k+1) = tp_one_gradb_gz_13h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k) = tp_one_gradb_pkc_14h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k+1) = tp_one_gradb_pkc_15h(:,:,(taf_rec-1)*npz+k)
  do j = js, jep1
    do i = is, ie
      addivg2(i+1,j) = addivg2(i+1,j)-adu(i,j,k)*rdx(i,j)
      addivg2(i,j) = addivg2(i,j)+adu(i,j,k)*rdx(i,j)
      adgz(i+1,j,k+1) = adgz(i+1,j,k+1)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))
      adgz(i+1,j,k) = adgz(i+1,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))
      adpkc(i+1,j,k+1) = adpkc(i+1,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adpkc(i,j,k+1) = adpkc(i,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpkc(i+1,j,k) = adpkc(i+1,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpkc(i,j,k) = adpkc(i,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adwk(i+1,j) = adwk(i+1,j)-adu(i,j,k)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+&
&1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      adwk(i,j) = adwk(i,j)-adu(i,j,k)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,&
&k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      adu(i,j,k) = adu(i,j,k)*rdx(i,j)
    end do
  end do
  if (hydrostatic) then
    do j = js, jep1
      do i = is, iep1
        adpkc(i,j,k+1) = adpkc(i,j,k+1)+adwk(i,j)
        adpkc(i,j,k) = adpkc(i,j,k)-adwk(i,j)
        adwk(i,j) = 0.
      end do
    end do
  else
    if (a2b_ord .eq. 4) then
      call ada2b_ord4( addelp(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng )
    else
      call ada2b_ord2( addelp(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng )
    endif
  endif
end do
do k = npz+1, 1, -1
  if (a2b_ord .eq. 4) then
    call ada2b_ord4( adgz(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call ada2b_ord2( adgz(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = npz+1, 2, -1
  if (a2b_ord .eq. 4) then
    call ada2b_ord4( adpkc(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call ada2b_ord2( adpkc(isd,jsd,k),adwk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do j = js, jep1
  do i = is, iep1
    adpkc(i,j,1) = 0.
  end do
end do

end subroutine adone_grad_p


subroutine adtwo_grad_p( adu, adv, pkc, adpkc, gz, adgz, addelp, pk3, adpk3, addivg2, dt, ng, npx, npy, npz, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains

use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use ada2b_edge_mod, only : ada2b_ord2, ada2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adtwo_grad_p_store, only : tp_two_gradb_gz_12h,tp_two_gradb_gz_20h,tp_two_gradb_pk3_14h,tp_two_gradb_pk3_22h,&
&tp_two_gradb_pk3_5h,tp_two_gradb_pkc_13h,tp_two_gradb_pkc_21h,tp_two_gradb_two_grad_p,tp_two_gradb_wk1_10h,tp_two_gradb_wk1_18h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: addelp(isd:ied,jsd:jed,npz)
real, intent(inout) :: addivg2(is:ie+1,js:je+1)
real, intent(inout) :: adgz(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: adpk3(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: adpkc(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(in) :: dt
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pk3(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
integer :: taf_rec

!==============================================
! declare local variables
!==============================================
real :: adwk(is:ie+1,js:je+1)
real :: adwk1(isd:ied,jsd:jed)
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: wk(is:ie+1,js:je+1)
real :: wk1(isd:ied,jsd:jed)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adwk(:,:) = 0.
adwk1(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
iep1 = ie+1
jep1 = je+1
do k = npz, 1, -1
  pk3(:,:,k) = tp_two_gradb_pk3_5h(:,:,(taf_rec-1)*npz+k)
  do j = js, jep1
    do i = is, iep1
      wk(i,j) = pk3(i,j,k+1)-pk3(i,j,k)
    end do
  end do
  wk1 = tp_two_gradb_wk1_18h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k+1) = tp_two_gradb_gz_20h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k+1) = tp_two_gradb_pkc_21h(:,:,(taf_rec-1)*npz+k)
  pk3(:,:,k+1) = tp_two_gradb_pk3_22h(:,:,(taf_rec-1)*npz+k)
  do j = js, je
    do i = is, iep1
      addivg2(i,j+1) = addivg2(i,j+1)-adv(i,j,k)*rdy(i,j)
      addivg2(i,j) = addivg2(i,j)+adv(i,j,k)*rdy(i,j)
      adgz(i,j+1,k+1) = adgz(i,j+1,k+1)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j,k+1)-pk3(i,j+1,k))
      adgz(i,j+1,k) = adgz(i,j+1,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j+1,k+1)-pk3(i,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j+1,k+1)-pk3(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(pk3(i,j,k+1)-pk3(i,j+1,k))
      adpk3(i,j+1,k+1) = adpk3(i,j+1,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adpk3(i,j+1,k) = adpk3(i,j+1,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpk3(i,j,k+1) = adpk3(i,j,k+1)+adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpk3(i,j,k) = adpk3(i,j,k)-adv(i,j,k)*rdy(i,j)*dt/(wk(i,j)+wk(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adwk(i,j+1) = adwk(i,j+1)-adv(i,j,k)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,&
&j+1,k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k)))
      adwk(i,j) = adwk(i,j)-adv(i,j,k)*rdy(i,j)*dt/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,j+1,&
&k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k)))
      adv(i,j,k) = adv(i,j,k)*rdy(i,j)
      adgz(i,j+1,k+1) = adgz(i,j+1,k+1)-adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))
      adgz(i,j+1,k) = adgz(i,j+1,k)-adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j+1,k+1)-pkc(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))
      adpkc(i,j+1,k+1) = adpkc(i,j+1,k+1)+adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adpkc(i,j+1,k) = adpkc(i,j+1,k)-adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpkc(i,j,k+1) = adpkc(i,j,k+1)+adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k)-gz(i,j+1,k+1))
      adpkc(i,j,k) = adpkc(i,j,k)-adv(i,j,k)*dt/(wk1(i,j)+wk1(i,j+1))*(gz(i,j,k+1)-gz(i,j+1,k))
      adwk1(i,j+1) = adwk1(i,j+1)-adv(i,j,k)*dt/((wk1(i,j)+wk1(i,j+1))*(wk1(i,j)+wk1(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+&
&1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      adwk1(i,j) = adwk1(i,j)-adv(i,j,k)*dt/((wk1(i,j)+wk1(i,j+1))*(wk1(i,j)+wk1(i,j+1)))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+&
&1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k)))
    end do
  end do
  wk1 = tp_two_gradb_wk1_10h(:,:,(taf_rec-1)*npz+k)
  gz(:,:,k+1) = tp_two_gradb_gz_12h(:,:,(taf_rec-1)*npz+k)
  pkc(:,:,k+1) = tp_two_gradb_pkc_13h(:,:,(taf_rec-1)*npz+k)
  pk3(:,:,k+1) = tp_two_gradb_pk3_14h(:,:,(taf_rec-1)*npz+k)
  do j = js, jep1
    do i = is, ie
      addivg2(i+1,j) = addivg2(i+1,j)-adu(i,j,k)*rdx(i,j)
      addivg2(i,j) = addivg2(i,j)+adu(i,j,k)*rdx(i,j)
      adgz(i+1,j,k+1) = adgz(i+1,j,k+1)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i,j,k+1)-pk3(i+1,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i+1,j,k+1)-pk3(i,j,k))
      adgz(i+1,j,k) = adgz(i+1,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i+1,j,k+1)-pk3(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(pk3(i,j,k+1)-pk3(i+1,j,k))
      adpk3(i+1,j,k+1) = adpk3(i+1,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adpk3(i,j,k+1) = adpk3(i,j,k+1)+adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpk3(i+1,j,k) = adpk3(i+1,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpk3(i,j,k) = adpk3(i,j,k)-adu(i,j,k)*rdx(i,j)*dt/(wk(i,j)+wk(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adwk(i+1,j) = adwk(i+1,j)-adu(i,j,k)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+&
&1,j,k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k)))
      adwk(i,j) = adwk(i,j)-adu(i,j,k)*rdx(i,j)*dt/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+1,j,&
&k+1)-pk3(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k)))
      adu(i,j,k) = adu(i,j,k)*rdx(i,j)
      adgz(i+1,j,k+1) = adgz(i+1,j,k+1)-adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))
      adgz(i,j,k+1) = adgz(i,j,k+1)+adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))
      adgz(i+1,j,k) = adgz(i+1,j,k)-adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i+1,j,k+1)-pkc(i,j,k))
      adgz(i,j,k) = adgz(i,j,k)+adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(pkc(i,j,k+1)-pkc(i+1,j,k))
      adpkc(i+1,j,k+1) = adpkc(i+1,j,k+1)+adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adpkc(i,j,k+1) = adpkc(i,j,k+1)+adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpkc(i+1,j,k) = adpkc(i+1,j,k)-adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k)-gz(i+1,j,k+1))
      adpkc(i,j,k) = adpkc(i,j,k)-adu(i,j,k)*dt/(wk1(i,j)+wk1(i+1,j))*(gz(i,j,k+1)-gz(i+1,j,k))
      adwk1(i+1,j) = adwk1(i+1,j)-adu(i,j,k)*dt/((wk1(i,j)+wk1(i+1,j))*(wk1(i,j)+wk1(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,&
&j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      adwk1(i,j) = adwk1(i,j)-adu(i,j,k)*dt/((wk1(i,j)+wk1(i+1,j))*(wk1(i,j)+wk1(i+1,j)))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+&
&1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k)))
    end do
  end do
  do j = js, jep1
    do i = is, iep1
      adpk3(i,j,k+1) = adpk3(i,j,k+1)+adwk(i,j)
      adpk3(i,j,k) = adpk3(i,j,k)-adwk(i,j)
      adwk(i,j) = 0.
    end do
  end do
  if (a2b_ord .eq. 4) then
    call ada2b_ord4( addelp(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng )
  else
    call ada2b_ord2( addelp(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng )
  endif
end do
do k = npz+1, 1, -1
  if (a2b_ord .eq. 4) then
    call ada2b_ord4( adgz(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call ada2b_ord2( adgz(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
  endif
  if (k .ne. 1) then
    if (a2b_ord .eq. 4) then
      call ada2b_ord4( adpk3(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
      call ada2b_ord4( adpkc(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
    else
      call ada2b_ord2( adpk3(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
      call ada2b_ord2( adpkc(isd,jsd,k),adwk1,npx,npy,is,ie,js,je,ng, .true.  )
    endif
  endif
end do
do j = js, jep1
  do i = is, iep1
    adpk3(i,j,1) = 0.
    adpkc(i,j,1) = 0.
  end do
end do

end subroutine adtwo_grad_p


subroutine mdadv_pe( ua, va, pem, om, npx, npy, npz, ng, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adadv_pe_store, only : tp_advpe_adv_pe,tp_advpe_grad_25h,tp_advpe_v3_24h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: npz
real, intent(inout) :: om(isd:ied,jsd:jed,npz)
real, intent(in) :: pem(is-1:ie+1,1:npz+1,js-1:je+1)
integer :: taf_rec
real, intent(in) :: ua(isd:ied,jsd:jed,npz)
real, intent(in) :: va(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: grad(3,is:ie,js:je)
integer :: i
integer :: j
integer :: k
integer :: n
real :: pb(isd:ied,jsd:jed)
real :: pdx(3,is:ie,js:je+1)
real :: pdy(3,is:ie+1,js:je)
real :: pin(isd:ied,jsd:jed)
real :: ut(is:ie,js:je)
real :: v3(3,is:ie,js:je)
real :: vt(is:ie,js:je)

!**********************************************
! executable statements of routine
!**********************************************
do k = 1, npz
  if (k .eq. npz) then
    do j = js, je
      do i = is, ie
        ut(i,j) = ua(i,j,npz)
        vt(i,j) = va(i,j,npz)
      end do
    end do
  else
    do j = js, je
      do i = is, ie
        ut(i,j) = 0.5*(ua(i,j,k)+ua(i,j,k+1))
        vt(i,j) = 0.5*(va(i,j,k)+va(i,j,k+1))
      end do
    end do
  endif
  do j = js, je
    do i = is, ie
      do n = 1, 3
        v3(n,i,j) = ut(i,j)*ec1(n,i,j)+vt(i,j)*ec2(n,i,j)
      end do
    end do
  end do
  do j = js-1, je+1
    do i = is-1, ie+1
      pin(i,j) = pem(i,k+1,j)
    end do
  end do
  call a2b_ord2( pin,pb,npx,npy,is,ie,js,je,ng )
  do j = js, je+1
    do i = is, ie
      do n = 1, 3
        pdx(n,i,j) = (pb(i,j)+pb(i+1,j))*dx(i,j)*en1(n,i,j)
      end do
    end do
  end do
  do j = js, je
    do i = is, ie+1
      do n = 1, 3
        pdy(n,i,j) = (pb(i,j)+pb(i,j+1))*dy(i,j)*en2(n,i,j)
      end do
    end do
  end do
  do j = js, je
    do i = is, ie
      do n = 1, 3
        grad(n,i,j) = pdx(n,i,j+1)-pdx(n,i,j)-pdy(n,i,j)+pdy(n,i+1,j)
      end do
    end do
  end do
  if ( .not. allocated(tp_advpe_v3_24h)) then
    allocate( tp_advpe_v3_24h(1:3,is:ie,js:je,tp_advpe_adv_pe) )
  endif
  tp_advpe_v3_24h(:,:,:,(taf_rec-1)*npz+k) = v3
  if ( .not. allocated(tp_advpe_grad_25h)) then
    allocate( tp_advpe_grad_25h(1:3,is:ie,js:je,tp_advpe_adv_pe) )
  endif
  tp_advpe_grad_25h(:,:,:,(taf_rec-1)*npz+k) = grad
  do j = js, je
    do i = is, ie
      om(i,j,k) = om(i,j,k)+0.5*rarea(i,j)*(v3(1,i,j)*grad(1,i,j)+v3(2,i,j)*grad(2,i,j)+v3(3,i,j)*grad(3,i,j))
    end do
  end do
end do
end subroutine mdadv_pe


subroutine mddyn_core( npx, npy, npz, ng, bdt, n_split, cp, akap, grav, hydrostatic, u, v, w, delz, pt, delp, pe, pk, phis, omga, &
&ptop, pfull, ua, va, uc, vc, mfx, mfy, cx, cy, pem, delzc, peln, uniform_ppm, time_total )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use nh_core_mod, only : riem_solver, riem_solver_c, update_dz_c, update_dz_d
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use fv_my_mpp, only : mpp_get_boundary_dummy, mpp_update_domains_dummy
use fv_my_mpp, only : mpp_update_domains_cgrid, mpp_update_domains_dgrid
use fv_my_mpp, only : mpp_get_boundary_dgrid
use addyn_core_store, only : tp2d_dyn_core_delpc_6h,tp2d_dyn_core_dyn_core,tp_dyn_core_crx_33h,tp_dyn_core_cry_34h,&
&tp_dyn_core_delp_31h,tp_dyn_core_delp_41h,tp_dyn_core_delpc_15h,tp_dyn_core_delpc_18h,tp_dyn_core_delpc_37h,tp_dyn_core_dyn_core,&
&tp_dyn_core_gz_25h,tp_dyn_core_gz_42h,tp_dyn_core_last_step_11h,tp_dyn_core_omga_17h,tp_dyn_core_pe_45h,tp_dyn_core_peln_38h,&
&tp_dyn_core_pk_44h,tp_dyn_core_pkc_24h,tp_dyn_core_pkc_43h,tp_dyn_core_pt_30h,tp_dyn_core_pt_40h,tp_dyn_core_ptc_16h,&
&tp_dyn_core_ptc_19h,tp_dyn_core_ptc_28h,tp_dyn_core_vt_27h,tp_dyn_core_w_39h,tp_dyn_core_xfx_35h,tp_dyn_core_yfx_36h,&
&tp_dyn_core_zh_20h,tp_dyn_core_zh_32h
use adsw_core_mod, only : mdc_sw, mdd_sw

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: akap
real, intent(in) :: bdt
real, intent(in) :: cp
integer, intent(in) :: npz
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
real, intent(inout) :: delzc(is:ie,js:je,npz)
real, intent(in) :: grav
logical, intent(in) :: hydrostatic
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: pem(is-1:ie+1,npz+1,js-1:je+1)
real, intent(in) :: pfull(npz)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(in) :: ptop
real,optional, intent(in) :: time_total
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
logical, intent(in) :: uniform_ppm
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
real :: crx(is:ie+1,jsd:jed,npz)
real :: cry(isd:ied,js:je+1,npz)
real :: d_divg
real :: delpc(isd:ied,jsd:jed,npz)
real :: divg2(is:ie+1,js:je+1)
real :: divg_d(isd:ied+1,jsd:jed+1,npz)
logical :: do_omega
logical :: dord4
real :: dt
real :: dt2
real :: gz(isd:ied,jsd:jed,npz+1)
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: help_r
integer :: help_s
integer :: help_t
integer :: help_u
integer :: hord_m
integer :: hord_t
integer :: hord_v
integer :: i
integer :: ieb1
integer :: iep1
integer :: ism1
integer :: it
integer :: j
integer :: jeb1
integer :: jep1
integer :: jsm1
integer :: k
logical :: last_step
real :: pk3(isd:ied,jsd:jed,npz+1)
real :: pkc(isd:ied,jsd:jed,npz+1)
real :: ptc(isd:ied,jsd:jed,npz)
real :: ptk
real :: rdt
real :: rgrav
integer :: taf_rec_npz
real :: ut(isd:ied,jsd:jed,npz)
real :: vt(isd:ied,jsd:jed,npz)
real :: wk(isd:ied,jsd:jed)
real :: xfx(is:ie+1,jsd:jed,npz)
real :: yfx(isd:ied,js:je+1,npz)
real :: zh(isd:ied,jsd:jed,npz)

!==============================================
! declare data
!==============================================

!**********************************************
! executable statements of routine
!**********************************************
vt = 0.
divg_d = 0.
ptk = ptop**akap
if (dddm4 .gt. 0.) then
  dord4 =  .true. 
else
  dord4 =  .false. 
endif
if (npz .gt. 1) then
  call mpp_update_domains_dummy( pt,is,ie,js,je,isd,ied,jsd,jed,npz )
endif
call mpp_update_domains_dummy( delp,is,ie,js,je,isd,ied,jsd,jed,npz )
dt = bdt/real(n_split)
dt2 = 0.5*dt
rdt = 1./dt
rgrav = 1./grav
ism1 = is-1
iep1 = ie+1
jsm1 = js-1
jep1 = je+1
do it = 1, n_split
  if ( .not. hydrostatic) then
    do j = js, je
      do i = is, ie
        zh(i,j,npz) = phis(i,j)*rgrav-delz(i,j,npz)
      end do
      do k = npz-1, 1, -1
        do i = is, ie
          zh(i,j,k) = zh(i,j,k+1)-delz(i,j,k)
        end do
      end do
    end do
    call mpp_update_domains_dummy( zh,is,ie,js,je,isd,ied,jsd,jed,npz )
    call mpp_update_domains_dummy( w,is,ie,js,je,isd,ied,jsd,jed,npz )
  endif
  if (it .eq. n_split) then
    do j = jsm1, jep1
      do i = ism1, iep1
        pem(i,1,j) = ptop
      end do
      do k = 1, npz
        do i = ism1, iep1
          pem(i,k+1,j) = pem(i,k,j)+delp(i,j,k)
        end do
      end do
    end do
    do_omega =  .true. 
  else
    do_omega =  .false. 
  endif
  if (it .eq. n_split) then
    last_step =  .true. 
  else
    last_step =  .false. 
  endif
  tp_dyn_core_last_step_11h(it) = last_step
  do k = 1, npz
    taf_rec_npz = (it-1)*npz+k
    call mdc_sw( delpc(isd,jsd,k),delp(isd,jsd,k),ptc(isd,jsd,k),pt(isd,jsd,k),u(isd,jsd,k),v(isd,jsd,k),w(isd,jsd,k),uc(isd,jsd,k)&
&,vc(isd,jsd,k),ua(isd,jsd,k),va(isd,jsd,k),omga(isd,jsd,k),ut(isd,jsd,k),vt(isd,jsd,k),dt2,hydrostatic,dord4,taf_rec_npz )
  end do
  if (hydrostatic) then
    if ( .not. allocated(tp_dyn_core_delpc_15h)) then
      allocate( tp_dyn_core_delpc_15h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_delpc_15h(:,:,:,it) = delpc
    if ( .not. allocated(tp_dyn_core_ptc_16h)) then
      allocate( tp_dyn_core_ptc_16h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_ptc_16h(:,:,:,it) = ptc
    call geopk( ptop,pe,peln,delpc,pkc,gz,phis,ptc,npz,akap, .false. , .false. , .true.  )
  else
    if ( .not. allocated(tp_dyn_core_omga_17h)) then
      allocate( tp_dyn_core_omga_17h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_omga_17h(:,:,:,it) = omga
    if ( .not. allocated(tp_dyn_core_delpc_18h)) then
      allocate( tp_dyn_core_delpc_18h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_delpc_18h(:,:,:,it) = delpc
    if ( .not. allocated(tp_dyn_core_ptc_19h)) then
      allocate( tp_dyn_core_ptc_19h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_ptc_19h(:,:,:,it) = ptc
    if ( .not. allocated(tp_dyn_core_zh_20h)) then
      allocate( tp_dyn_core_zh_20h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_zh_20h(:,:,:,it) = zh
    call update_dz_c( is,ie,js,je,npz,ng,area,zh,ut,vt,delz,delzc,gz )
    call riem_solver_c( dt2,is,ie,js,je,npz,ng,akap,cp,ptop,phis,omga,delzc,ptc,delpc,gz,pkc,1 )
    help_h = npz+1
    call mpp_update_domains_dummy( pkc,is,ie,js,je,isd,ied,jsd,jed,help_h )
    help_i = npz+1
    call mpp_update_domains_dummy( gz,is,ie,js,je,isd,ied,jsd,jed,help_i )
  endif
  if ( .not. allocated(tp_dyn_core_pkc_24h)) then
    allocate( tp_dyn_core_pkc_24h(isd:ied,jsd:jed,1:npz+1,tp_dyn_core_dyn_core) )
  endif
  tp_dyn_core_pkc_24h(:,:,:,it) = pkc
  if ( .not. allocated(tp_dyn_core_gz_25h)) then
    allocate( tp_dyn_core_gz_25h(isd:ied,jsd:jed,1:npz+1,tp_dyn_core_dyn_core) )
  endif
  tp_dyn_core_gz_25h(:,:,:,it) = gz
  ieb1 = ie+1
  jeb1 = je+1
  do k = 1, npz
    if ( .not. allocated(tp2d_dyn_core_delpc_6h)) then
      allocate( tp2d_dyn_core_delpc_6h(isd:ied,jsd:jed,tp2d_dyn_core_dyn_core) )
    endif
    tp2d_dyn_core_delpc_6h(:,:,(it-1)*npz+k) = delpc(:,:,k)
    if (hydrostatic) then
      do j = jsm1, jeb1
        do i = ism1, ieb1
          wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
        end do
      end do
    else
      do j = jsd, jed
        do i = isd, ied
          wk(i,j) = delpc(i,j,k)
          delpc(i,j,k) = delp(i,j,k)
        end do
      end do
    endif
    do j = js, je
      do i = is, ieb1
        uc(i,j,k) = uc(i,j,k)+dt2*rdxc(i,j)/(wk(i-1,j)+wk(i,j))*((gz(i-1,j,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(gz(i-1,j,k)&
&-gz(i,j,k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))
      end do
    end do
    do j = js, jeb1
      do i = is, ie
        vc(i,j,k) = vc(i,j,k)+dt2*rdyc(i,j)/(wk(i,j-1)+wk(i,j))*((gz(i,j-1,k+1)-gz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(gz(i,j-1,k)&
&-gz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      end do
    end do
  end do
  help_j = jed+1
  help_k = ied+1
  call mpp_update_domains_cgrid( vc,uc,is,ie,js,je,isd,ied,jsd,help_j,npz,is,ie,js,je,isd,help_k,jsd,jed,npz )
  if (dord4) then
    call divergence_corner( u,v,ua,va,divg_d,npz )
    if (grid_type .ne. 4) then
      call mpp_update_domains_dummy( divg_d,is,ie,js,je,isd,ied,jsd,jed,npz )
    endif
  endif
  do k = 1, npz
    hord_m = hord_mt
    hord_t = hord_tm
    hord_v = hord_vt
    if (n_sponge .eq. (-1) .or. npz .eq. 1) then
      d_divg = dddmp
    else
      if (k .le. n_sponge .and. npz .gt. 16) then
        hord_v = 1
        hord_t = 1
        d_divg = min(0.24,6.*dddmp)
        d_divg = max(0.02,d_divg)
      else if (k .eq. n_sponge+1 .and. npz .gt. 16) then
        d_divg = min(0.24,4.*dddmp)
        d_divg = max(0.01,d_divg)
      else
        d_divg = min(0.24,dddmp*(1.-3.*tanh(0.1*log(pfull(k)/pfull(npz)))))
      endif
    endif
    if (d_ext .gt. 0.) then
      call a2b_ord2( delp(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng, .false.  )
    endif
    taf_rec_npz = (it-1)*npz+k
         call timing_on('adm_dsw')
    call mdd_sw( vt(isd,jsd,k),delp(isd,jsd,k),ptc(isd,jsd,k),pt(isd,jsd,k),u(isd,jsd,k),v(isd,jsd,k),w(isd,jsd,k),uc(isd,jsd,k),&
&vc(isd,jsd,k),ua(isd,jsd,k),va(isd,jsd,k),divg_d(isd,jsd,k),mfx(is,js,k),mfy(is,js,k),cx(is,jsd,k),cy(isd,js,k),crx(is,jsd,k),&
&cry(isd,js,k),xfx(is,jsd,k),yfx(isd,js,k),dt,hord_m,hord_v,hord_t,d_divg,dddm4,hydrostatic,uniform_ppm,taf_rec_npz )
         call timing_off('adm_dsw')
    if (d_ext .gt. 0.) then
      do j = js, jep1
        do i = is, iep1
          ptc(i,j,k) = wk(i,j)
        end do
      end do
    endif
  end do
  if ( .not. allocated(tp_dyn_core_vt_27h)) then
    allocate( tp_dyn_core_vt_27h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
  endif
  tp_dyn_core_vt_27h(:,:,:,it) = vt
  if ( .not. allocated(tp_dyn_core_ptc_28h)) then
    allocate( tp_dyn_core_ptc_28h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
  endif
  tp_dyn_core_ptc_28h(:,:,:,it) = ptc
  if (d_ext .gt. 0.) then
    d_divg = d_ext*da_min_c
    do j = js, jep1
      do i = is, iep1
        wk(i,j) = ptc(i,j,1)
        divg2(i,j) = wk(i,j)*vt(i,j,1)
      end do
      do k = 2, npz
        do i = is, iep1
          wk(i,j) = wk(i,j)+ptc(i,j,k)
          divg2(i,j) = divg2(i,j)+ptc(i,j,k)*vt(i,j,k)
        end do
      end do
      do i = is, iep1
        divg2(i,j) = d_divg*divg2(i,j)/wk(i,j)
      end do
    end do
  else
    divg2 = 0.
    vt = 0.
  endif
  call mpp_update_domains_dummy( pt,is,ie,js,je,isd,ied,jsd,jed,npz )
  call mpp_update_domains_dummy( delp,is,ie,js,je,isd,ied,jsd,jed,npz )
  if (hydrostatic) then
    if ( .not. allocated(tp_dyn_core_pt_30h)) then
      allocate( tp_dyn_core_pt_30h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_pt_30h(:,:,:,it) = pt
    if ( .not. allocated(tp_dyn_core_delp_31h)) then
      allocate( tp_dyn_core_delp_31h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_delp_31h(:,:,:,it) = delp
    call geopk( ptop,pe,peln,delp,pkc,gz,phis,pt,npz,akap,last_step, .false. , .false.  )
  else
    if ( .not. allocated(tp_dyn_core_zh_32h)) then
      allocate( tp_dyn_core_zh_32h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_zh_32h(:,:,:,it) = zh
    if ( .not. allocated(tp_dyn_core_crx_33h)) then
      allocate( tp_dyn_core_crx_33h(is:ie+1,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_crx_33h(:,:,:,it) = crx
    if ( .not. allocated(tp_dyn_core_cry_34h)) then
      allocate( tp_dyn_core_cry_34h(isd:ied,js:je+1,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_cry_34h(:,:,:,it) = cry
    if ( .not. allocated(tp_dyn_core_xfx_35h)) then
      allocate( tp_dyn_core_xfx_35h(is:ie+1,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_xfx_35h(:,:,:,it) = xfx
    if ( .not. allocated(tp_dyn_core_yfx_36h)) then
      allocate( tp_dyn_core_yfx_36h(isd:ied,js:je+1,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_yfx_36h(:,:,:,it) = yfx
    if ( .not. allocated(tp_dyn_core_delpc_37h)) then
      allocate( tp_dyn_core_delpc_37h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_delpc_37h(:,:,:,it) = delpc
    call update_dz_d( hord_tm,is,ie,js,je,npz,ng,npx,npy,area,zh,crx,cry,xfx,yfx,delz,delzc,delpc,n_sponge )
    if ( .not. allocated(tp_dyn_core_peln_38h)) then
      allocate( tp_dyn_core_peln_38h(is:ie,1:npz+1,js:je,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_peln_38h(:,:,:,it) = peln
    if ( .not. allocated(tp_dyn_core_w_39h)) then
      allocate( tp_dyn_core_w_39h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_w_39h(:,:,:,it) = w
    if ( .not. allocated(tp_dyn_core_pt_40h)) then
      allocate( tp_dyn_core_pt_40h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_pt_40h(:,:,:,it) = pt
    if ( .not. allocated(tp_dyn_core_delp_41h)) then
      allocate( tp_dyn_core_delp_41h(isd:ied,jsd:jed,1:npz,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_delp_41h(:,:,:,it) = delp
    if ( .not. allocated(tp_dyn_core_gz_42h)) then
      allocate( tp_dyn_core_gz_42h(isd:ied,jsd:jed,1:npz+1,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_gz_42h(:,:,:,it) = gz
    if ( .not. allocated(tp_dyn_core_pkc_43h)) then
      allocate( tp_dyn_core_pkc_43h(isd:ied,jsd:jed,1:npz+1,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_pkc_43h(:,:,:,it) = pkc
    if ( .not. allocated(tp_dyn_core_pk_44h)) then
      allocate( tp_dyn_core_pk_44h(is:ie,js:je,1:npz+1,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_pk_44h(:,:,:,it) = pk
    if ( .not. allocated(tp_dyn_core_pe_45h)) then
      allocate( tp_dyn_core_pe_45h(is-1:ie+1,1:npz+1,js-1:je+1,tp_dyn_core_dyn_core) )
    endif
    tp_dyn_core_pe_45h(:,:,:,it) = pe
    call riem_solver( dt,is,ie,js,je,npz,ng,akap,cp,ptop,phis,peln,w,delz,pt,delp,gz,pkc,pk,pe,last_step,m_grad_p )
    if (m_grad_p .eq. 0) then
      do k = 1, npz+1
        do j = js, je
          do i = is, ie
            pk3(i,j,k) = pk(i,j,k)
          end do
        end do
      end do
    endif
    if (a2b_ord .eq. 4) then
      help_n = npz+1
      call mpp_update_domains_dummy( pkc,is,ie,js,je,isd,ied,jsd,jed,help_n )
      help_o = npz+1
      call mpp_update_domains_dummy( gz,is,ie,js,je,isd,ied,jsd,jed,help_o )
    else
      help_p = npz+1
      call mpp_update_domains_dummy( pkc,is,ie,js,je,isd,ied,jsd,jed,help_p )
      help_q = npz+1
      call mpp_update_domains_dummy( gz,is,ie,js,je,isd,ied,jsd,jed,help_q )
    endif
  endif
  if (last_step .and. hydrostatic) then
    do k = 1, npz+1
      do j = js, je
        do i = is, ie
          pk(i,j,k) = pkc(i,j,k)
        end do
      end do
    end do
  endif
  if (do_omega) then
    do k = 1, npz
      do j = js, je
        do i = is, ie
          omga(i,j,k) = (pe(i,k+1,j)-pem(i,k+1,j))*rdt
        end do
      end do
    end do
    call mdadv_pe( ua,va,pem,omga,npx,npy,npz,ng,it )
  endif
  if (( .not. hydrostatic) .and. m_grad_p .eq. 0) then
    call mdtwo_grad_p( u,v,pkc,gz,delp,pk3,divg2,dt,ng,npx,npy,npz,ptk,it )
  else
    call mdone_grad_p( u,v,pkc,gz,divg2,delp,dt,ng,npx,npy,npz,ptop,ptk,hydrostatic,it )
  endif
  help_r = jed+1
  help_s = ied+1
  call mpp_update_domains_dgrid( u,v,is,ie,js,je,isd,ied,jsd,help_r,npz,is,ie,js,je,isd,help_s,jsd,jed,npz )
  if (last_step .and. grid_type .lt. 4) then
    help_t = jed+1
    help_u = ied+1
    call mpp_get_boundary_dgrid( u,v,is,ie,js,je,isd,ied,jsd,help_t,npz,is,ie,js,je,isd,help_u,jsd,jed,npz,npx,npy,npz,is,ie,js,je )
  endif
end do
end subroutine mddyn_core


subroutine mdone_grad_p( u, v, pkc, gz, divg2, delp, dt, ng, npx, npy, npz, ptop, ptk, hydrostatic, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adone_grad_p_store, only : tp_one_gradb_gz_12h,tp_one_gradb_gz_13h,tp_one_gradb_gz_19h,tp_one_gradb_gz_20h,&
&tp_one_gradb_one_grad_p,tp_one_gradb_pkc_14h,tp_one_gradb_pkc_15h,tp_one_gradb_pkc_21h,tp_one_gradb_pkc_22h,tp_one_gradb_wk_11h,&
&tp_one_gradb_wk_18h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(in) :: divg2(is:ie+1,js:je+1)
real, intent(in) :: dt
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
logical, intent(in) :: hydrostatic
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
real, intent(in) :: ptk
real, intent(in) :: ptop
integer :: taf_rec
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: top_value
real :: wk(isd:ied,jsd:jed)

!**********************************************
! executable statements of routine
!**********************************************
iep1 = ie+1
jep1 = je+1
if (hydrostatic) then
  top_value = ptk
else
  top_value = ptop
endif
do j = js, jep1
  do i = is, iep1
    pkc(i,j,1) = top_value
  end do
end do
do k = 2, npz+1
  if (a2b_ord .eq. 4) then
    call a2b_ord4( pkc(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call a2b_ord2( pkc(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz+1
  if (a2b_ord .eq. 4) then
    call a2b_ord4( gz(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call a2b_ord2( gz(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz
  if (hydrostatic) then
    do j = js, jep1
      do i = is, iep1
        wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
      end do
    end do
  else
    if (a2b_ord .eq. 4) then
      call a2b_ord4( delp(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng )
    else
      call a2b_ord2( delp(isd,jsd,k),wk,npx,npy,is,ie,js,je,ng )
    endif
  endif
  if ( .not. allocated(tp_one_gradb_wk_11h)) then
    allocate( tp_one_gradb_wk_11h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_wk_11h(:,:,(taf_rec-1)*npz+k) = wk
  if ( .not. allocated(tp_one_gradb_gz_12h)) then
    allocate( tp_one_gradb_gz_12h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_gz_12h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k)
  if ( .not. allocated(tp_one_gradb_gz_13h)) then
    allocate( tp_one_gradb_gz_13h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_gz_13h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k+1)
  if ( .not. allocated(tp_one_gradb_pkc_14h)) then
    allocate( tp_one_gradb_pkc_14h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_pkc_14h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k)
  if ( .not. allocated(tp_one_gradb_pkc_15h)) then
    allocate( tp_one_gradb_pkc_15h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_pkc_15h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k+1)
  do j = js, jep1
    do i = is, ie
      u(i,j,k) = rdx(i,j)*(divg2(i,j)-divg2(i+1,j)+u(i,j,k)+dt/(wk(i,j)+wk(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-&
&pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pkc(i,j,k+1)-pkc(i+1,j,k))))
    end do
  end do
  if ( .not. allocated(tp_one_gradb_wk_18h)) then
    allocate( tp_one_gradb_wk_18h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_wk_18h(:,:,(taf_rec-1)*npz+k) = wk
  if ( .not. allocated(tp_one_gradb_gz_19h)) then
    allocate( tp_one_gradb_gz_19h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_gz_19h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k)
  if ( .not. allocated(tp_one_gradb_gz_20h)) then
    allocate( tp_one_gradb_gz_20h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_gz_20h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k+1)
  if ( .not. allocated(tp_one_gradb_pkc_21h)) then
    allocate( tp_one_gradb_pkc_21h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_pkc_21h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k)
  if ( .not. allocated(tp_one_gradb_pkc_22h)) then
    allocate( tp_one_gradb_pkc_22h(isd:ied,jsd:jed,tp_one_gradb_one_grad_p) )
  endif
  tp_one_gradb_pkc_22h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k+1)
  do j = js, je
    do i = is, iep1
      v(i,j,k) = rdy(i,j)*(divg2(i,j)-divg2(i,j+1)+v(i,j,k)+dt/(wk(i,j)+wk(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-&
&pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pkc(i,j,k+1)-pkc(i,j+1,k))))
    end do
  end do
end do
end subroutine mdone_grad_p


subroutine mdtwo_grad_p( u, v, pkc, gz, delp, pk3, divg2, dt, ng, npx, npy, npz, ptk, taf_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.50  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mpp_domains_mod, only : cgrid_ne,dgrid_ne,mpp_get_boundary, mpp_update_domains
use fv_mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use fv_control_mod, only : a2b_ord,d_ext,dddm4,dddmp,hord_mt,hord_tm,hord_vt,hord_ze,m_grad_p,master,n_sponge
use sw_core_mod, only : c_sw, d_sw, divergence_corner
use a2b_edge_mod, only : a2b_ord2, a2b_ord4
use fv_grid_tools_mod, only : area,dx,dxc,dy,dyc,grid_type,rarea,rdx,rdxc,rdy,rdyc
use fv_grid_utils_mod, only : da_min_c,ec1,ec2,edge_vect_e,edge_vect_n,edge_vect_s,edge_vect_w,en1,en2
use fv_timing_mod, only : timing_off, timing_on
use mpp_parameter_mod, only : corner
use adtwo_grad_p_store, only : tp_two_gradb_gz_12h,tp_two_gradb_gz_20h,tp_two_gradb_pk3_14h,tp_two_gradb_pk3_22h,&
&tp_two_gradb_pk3_5h,tp_two_gradb_pkc_13h,tp_two_gradb_pkc_21h,tp_two_gradb_two_grad_p,tp_two_gradb_wk1_10h,tp_two_gradb_wk1_18h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(in) :: divg2(is:ie+1,js:je+1)
real, intent(in) :: dt
real, intent(inout) :: gz(isd:ied,jsd:jed,npz+1)
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: pk3(isd:ied,jsd:jed,npz+1)
real, intent(inout) :: pkc(isd:ied,jsd:jed,npz+1)
real, intent(in) :: ptk
integer :: taf_rec
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: iep1
integer :: j
integer :: jep1
integer :: k
real :: wk(is:ie+1,js:je+1)
real :: wk1(isd:ied,jsd:jed)

!**********************************************
! executable statements of routine
!**********************************************
iep1 = ie+1
jep1 = je+1
do j = js, jep1
  do i = is, iep1
    pkc(i,j,1) = 0.
    pk3(i,j,1) = ptk
  end do
end do
do k = 1, npz+1
  if (k .ne. 1) then
    if (a2b_ord .eq. 4) then
      call a2b_ord4( pkc(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
      call a2b_ord4( pk3(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
    else
      call a2b_ord2( pkc(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
      call a2b_ord2( pk3(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
    endif
  endif
  if (a2b_ord .eq. 4) then
    call a2b_ord4( gz(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
  else
    call a2b_ord2( gz(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng, .true.  )
  endif
end do
do k = 1, npz
  if (a2b_ord .eq. 4) then
    call a2b_ord4( delp(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng )
  else
    call a2b_ord2( delp(isd,jsd,k),wk1,npx,npy,is,ie,js,je,ng )
  endif
  if ( .not. allocated(tp_two_gradb_pk3_5h)) then
    allocate( tp_two_gradb_pk3_5h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_pk3_5h(:,:,(taf_rec-1)*npz+k) = pk3(:,:,k)
  do j = js, jep1
    do i = is, iep1
      wk(i,j) = pk3(i,j,k+1)-pk3(i,j,k)
    end do
  end do
  if ( .not. allocated(tp_two_gradb_wk1_10h)) then
    allocate( tp_two_gradb_wk1_10h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_wk1_10h(:,:,(taf_rec-1)*npz+k) = wk1
  if ( .not. allocated(tp_two_gradb_gz_12h)) then
    allocate( tp_two_gradb_gz_12h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_gz_12h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k+1)
  if ( .not. allocated(tp_two_gradb_pkc_13h)) then
    allocate( tp_two_gradb_pkc_13h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_pkc_13h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k+1)
  if ( .not. allocated(tp_two_gradb_pk3_14h)) then
    allocate( tp_two_gradb_pk3_14h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_pk3_14h(:,:,(taf_rec-1)*npz+k) = pk3(:,:,k+1)
  do j = js, jep1
    do i = is, ie
      u(i,j,k) = u(i,j,k)+dt/(wk1(i,j)+wk1(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pkc(i+1,j,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))&
&*(pkc(i,j,k+1)-pkc(i+1,j,k)))
      u(i,j,k) = rdx(i,j)*(divg2(i,j)-divg2(i+1,j)+u(i,j,k)+dt/(wk(i,j)+wk(i+1,j))*((gz(i,j,k+1)-gz(i+1,j,k))*(pk3(i+1,j,k+1)-&
&pk3(i,j,k))+(gz(i,j,k)-gz(i+1,j,k+1))*(pk3(i,j,k+1)-pk3(i+1,j,k))))
    end do
  end do
  if ( .not. allocated(tp_two_gradb_wk1_18h)) then
    allocate( tp_two_gradb_wk1_18h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_wk1_18h(:,:,(taf_rec-1)*npz+k) = wk1
  if ( .not. allocated(tp_two_gradb_gz_20h)) then
    allocate( tp_two_gradb_gz_20h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_gz_20h(:,:,(taf_rec-1)*npz+k) = gz(:,:,k+1)
  if ( .not. allocated(tp_two_gradb_pkc_21h)) then
    allocate( tp_two_gradb_pkc_21h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_pkc_21h(:,:,(taf_rec-1)*npz+k) = pkc(:,:,k+1)
  if ( .not. allocated(tp_two_gradb_pk3_22h)) then
    allocate( tp_two_gradb_pk3_22h(isd:ied,jsd:jed,tp_two_gradb_two_grad_p) )
  endif
  tp_two_gradb_pk3_22h(:,:,(taf_rec-1)*npz+k) = pk3(:,:,k+1)
  do j = js, je
    do i = is, iep1
      v(i,j,k) = v(i,j,k)+dt/(wk1(i,j)+wk1(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pkc(i,j+1,k+1)-pkc(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))&
&*(pkc(i,j,k+1)-pkc(i,j+1,k)))
      v(i,j,k) = rdy(i,j)*(divg2(i,j)-divg2(i,j+1)+v(i,j,k)+dt/(wk(i,j)+wk(i,j+1))*((gz(i,j,k+1)-gz(i,j+1,k))*(pk3(i,j+1,k+1)-&
&pk3(i,j,k))+(gz(i,j,k)-gz(i,j+1,k+1))*(pk3(i,j,k+1)-pk3(i,j+1,k))))
    end do
  end do
end do
end subroutine mdtwo_grad_p


end module     addyn_core_mod


