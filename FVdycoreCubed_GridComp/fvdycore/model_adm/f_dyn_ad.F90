!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine adf_dyn( npx, npy, npz, nq, ng, bdt, consv_te, fill, reproduce_sum, kappa, cp_air, zvir, ks, ncnst, n_split, q_split, u,&
& adu, v, adv, w, adw, delz, addelz, hydrostatic, pt, adpt, delp, addelp, q, adq, pe, adpe, pk, peln, pkz, adpkz, phis, omga, ua, &
&adua, va, adva, uc, vc, ak, bk, mfx, mfy, cx, cy, ze0, adze0, hybrid_z, y_u, ady_u, y_v, ady_v, y_pt, ady_pt, y_delp, ady_delp, &
&y_q, ady_q )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_dynamics_mod, only : fv_dynamics
use mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
use adfv_dynamics_mod, only : adfv_dynamics, mdfv_dynamics

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: addelp(isd:ied,jsd:jed,npz)
real, intent(inout) :: addelz(is:ie,js:je,npz)
real, intent(inout) :: adpe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: adpkz(is:ie,js:je,npz)
real, intent(inout) :: adpt(isd:ied,jsd:jed,npz)
integer, intent(in) :: ncnst
real, intent(inout) :: adq(isd:ied,jsd:jed,npz,ncnst)
real, intent(inout) :: adu(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: adua(isd:ied,jsd:jed,npz)
real, intent(inout) :: adv(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adva(isd:ied,jsd:jed,npz)
real, intent(inout) :: adw(isd:ied,jsd:jed,npz)
real, intent(inout) :: ady_delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: ady_pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: ady_q(isd:ied,jsd:jed,npz,ncnst)
real, intent(inout) :: ady_u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ady_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: adze0(is:ie,js:je,npz+1)
real, intent(in) :: ak(npz+1)
real, intent(in) :: bdt
real, intent(in) :: bk(npz+1)
real, intent(in) :: consv_te
real, intent(in) :: cp_air
real, intent(inout) :: cx(is:ie+1,jsd:jed,npz)
real, intent(inout) :: cy(isd:ied,js:je+1,npz)
real, intent(inout) :: delp(isd:ied,jsd:jed,npz)
real, intent(inout) :: delz(is:ie,js:je,npz)
logical, intent(in) :: fill
logical, intent(in) :: hybrid_z
logical, intent(in) :: hydrostatic
real, intent(in) :: kappa
integer, intent(in) :: ks
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: n_split
integer, intent(in) :: ng
integer, intent(in) :: npx
integer, intent(in) :: npy
integer, intent(in) :: nq
real, intent(inout) :: omga(isd:ied,jsd:jed,npz)
real, intent(inout) :: pe(is-1:ie+1,npz+1,js-1:je+1)
real, intent(inout) :: peln(is:ie,npz+1,js:je)
real, intent(inout) :: phis(isd:ied,jsd:jed)
real, intent(inout) :: pk(is:ie,js:je,npz+1)
real, intent(inout) :: pkz(is:ie,js:je,npz)
real, intent(inout) :: pt(isd:ied,jsd:jed,npz)
real, intent(inout) :: q(isd:ied,jsd:jed,npz,ncnst)
integer, intent(in) :: q_split
logical, intent(in) :: reproduce_sum
real, intent(inout) :: u(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: ua(isd:ied,jsd:jed,npz)
real, intent(inout) :: uc(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: va(isd:ied,jsd:jed,npz)
real, intent(inout) :: vc(isd:ied,jsd:jed+1,npz)
real, intent(inout) :: w(isd:ied,jsd:jed,npz)
real, intent(out) :: y_delp(isd:ied,jsd:jed,npz)
real, intent(out) :: y_pt(isd:ied,jsd:jed,npz)
real, intent(out) :: y_q(isd:ied,jsd:jed,npz,ncnst)
real, intent(out) :: y_u(isd:ied,jsd:jed+1,npz)
real, intent(out) :: y_v(isd:ied+1,jsd:jed,npz)
real, intent(inout) :: ze0(is:ie,js:je,npz+1)
real, intent(in) :: zvir

!==============================================
! declare local variables
!==============================================
real, allocatable :: adcxi(:,:,:)
real, allocatable :: adcyi(:,:,:)
real, allocatable :: admfxi(:,:,:)
real, allocatable :: admfyi(:,:,:)
real, allocatable :: adomgai(:,:,:)
real, allocatable :: adpki(:,:,:)
real :: delph(lbound(delp,1):ubound(delp,1),lbound(delp,2):ubound(delp,2),lbound(delp,3):ubound(delp,3))
real :: delzh(lbound(delz,1):ubound(delz,1),lbound(delz,2):ubound(delz,2),lbound(delz,3):ubound(delz,3))
real :: peh(lbound(pe,1):ubound(pe,1),lbound(pe,2):ubound(pe,2),lbound(pe,3):ubound(pe,3))
real :: pelnh(lbound(peln,1):ubound(peln,1),lbound(peln,2):ubound(peln,2),lbound(peln,3):ubound(peln,3))
real :: pkj(lbound(pk,1):ubound(pk,1),lbound(pk,2):ubound(pk,2),lbound(pk,3):ubound(pk,3))
real :: pkzh(lbound(pkz,1):ubound(pkz,1),lbound(pkz,2):ubound(pkz,2),lbound(pkz,3):ubound(pkz,3))
real :: ps(isd:ied,jsd:jed)
real :: pth(lbound(pt,1):ubound(pt,1),lbound(pt,2):ubound(pt,2),lbound(pt,3):ubound(pt,3))
real :: qh(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3),lbound(q,4):ubound(q,4))
logical :: srf_init
real :: time_total
real :: u_srf(is:ie,js:je)
real :: uah(lbound(ua,1):ubound(ua,1),lbound(ua,2):ubound(ua,2),lbound(ua,3):ubound(ua,3))
real :: uh(lbound(u,1):ubound(u,1),lbound(u,2):ubound(u,2),lbound(u,3):ubound(u,3))
real :: v_srf(is:ie,js:je)
real :: vah(lbound(va,1):ubound(va,1),lbound(va,2):ubound(va,2),lbound(va,3):ubound(va,3))
real :: vh(lbound(v,1):ubound(v,1),lbound(v,2):ubound(v,2),lbound(v,3):ubound(v,3))
real :: wh(lbound(w,1):ubound(w,1),lbound(w,2):ubound(w,2),lbound(w,3):ubound(w,3))

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
wh(:,:,:) = w(:,:,:)
vah(:,:,:) = va(:,:,:)
vh(:,:,:) = v(:,:,:)
uah(:,:,:) = ua(:,:,:)
uh(:,:,:) = u(:,:,:)
qh(:,:,:,:) = q(:,:,:,:)
pth(:,:,:) = pt(:,:,:)
pkzh(:,:,:) = pkz(:,:,:)
pkj(:,:,:) = pk(:,:,:)
pelnh(:,:,:) = peln(:,:,:)
peh(:,:,:) = pe(:,:,:)
delzh(:,:,:) = delz(:,:,:)
delph(:,:,:) = delp(:,:,:)

!----------------------------------------------
! RESET GLOBAL ADJOINT VARIABLES
!----------------------------------------------
!jkimcall adzero

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
!----------------------------------------------
! RESET TAPE memory SUBROUTINE COUNTER
!----------------------------------------------
call admzero( 1 )

!----------------------------------------------
! FUNCTION AND TAPE COMPUTATIONS
!----------------------------------------------
call mdfv_dynamics( npx,npy,npz,nq,ng,bdt,consv_te,fill,reproduce_sum,kappa,cp_air,zvir,ks,ncnst,n_split,q_split,u,v,w,delz,&
&hydrostatic,pt,delp,q,ps,pe,pk,peln,pkz,phis,omga,ua,va,uc,vc,ak,bk,mfx,mfy,cx,cy,u_srf,v_srf,srf_init,ze0,hybrid_z,time_total )
y_u(isd:ied,jsd:jed+1,npz) = u(isd:ied,jsd:jed+1,npz)
y_v(isd:ied+1,jsd:jed,npz) = v(isd:ied+1,jsd:jed,npz)
y_pt(isd:ied,jsd:jed,npz) = pt(isd:ied,jsd:jed,npz)
y_delp(isd:ied,jsd:jed,npz) = delp(isd:ied,jsd:jed,npz)
y_q(isd:ied,jsd:jed,npz,nq) = q(isd:ied,jsd:jed,npz,nq)

!----------------------------------------------
! ADJOINT COMPUTATIONS
!----------------------------------------------
delp(:,:,:) = delph(:,:,:)
delz(:,:,:) = delzh(:,:,:)
pe(:,:,:) = peh(:,:,:)
peln(:,:,:) = pelnh(:,:,:)
pk(:,:,:) = pkj(:,:,:)
pkz(:,:,:) = pkzh(:,:,:)
pt(:,:,:) = pth(:,:,:)
q(:,:,:,:) = qh(:,:,:,:)
u(:,:,:) = uh(:,:,:)
ua(:,:,:) = uah(:,:,:)
v(:,:,:) = vh(:,:,:)
va(:,:,:) = vah(:,:,:)
w(:,:,:) = wh(:,:,:)
adq(isd:ied,jsd:jed,npz,nq) = adq(isd:ied,jsd:jed,npz,nq)+ady_q(isd:ied,jsd:jed,npz,nq)
ady_q(isd:ied,jsd:jed,npz,nq) = 0.
addelp(isd:ied,jsd:jed,npz) = addelp(isd:ied,jsd:jed,npz)+ady_delp(isd:ied,jsd:jed,npz)
ady_delp(isd:ied,jsd:jed,npz) = 0.
adpt(isd:ied,jsd:jed,npz) = adpt(isd:ied,jsd:jed,npz)+ady_pt(isd:ied,jsd:jed,npz)
ady_pt(isd:ied,jsd:jed,npz) = 0.
adv(isd:ied+1,jsd:jed,npz) = adv(isd:ied+1,jsd:jed,npz)+ady_v(isd:ied+1,jsd:jed,npz)
ady_v(isd:ied+1,jsd:jed,npz) = 0.
adu(isd:ied,jsd:jed+1,npz) = adu(isd:ied,jsd:jed+1,npz)+ady_u(isd:ied,jsd:jed+1,npz)
ady_u(isd:ied,jsd:jed+1,npz) = 0.
allocate( adcyi(isd:ied,js:je+1,1:npz) )
adcyi(:,:,:) = 0.
allocate( adcxi(is:ie+1,jsd:jed,1:npz) )
adcxi(:,:,:) = 0.
allocate( admfyi(is:ie,js:je+1,1:npz) )
admfyi(:,:,:) = 0.
allocate( admfxi(is:ie+1,js:je,1:npz) )
admfxi(:,:,:) = 0.
allocate( adomgai(isd:ied,jsd:jed,1:npz) )
adomgai(:,:,:) = 0.
allocate( adpki(is:ie,js:je,1:npz+1) )
adpki(:,:,:) = 0.
call adfv_dynamics( npx,npy,npz,nq,ng,bdt,consv_te,fill,reproduce_sum,kappa,cp_air,zvir,ks,ncnst,n_split,q_split,u,adu,v,adv,w,adw,&
&delz,addelz,hydrostatic,pt,adpt,delp,addelp,q,adq,pe,adpe,pk,adpki,peln,pkz,adpkz,phis,omga,adomgai,ua,adua,va,adva,uc,vc,ak,bk,&
&mfx,admfxi,mfy,admfyi,cx,adcxi,cy,adcyi,ze0,adze0,hybrid_z )
deallocate( adpki )
deallocate( adomgai )
deallocate( admfxi )
deallocate( admfyi )
deallocate( adcxi )
deallocate( adcyi )


!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine adf_dyn


subroutine adzero
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_dynamics_mod, only : fv_dynamics
use mp_mod, only : domain,ie,ied,is,isd,je,jed,js,jsd
!jkimuse adtimingmodule, only : adtimingmodule_constructor

!==============================================
! all entries are defined explicitly
!==============================================
implicit none


!----------------------------------------------
! reset adjoint module variables
!----------------------------------------------
!jkimcall adtimingmodule_constructor

end subroutine adzero


