!                           DISCLAIMER
!
!   This file was generated by TAF version 1.9.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     adtracer_2d_mod
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use tpcore, only : fv_tp_2d
use grid_tools, only : area,dx,dxa,dy,dya,rarea
use grid_utils, only : sina_u,sina_v
use mp_mod, only : domain,gid,ie,ied,is,isd,je,jed,js,jsd,ng,mp_reduce_max
use mpp_domains_mod, only : mpp_update_domains
use timingmodule, only : timing_off, timing_on
use tracer_2d_mod

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine adtracer_2d( addp1, mfx, admfx, mfy, admfy, npz, q_split )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mp_mod, only : mp_reduce_max

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: npz
real, intent(inout) :: addp1(is:ie,js:je,npz)
real, intent(inout) :: admfx(is:ie+1,js:je,npz)
real, intent(inout) :: admfy(is:ie,js:je+1,npz)
real, intent(inout) :: mfx(is:ie+1,js:je,npz)
real, intent(inout) :: mfy(is:ie,js:je+1,npz)
integer, intent(in) :: q_split

!==============================================
! declare local variables
!==============================================
real :: adc_global
real :: adcmax(npz)
real :: addp2(isd:ied,jsd:jed)
real :: adfrac
real :: c_global
real :: cmax(npz)
real :: frac
integer :: i
integer :: it
integer :: j
integer :: k
integer :: nsplt

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adc_global = 0.
adcmax(:) = 0.
addp2(:,:) = 0.
adfrac = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (q_split .eq. 0) then
  call mp_reduce_max( cmax,npz )
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      c_global = max(cmax(k),c_global)
    end do
  endif
  nsplt = int(1.+c_global)
else
  nsplt = q_split
endif
frac = 1./real(nsplt)
do it = nsplt, 1, -1
  do k = 1, npz
    do j = js, je
      do i = is, ie
        addp2(i,j) = addp2(i,j)+addp1(i,j,k)
        addp1(i,j,k) = 0.
      end do
    end do
    do j = js, je
      do i = is, ie
        addp1(i,j,k) = addp1(i,j,k)+addp2(i,j)
        admfx(i+1,j,k) = admfx(i+1,j,k)-addp2(i,j)*rarea(i,j)
        admfx(i,j,k) = admfx(i,j,k)+addp2(i,j)*rarea(i,j)
        admfy(i,j+1,k) = admfy(i,j+1,k)-addp2(i,j)*rarea(i,j)
        admfy(i,j,k) = admfy(i,j,k)+addp2(i,j)*rarea(i,j)
        addp2(i,j) = 0.
      end do
    end do
  end do
end do
if (nsplt .ne. 1) then
  do k = 1, npz
    do j = js, je+1
      do i = is, ie
        adfrac = adfrac+admfy(i,j,k)*mfy(i,j,k)
        admfy(i,j,k) = admfy(i,j,k)*frac
      end do
    end do
    do j = js, je
      do i = is, ie+1
        adfrac = adfrac+admfx(i,j,k)*mfx(i,j,k)
        admfx(i,j,k) = admfx(i,j,k)*frac
      end do
    end do
  end do
endif
adfrac = 0.
if (q_split .eq. 0) then
  c_global = cmax(1)
  if (npz .ne. 1) then
    do k = 2, npz
      adcmax(k) = adcmax(k)+adc_global*(0.5+sign(0.5,cmax(k)-c_global))
      adc_global = adc_global*(0.5-sign(0.5,cmax(k)-c_global))
    end do
  endif
  adcmax(1) = adcmax(1)+adc_global
  adc_global = 0.
  call mp_reduce_max( adcmax,npz )
endif

end subroutine adtracer_2d


subroutine adtracer_2d_1l( q, adq, dp1, addp1, mfx, admfx, mfy, admfy, cx, adcx, cy, adcy, npx, npy, npz, nq, hord, q_split, k, &
&adq3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use adtpcore, only : adfv_tp_2d
use mp_mod, only : mp_reduce_max

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: adcx(is:ie+1,jsd:jed)
real, intent(inout) :: adcy(isd:ied,js:je+1)
real, intent(inout) :: addp1(is:ie,js:je)
real, intent(inout) :: admfx(is:ie+1,js:je)
real, intent(inout) :: admfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: adq(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: adq3(isd:ied,jsd:jed,npz,nq)
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: adcmax
real :: addp2(isd:ied,jsd:jed)
real :: adfrac
real :: adfx(is:ie+1,js:je)
real :: adfy(is:ie,js:je+1)
real :: adra_x(is:ie,jsd:jed)
real :: adra_y(isd:ied,js:je)
real :: adrdt
real :: adxfx(is:ie+1,jsd:jed)
real :: adyfx(isd:ied,js:je+1)
real :: cmax
real :: cxh(lbound(cx,1):ubound(cx,1),lbound(cx,2):ubound(cx,2))
real :: cyh(lbound(cy,1):ubound(cy,1),lbound(cy,2):ubound(cy,2))
real :: dp1h(lbound(dp1,1):ubound(dp1,1),lbound(dp1,2):ubound(dp1,2))
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
integer :: i
integer :: iq
integer :: iq1
integer :: it
integer :: it1
integer :: j
real :: mfxh(lbound(mfx,1):ubound(mfx,1),lbound(mfx,2):ubound(mfx,2))
real :: mfyh(lbound(mfy,1):ubound(mfy,1),lbound(mfy,2):ubound(mfy,2))
integer :: nsplt
real :: qh(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: qi(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: qj(lbound(q,1):ubound(q,1),lbound(q,2):ubound(q,2),lbound(q,3):ubound(q,3))
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
qj(:,:,:) = q(:,:,:)
mfyh(:,:) = mfy(:,:)
mfxh(:,:) = mfx(:,:)
dp1h(:,:) = dp1(:,:)
cyh(:,:) = cy(:,:)
cxh(:,:) = cx(:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adcmax = 0.
addp2(:,:) = 0.
adfrac = 0.
adfx(:,:) = 0.
adfy(:,:) = 0.
adra_x(:,:) = 0.
adra_y(:,:) = 0.
adrdt = 0.
adxfx(:,:) = 0.
adyfx(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (q_split .eq. 0) then
  call mp_reduce_max( cmax )
  nsplt = int(1.0001+cmax)
else
  nsplt = q_split
endif
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      cx(i,j) = cx(i,j)*frac
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      cy(i,j) = cy(i,j)*frac
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie
    ra_x(i,j) = area(i,j)+xfx(i,j)-xfx(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    ra_y(i,j) = area(i,j)+yfx(i,j)-yfx(i,j+1)
  end do
end do
if (id_divg .gt. 0) then
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      adrdt = adrdt+addp1(i,j)*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)
      adxfx(i+1,j) = adxfx(i+1,j)+addp1(i,j)*rarea(i,j)*rdt
      adxfx(i,j) = adxfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j+1) = adyfx(i,j+1)+addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j) = adyfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      addp1(i,j) = 0.
    end do
  end do
  adfrac = adfrac-adrdt*(1.*dt/(frac*dt*frac*dt))
  adrdt = 0.
endif
do it = nsplt, 1, -1
  dp1(:,:) = dp1h(:,:)
  q(:,:,:) = qj(:,:,:)
  do it1 = 1, it-1
    do j = js, je
      do i = is, ie
        dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
      end do
    end do
    do iq = 1, nq
      call fv_tp_2d( q(isd,jsd,iq),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx=mfx,mfy=mfy )
      if (it1 .eq. nsplt) then
      else
        do j = js, je
          do i = is, ie
            q(i,j,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      endif
    end do
    if (it1 .ne. nsplt) then
      do j = js, je
        do i = is, ie
          dp1(i,j) = dp2(i,j)
        end do
      end do
    endif
  end do
  qi(:,:,:) = q(:,:,:)
  do j = js, je
    do i = is, ie
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        addp2(i,j) = addp2(i,j)+addp1(i,j)
        addp1(i,j) = 0.
      end do
    end do
  endif
  do iq = nq, 1, -1
    q(:,:,:) = qi(:,:,:)
    do iq1 = 1, iq-1
      call fv_tp_2d( q(isd,jsd,iq1),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx=mfx,mfy=mfy )
      if (it .eq. nsplt) then
      else
        do j = js, je
          do i = is, ie
            q(i,j,iq1) = (q(i,j,iq1)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
          end do
        end do
      endif
    end do
    qh(:,:,:) = q(:,:,:)
    call fv_tp_2d( q(isd,jsd,iq),cx,cy,npx,npy,hord,fx,fy,xfx,yfx,area,ra_x,ra_y,uniform_ppm,mfx=mfx,mfy=mfy )
    if (it .eq. nsplt) then
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq3(i,j,k,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq3(i,j,k,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)+adq3(i,j,k,iq)*(dp1(i,j)/dp2(i,j))
          adq3(i,j,k,iq) = 0.
        end do
      end do
    else
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq(i,j,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq(i,j,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)*(dp1(i,j)/dp2(i,j))
        end do
      end do
    endif
    q(:,:,:) = qh(:,:,:)
    call adfv_tp_2d( q(isd,jsd,iq),adq(isd,jsd,iq),cx,adcx,cy,adcy,npx,npy,hord,adfx,adfy,xfx,adxfx,yfx,adyfx,area,ra_x,adra_x,&
&ra_y,adra_y,uniform_ppm,mfx=mfx,admfx=admfx,mfy=mfy,admfy=admfy )
  end do
  do j = js, je
    do i = is, ie
      addp1(i,j) = addp1(i,j)+addp2(i,j)
      admfx(i+1,j) = admfx(i+1,j)-addp2(i,j)*rarea(i,j)
      admfx(i,j) = admfx(i,j)+addp2(i,j)*rarea(i,j)
      admfy(i,j+1) = admfy(i,j+1)-addp2(i,j)*rarea(i,j)
      admfy(i,j) = admfy(i,j)+addp2(i,j)*rarea(i,j)
      addp2(i,j) = 0.
    end do
  end do
end do
do j = js, je
  do i = isd, ied
    adyfx(i,j+1) = adyfx(i,j+1)-adra_y(i,j)
    adyfx(i,j) = adyfx(i,j)+adra_y(i,j)
    adra_y(i,j) = 0.
  end do
end do
do j = jsd, jed
  do i = is, ie
    adxfx(i+1,j) = adxfx(i+1,j)-adra_x(i,j)
    adxfx(i,j) = adxfx(i,j)+adra_x(i,j)
    adra_x(i,j) = 0.
  end do
end do
cx(:,:) = cxh(:,:)
cy(:,:) = cyh(:,:)
mfx(:,:) = mfxh(:,:)
mfy(:,:) = mfyh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (nsplt .ne. 1) then
  do j = js, je+1
    do i = is, ie
      adfrac = adfrac+admfy(i,j)*mfy(i,j)
      admfy(i,j) = admfy(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      adfrac = adfrac+adyfx(i,j)*yfx(i,j)
      adyfx(i,j) = adyfx(i,j)*frac
      adfrac = adfrac+adcy(i,j)*cy(i,j)
      adcy(i,j) = adcy(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      adfrac = adfrac+admfx(i,j)*mfx(i,j)
      admfx(i,j) = admfx(i,j)*frac
    end do
  end do
  do j = jsd, jed
    do i = is, ie+1
      adfrac = adfrac+adxfx(i,j)*xfx(i,j)
      adxfx(i,j) = adxfx(i,j)*frac
      adfrac = adfrac+adcx(i,j)*cx(i,j)
      adcx(i,j) = adcx(i,j)*frac
    end do
  end do
endif
adfrac = 0.
if (q_split .eq. 0) then
  call mp_reduce_max( adcmax )
endif
cy(:,:) = cyh(:,:)
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    else
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    endif
  end do
end do
cx(:,:) = cxh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    else
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    endif
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine adtracer_2d_1l


end module     adtracer_2d_mod


